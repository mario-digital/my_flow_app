# Story 4.2: Transition Suggestions Service

## Status
Ready for Review 

## Story

**As a** backend developer,
**I want** intelligent transition suggestions when users switch contexts,
**so that** users are reminded of incomplete flows and priorities.

## Acceptance Criteria

1. **Suggestions method in `my_flow_api/src/services/transition_service.py`:**
   - `get_transition_suggestions(from_context_id: str, to_context_id: str, user_id: str) -> TransitionSuggestions`
   - Analyzes incomplete flows in target context
   - Identifies high-priority flows due soon
   - Returns structured suggestions: "Before switching, you have 2 high-priority flows in your Work context due today."

2. **Suggestions model created in `my_flow_api/src/models/transition.py`:**
   - `TransitionSuggestions`: `from_context`, `to_context`, `warnings` (List[str]), `suggestions` (List[str]), `urgent_flows` (List[FlowResponse])

3. **API endpoint created in `my_flow_api/src/routers/transitions.py`:**
   - `GET /api/v1/transitions/suggestions?from={context_id}&to={context_id}` → Returns `TransitionSuggestions`
   - Requires authentication

4. **Unit tests created in `my_flow_api/tests/unit/services/test_transition_service.py`:**
   - Tests suggestions with various flow states
   - Tests urgency detection (due today, overdue)
   - At least 80% coverage

## Tasks / Subtasks

- [x] **Task 0: Review existing flow service implementation** (AC: 1)
  - [x] Open `my_flow_api/src/services/flow_service.py` (from Epic 2)
  - [x] Review `FlowService` class structure
  - [x] Understand `get_flows_by_context()` method
  - [x] Review flow status computation logic
  - [x] Check `is_completed` and `due_date` field handling
  - [x] Document flow urgency determination logic

- [x] **Task 1: Create transition Pydantic models** (AC: 2)
  - [x] Create `my_flow_api/src/models/transition.py`
  - [x] Define `TransitionSuggestions` response model:
    ```python
    from pydantic import BaseModel, Field
    from typing import List
    from src.models.flow import FlowResponse
    
    class TransitionSuggestions(BaseModel):
        """
        Intelligent suggestions when users switch contexts.
        
        Provides warnings about incomplete flows and suggests priorities
        in the target context.
        """
        from_context: str = Field(description="Context ID user is leaving")
        to_context: str = Field(description="Context ID user is switching to")
        warnings: List[str] = Field(
            default_factory=list,
            description="Warning messages about incomplete flows in source context"
        )
        suggestions: List[str] = Field(
            default_factory=list,
            description="Actionable suggestions for target context"
        )
        urgent_flows: List[FlowResponse] = Field(
            default_factory=list,
            description="High-priority flows due soon or overdue in target context"
        )
        
        model_config = {
            "json_schema_extra": {
                "example": {
                    "from_context": "ctx-work-123",
                    "to_context": "ctx-personal-456",
                    "warnings": [
                        "You have 3 incomplete flows in Work context"
                    ],
                    "suggestions": [
                        "You have 2 high-priority flows due today in Personal context",
                        "1 flow is overdue in Personal context"
                    ],
                    "urgent_flows": [
                        {
                            "id": "flow-urgent-1",
                            "title": "Review Q4 budget",
                            "priority": "high",
                            "due_date": "2025-01-12T17:00:00Z",
                            "is_completed": False
                        }
                    ]
                }
            }
        }
    ```
  - [x] Import `FlowResponse` from `src.models.flow`
  - [x] Add model config with example for OpenAPI docs

- [x] **Task 2: Create transition service with suggestion logic** (AC: 1)
  - [x] Create `my_flow_api/src/services/transition_service.py`
  - [x] Import required dependencies:
    ```python
    from datetime import datetime, timedelta, timezone
    from typing import List
    from src.models.transition import TransitionSuggestions
    from src.models.flow import FlowResponse
    from src.repositories.flow_repository import FlowRepository
    from src.repositories.context_repository import ContextRepository
    ```
  - [x] Define `TransitionService` class:
    ```python
    class TransitionService:
        """
        Service for generating intelligent transition suggestions
        when users switch between contexts.
        """
        
        def __init__(
            self,
            flow_repository: FlowRepository,
            context_repository: ContextRepository
        ):
            self.flow_repository = flow_repository
            self.context_repository = context_repository
    ```
  - [x] Implement `get_transition_suggestions()` method:
    ```python
    async def get_transition_suggestions(
        self,
        from_context_id: str,
        to_context_id: str,
        user_id: str
    ) -> TransitionSuggestions:
        """
        Generate transition suggestions when switching contexts.
        
        Args:
            from_context_id: Context user is leaving
            to_context_id: Context user is switching to
            user_id: User making the switch
            
        Returns:
            TransitionSuggestions with warnings and priorities
        """
        # 1. Fetch incomplete flows from source context
        from_flows = await self.flow_repository.get_flows_by_context(
            context_id=from_context_id,
            user_id=user_id
        )
        incomplete_from = [f for f in from_flows if not f.is_completed]
        
        # 2. Fetch flows from target context
        to_flows = await self.flow_repository.get_flows_by_context(
            context_id=to_context_id,
            user_id=user_id
        )
        incomplete_to = [f for f in to_flows if not f.is_completed]
        
        # 3. Generate warnings about source context
        warnings = self._generate_warnings(incomplete_from, from_context_id)
        
        # 4. Identify urgent flows in target context
        urgent_flows = self._identify_urgent_flows(incomplete_to)
        
        # 5. Generate suggestions for target context
        suggestions = self._generate_suggestions(
            incomplete_to,
            urgent_flows,
            to_context_id
        )
        
        return TransitionSuggestions(
            from_context=from_context_id,
            to_context=to_context_id,
            warnings=warnings,
            suggestions=suggestions,
            urgent_flows=urgent_flows
        )
    ```
  - [x] Add dependency injection for repositories

- [x] **Task 3: Implement warning generation logic** (AC: 1)
  - [x] Add `_generate_warnings()` helper method:
    ```python
    def _generate_warnings(
        self,
        incomplete_flows: List[FlowResponse],
        context_id: str
    ) -> List[str]:
        """
        Generate warning messages about incomplete flows in source context.
        
        Args:
            incomplete_flows: List of incomplete flows
            context_id: Source context ID
            
        Returns:
            List of warning messages
        """
        warnings = []
        
        if len(incomplete_flows) == 0:
            return warnings
        
        # Count high-priority incomplete flows
        high_priority_count = sum(
            1 for f in incomplete_flows if f.priority == "high"
        )
        
        # Generate appropriate warning message
        if len(incomplete_flows) == 1:
            warnings.append(
                f"You have 1 incomplete flow in this context"
            )
        else:
            warnings.append(
                f"You have {len(incomplete_flows)} incomplete flows in this context"
            )
        
        if high_priority_count > 0:
            warnings.append(
                f"{high_priority_count} of them are high priority"
            )
        
        return warnings
    ```
  - [x] Handle singular vs plural flow counts
  - [x] Highlight high-priority flows in warnings

- [x] **Task 4: Implement urgent flow identification** (AC: 1)
  - [x] Add `_identify_urgent_flows()` helper method:
    ```python
    def _identify_urgent_flows(
        self,
        flows: List[FlowResponse]
    ) -> List[FlowResponse]:
        """
        Identify urgent flows (due today, overdue, or high priority).
        
        Args:
            flows: List of flows to analyze
            
        Returns:
            List of urgent flows sorted by due date
        """
        now = datetime.now(timezone.utc)
        today_end = (now + timedelta(days=1)).replace(
            hour=0, minute=0, second=0, microsecond=0
        )
        
        urgent = []
        
        for flow in flows:
            # Already completed flows are not urgent
            if flow.is_completed:
                continue
            
            # Check if flow has a due date
            if flow.due_date:
                # Parse due_date (ISO 8601 string to datetime)
                due_dt = datetime.fromisoformat(
                    flow.due_date.replace('Z', '+00:00')
                )
                
                # Urgent if: overdue OR due today
                if due_dt < now or due_dt <= today_end:
                    urgent.append(flow)
                # Also urgent if high priority and due within 3 days
                elif flow.priority == "high" and due_dt <= now + timedelta(days=3):
                    urgent.append(flow)
            # No due date but high priority
            elif flow.priority == "high":
                urgent.append(flow)
        
        # Sort by due date (overdue first, then soonest)
        urgent.sort(key=lambda f: (
            f.due_date if f.due_date else "9999-12-31T23:59:59Z"
        ))
        
        return urgent
    ```
  - [x] Check for overdue flows (due_date < now)
  - [x] Check for flows due today (due_date <= end of today)
  - [x] Check for high-priority flows due within 3 days
  - [x] Include high-priority flows without due dates
  - [x] Sort urgent flows by due date (overdue first)
  - [x] Handle timezone-aware datetime comparisons

- [x] **Task 5: Implement suggestion generation logic** (AC: 1)
  - [x] Add `_generate_suggestions()` helper method:
    ```python
    def _generate_suggestions(
        self,
        incomplete_flows: List[FlowResponse],
        urgent_flows: List[FlowResponse],
        context_id: str
    ) -> List[str]:
        """
        Generate actionable suggestions for target context.
        
        Args:
            incomplete_flows: All incomplete flows in target context
            urgent_flows: Urgent flows in target context
            context_id: Target context ID
            
        Returns:
            List of suggestion messages
        """
        suggestions = []
        
        # No incomplete flows - positive message
        if len(incomplete_flows) == 0:
            suggestions.append("No pending flows in this context")
            return suggestions
        
        # Count flows by urgency
        overdue_count = 0
        due_today_count = 0
        now = datetime.now(timezone.utc)
        today_end = (now + timedelta(days=1)).replace(
            hour=0, minute=0, second=0, microsecond=0
        )
        
        for flow in urgent_flows:
            if flow.due_date:
                due_dt = datetime.fromisoformat(
                    flow.due_date.replace('Z', '+00:00')
                )
                if due_dt < now:
                    overdue_count += 1
                elif due_dt <= today_end:
                    due_today_count += 1
        
        # Generate suggestions based on urgency
        if overdue_count > 0:
            suggestions.append(
                f"{overdue_count} flow{'s' if overdue_count > 1 else ''} overdue in this context"
            )
        
        if due_today_count > 0:
            suggestions.append(
                f"{due_today_count} high-priority flow{'s' if due_today_count > 1 else ''} due today"
            )
        
        # If urgent but not overdue/due today, mention priorities
        if len(urgent_flows) > 0 and overdue_count == 0 and due_today_count == 0:
            suggestions.append(
                f"You have {len(urgent_flows)} high-priority flow{'s' if len(urgent_flows) > 1 else ''} in this context"
            )
        
        # Total incomplete flows count
        if len(incomplete_flows) > len(urgent_flows):
            suggestions.append(
                f"{len(incomplete_flows)} total incomplete flows"
            )
        
        return suggestions
    ```
  - [x] Check for overdue flows
  - [x] Check for flows due today
  - [x] Generate positive message when no incomplete flows
  - [x] Handle singular vs plural flow counts

- [x] **Task 6: Create transitions API router** (AC: 3)
  - [x] Create `my_flow_api/src/routers/transitions.py`
  - [x] Import required dependencies:
    ```python
    from fastapi import APIRouter, Depends, Query, HTTPException
    from typing import Annotated
    from src.models.transition import TransitionSuggestions
    from src.services.transition_service import TransitionService
    from src.repositories.flow_repository import FlowRepository
    from src.repositories.context_repository import ContextRepository
    from src.database import get_database
    from src.middleware.auth import get_current_user_id
    from motor.motor_asyncio import AsyncIOMotorDatabase
    ```
  - [x] Create router instance:
    ```python
    router = APIRouter(
        prefix="/api/v1/transitions",
        tags=["transitions"]
    )
    ```
  - [x] Define dependency injection for service:
    ```python
    async def get_transition_service(
        db: Annotated[AsyncIOMotorDatabase, Depends(get_database)]
    ) -> TransitionService:
        """Dependency injection for TransitionService."""
        flow_repo = FlowRepository(db)
        context_repo = ContextRepository(db)
        return TransitionService(flow_repo, context_repo)
    ```
  - [x] Implement GET endpoint:
    ```python
    @router.get("/suggestions", response_model=TransitionSuggestions)
    async def get_transition_suggestions(
        from_context: Annotated[str, Query(alias="from", description="Context ID user is leaving")],
        to_context: Annotated[str, Query(alias="to", description="Context ID user is switching to")],
        user_id: Annotated[str, Depends(get_current_user_id)],
        service: Annotated[TransitionService, Depends(get_transition_service)]
    ) -> TransitionSuggestions:
        """
        Get intelligent suggestions when switching contexts.
        
        Analyzes incomplete flows and priorities to provide warnings
        about the source context and suggestions for the target context.
        
        **Query Parameters:**
        - `from`: Context ID user is leaving
        - `to`: Context ID user is switching to
        
        **Returns:**
        - Warnings about incomplete flows in source context
        - Suggestions for target context (urgent flows, priorities)
        - List of urgent flows in target context
        
        **Example:**
        ```
        GET /api/v1/transitions/suggestions?from=ctx-work-123&to=ctx-personal-456
        ```
        """
        try:
            suggestions = await service.get_transition_suggestions(
                from_context_id=from_context,
                to_context_id=to_context,
                user_id=user_id
            )
            return suggestions
        except Exception as e:
            raise HTTPException(
                status_code=500,
                detail=f"Failed to generate transition suggestions: {str(e)}"
            )
    ```
  - [x] Use query parameter aliases (`from` and `to`)
  - [x] Add comprehensive docstring with example
  - [x] Add error handling

- [x] **Task 7: Register transitions router in main app** (AC: 3)
  - [x] Open `my_flow_api/src/main.py`
  - [x] Import transitions router:
    ```python
    from src.routers import contexts, flows, preferences, transitions
    ```
  - [x] Register router with app:
    ```python
    app.include_router(transitions.router)
    ```
  - [x] Ensure router is registered after database connection
  - [x] Verify router appears in OpenAPI docs at `/docs`

- [x] **Task 8: Write unit tests for transition service** (AC: 4)
  - [x] Create `my_flow_api/tests/unit/services/test_transition_service.py`
  - [x] Import test dependencies:
    ```python
    import pytest
    from datetime import datetime, timedelta, timezone
    from unittest.mock import AsyncMock, MagicMock
    from src.services.transition_service import TransitionService
    from src.models.transition import TransitionSuggestions
    from src.models.flow import FlowResponse
    ```
  - [x] Create mock repositories fixture:
    ```python
    @pytest.fixture
    def mock_flow_repo():
        return AsyncMock()
    
    @pytest.fixture
    def mock_context_repo():
        return AsyncMock()
    
    @pytest.fixture
    def transition_service(mock_flow_repo, mock_context_repo):
        return TransitionService(mock_flow_repo, mock_context_repo)
    ```
  - [x] Test: `test_no_incomplete_flows()`:
    ```python
    @pytest.mark.asyncio
    async def test_no_incomplete_flows(
        transition_service,
        mock_flow_repo
    ):
        """Test suggestions when no incomplete flows exist."""
        # Mock: No flows in either context
        mock_flow_repo.get_flows_by_context.return_value = []
        
        result = await transition_service.get_transition_suggestions(
            from_context_id="ctx-work",
            to_context_id="ctx-personal",
            user_id="user123"
        )
        
        assert result.from_context == "ctx-work"
        assert result.to_context == "ctx-personal"
        assert len(result.warnings) == 0
        assert "No pending flows" in result.suggestions[0]
        assert len(result.urgent_flows) == 0
    ```
  - [x] Test: `test_incomplete_flows_in_source_context()`:
    ```python
    @pytest.mark.asyncio
    async def test_incomplete_flows_in_source_context(
        transition_service,
        mock_flow_repo
    ):
        """Test warnings when source context has incomplete flows."""
        # Mock: 3 incomplete flows in source, none in target
        mock_flow_repo.get_flows_by_context.side_effect = [
            # Source context (from)
            [
                FlowResponse(
                    id="f1", title="Task 1", priority="high",
                    is_completed=False, context_id="ctx-work",
                    user_id="user123", created_at=datetime.now(timezone.utc),
                    updated_at=datetime.now(timezone.utc)
                ),
                FlowResponse(
                    id="f2", title="Task 2", priority="medium",
                    is_completed=False, context_id="ctx-work",
                    user_id="user123", created_at=datetime.now(timezone.utc),
                    updated_at=datetime.now(timezone.utc)
                ),
                FlowResponse(
                    id="f3", title="Task 3", priority="low",
                    is_completed=False, context_id="ctx-work",
                    user_id="user123", created_at=datetime.now(timezone.utc),
                    updated_at=datetime.now(timezone.utc)
                )
            ],
            # Target context (to)
            []
        ]
        
        result = await transition_service.get_transition_suggestions(
            from_context_id="ctx-work",
            to_context_id="ctx-personal",
            user_id="user123"
        )
        
        assert len(result.warnings) > 0
        assert "3 incomplete flows" in result.warnings[0]
        assert "1 of them are high priority" in result.warnings[1]
    ```
  - [x] Test: `test_urgent_flows_due_today()`:
    ```python
    @pytest.mark.asyncio
    async def test_urgent_flows_due_today(
        transition_service,
        mock_flow_repo
    ):
        """Test detection of flows due today."""
        # Mock: Flow due today in target context
        due_today = datetime.now(timezone.utc) + timedelta(hours=3)
        
        mock_flow_repo.get_flows_by_context.side_effect = [
            [],  # Source context
            [
                FlowResponse(
                    id="f1", title="Urgent Task", priority="high",
                    is_completed=False, due_date=due_today.isoformat(),
                    context_id="ctx-personal", user_id="user123",
                    created_at=datetime.now(timezone.utc),
                    updated_at=datetime.now(timezone.utc)
                )
            ]
        ]
        
        result = await transition_service.get_transition_suggestions(
            from_context_id="ctx-work",
            to_context_id="ctx-personal",
            user_id="user123"
        )
        
        assert len(result.urgent_flows) == 1
        assert result.urgent_flows[0].id == "f1"
        assert "due today" in result.suggestions[0]
    ```
  - [x] Test: `test_overdue_flows()`:
    ```python
    @pytest.mark.asyncio
    async def test_overdue_flows(
        transition_service,
        mock_flow_repo
    ):
        """Test detection of overdue flows."""
        # Mock: Overdue flow in target context
        overdue = datetime.now(timezone.utc) - timedelta(days=2)
        
        mock_flow_repo.get_flows_by_context.side_effect = [
            [],  # Source context
            [
                FlowResponse(
                    id="f1", title="Overdue Task", priority="high",
                    is_completed=False, due_date=overdue.isoformat(),
                    context_id="ctx-personal", user_id="user123",
                    created_at=datetime.now(timezone.utc),
                    updated_at=datetime.now(timezone.utc)
                )
            ]
        ]
        
        result = await transition_service.get_transition_suggestions(
            from_context_id="ctx-work",
            to_context_id="ctx-personal",
            user_id="user123"
        )
        
        assert len(result.urgent_flows) == 1
        assert "overdue" in result.suggestions[0]
    ```
  - [x] Test: `test_high_priority_without_due_date()`:
    ```python
    @pytest.mark.asyncio
    async def test_high_priority_without_due_date(
        transition_service,
        mock_flow_repo
    ):
        """Test urgent flows with high priority but no due date."""
        mock_flow_repo.get_flows_by_context.side_effect = [
            [],  # Source context
            [
                FlowResponse(
                    id="f1", title="Important Task", priority="high",
                    is_completed=False, due_date=None,
                    context_id="ctx-personal", user_id="user123",
                    created_at=datetime.now(timezone.utc),
                    updated_at=datetime.now(timezone.utc)
                )
            ]
        ]
        
        result = await transition_service.get_transition_suggestions(
            from_context_id="ctx-work",
            to_context_id="ctx-personal",
            user_id="user123"
        )
        
        assert len(result.urgent_flows) == 1
        assert "high-priority" in result.suggestions[0]
    ```
  - [x] Run tests: `cd my_flow_api && pytest tests/unit/services/test_transition_service.py -v`

- [x] **Task 9: Write integration tests for API endpoint** (AC: 3, 4)
  - [x] Create `my_flow_api/tests/integration/test_transitions_router.py`
  - [x] Import test dependencies:
    ```python
    import pytest
    from httpx import AsyncClient
    from datetime import datetime, timedelta, timezone
    from src.main import app
    from src.database import get_database
    ```
  - [x] Test: `test_get_suggestions_endpoint()`:
    ```python
    @pytest.mark.asyncio
    async def test_get_suggestions_endpoint(
        async_client: AsyncClient,
        test_db,
        mock_auth_user
    ):
        """Test GET /api/v1/transitions/suggestions endpoint."""
        # Setup: Create contexts and flows in test DB
        # ... (create test data)
        
        response = await async_client.get(
            "/api/v1/transitions/suggestions",
            params={
                "from": "ctx-work",
                "to": "ctx-personal"
            }
        )
        
        assert response.status_code == 200
        data = response.json()
        assert "from_context" in data
        assert "to_context" in data
        assert "warnings" in data
        assert "suggestions" in data
        assert "urgent_flows" in data
    ```
  - [x] Test: `test_unauthorized_access()`:
    ```python
    @pytest.mark.asyncio
    async def test_unauthorized_access(async_client: AsyncClient):
        """Test endpoint requires authentication."""
        response = await async_client.get(
            "/api/v1/transitions/suggestions",
            params={"from": "ctx1", "to": "ctx2"}
        )
        
        assert response.status_code == 401
    ```
  - [x] Test: `test_missing_query_params()`:
    ```python
    @pytest.mark.asyncio
    async def test_missing_query_params(
        async_client: AsyncClient,
        mock_auth_user
    ):
        """Test endpoint validates required query parameters."""
        response = await async_client.get(
            "/api/v1/transitions/suggestions"
            # Missing 'from' and 'to' params
        )
        
        assert response.status_code == 422  # Validation error
    ```
  - [x] Run tests: `cd my_flow_api && pytest tests/integration/test_transitions_router.py -v`

- [x] **Task 10: Run all tests and verify coverage** (AC: 4)
  - [x] Run full test suite:
    ```bash
    cd my_flow_api
    pytest tests/unit/services/test_transition_service.py -v
    pytest tests/integration/test_transitions_router.py -v
    ```
  - [x] Run coverage report:
    ```bash
    pytest tests/unit/services/test_transition_service.py \
        --cov=src/services/transition_service \
        --cov-report=term-missing
    ```
  - [x] Verify coverage ≥ 80%
  - [x] Fix any failing tests
  - [x] Document any edge cases discovered

- [x] **Task 11: Manual testing with API client** (AC: 3)
  - [x] Start backend server: `cd my_flow_api && python -m src.main`
  - [x] Open API docs: `http://localhost:8000/docs`
  - [x] Authenticate with test user (JWT token)
  - [x] Create test contexts via `/api/v1/contexts` (if not exist)
  - [x] Create test flows with different priorities and due dates:
    - Flow 1: High priority, due today
    - Flow 2: Medium priority, overdue
    - Flow 3: Low priority, no due date
  - [x] Call suggestions endpoint:
    ```bash
    curl -X GET "http://localhost:8000/api/v1/transitions/suggestions?from=ctx-work&to=ctx-personal" \
      -H "Authorization: Bearer <token>"
    ```
  - [x] Verify response includes:
    - Warnings about incomplete flows in source context
    - Suggestions about urgent flows in target context
    - Urgent flows array with correct flows
  - [x] Test edge cases:
    - No incomplete flows
    - All flows completed
    - Mix of priorities and due dates
  - [x] Document manual test results

- [x] **Task 12: Code quality and compliance** (AC: All)
  - [x] Run linter: `cd my_flow_api && ruff check src/`
  - [x] Fix any linting errors
  - [x] Run type checker: `mypy src/`
  - [x] Fix any type errors
  - [x] Ensure all functions have docstrings
  - [x] Verify error handling is comprehensive
  - [x] Check for proper async/await usage
  - [x] Ensure user isolation (user_id filtering)

## Dev Notes

### Previous Story Integration

**From Story 4.1 (Context Summary Generation):**
- AI service exists in `my_flow_api/src/services/ai_service.py`
- Pattern for AI-powered suggestions established
- Caching strategy for AI API calls (5 minutes)
- Integration with flow and conversation data

**From Epic 2 (Flow Service):**
- `FlowService` exists in `my_flow_api/src/services/flow_service.py`
- `FlowRepository` has `get_flows_by_context()` method
- Flow models include `priority`, `due_date`, `is_completed` fields
- Status computation logic for flows

**From Epic 2 (Context Service):**
- `ContextRepository` exists for context data access
- Context validation and user isolation patterns established

**Integration Point:**
This story creates a NEW service (`TransitionService`) that analyzes flows when users switch contexts, complementing Story 4.1's AI-powered summaries.

[Source: docs/stories/4.1.story.md, docs/architecture/backend-architecture.md]

---

### Backend Architecture Patterns

**Service Layer Pattern:**
- Services contain business logic
- Services depend on repositories (data access)
- Services are injected via FastAPI Depends()
- Services are async for MongoDB operations

**Repository Layer Pattern:**
- Repositories handle MongoDB CRUD operations
- Repositories enforce user isolation (user_id filtering)
- Repositories use Motor (async MongoDB driver)
- Repositories inherit from `BaseRepository` where applicable

**Router Layer Pattern:**
- Routers define API endpoints
- Routers use dependency injection for services
- Routers validate request/response with Pydantic models
- Routers handle authentication via middleware

[Source: docs/architecture/backend-architecture.md]

---

### Flow Urgency Logic

**Urgency Determination:**

A flow is considered "urgent" if ANY of these conditions are met:

1. **Overdue:** `due_date < now`
2. **Due today:** `due_date <= end_of_today`
3. **High priority + due within 3 days:** `priority == "high" AND due_date <= now + 3 days`
4. **High priority + no due date:** `priority == "high" AND due_date is None`

**Priority Levels:**
- `"high"` - Urgent, requires immediate attention
- `"medium"` - Standard priority
- `"low"` - Can be deferred

**Sorting:**
- Urgent flows sorted by due date (overdue first, then soonest)
- Flows without due dates sorted last

[Source: docs/architecture/data-models.md - Flow Model]

---

### Transition Suggestions Logic

**Warning Generation (Source Context):**
1. Count incomplete flows
2. Count high-priority incomplete flows
3. Generate appropriate warning message:
   - "You have 3 incomplete flows in this context"
   - "2 of them are high priority"

**Suggestion Generation (Target Context):**
1. Identify overdue flows
2. Identify flows due today
3. Identify high-priority flows
4. Generate suggestions in priority order:
   - First: Overdue flows count
   - Second: Flows due today count
   - Third: High-priority flows count
   - Fourth: Total incomplete flows count

**Edge Cases:**
- No incomplete flows → Positive message: "No pending flows in this context"
- All flows completed → No warnings or suggestions
- Mix of priorities → Highlight highest priority first

---

### API Endpoint Design

**Endpoint:** `GET /api/v1/transitions/suggestions`

**Query Parameters:**
- `from` - Context ID user is leaving (required)
- `to` - Context ID user is switching to (required)

**Authentication:**
- Requires JWT token in `Authorization: Bearer <token>` header
- User ID extracted from JWT token
- User isolation enforced (only user's flows analyzed)

**Response Model:**
```json
{
  "from_context": "ctx-work-123",
  "to_context": "ctx-personal-456",
  "warnings": [
    "You have 3 incomplete flows in this context",
    "2 of them are high priority"
  ],
  "suggestions": [
    "2 flows overdue in this context",
    "1 high-priority flow due today"
  ],
  "urgent_flows": [
    {
      "id": "flow-1",
      "title": "Review Q4 budget",
      "priority": "high",
      "due_date": "2025-01-12T17:00:00Z",
      "is_completed": false
    }
  ]
}
```

**Error Handling:**
- 401: Unauthorized (missing/invalid JWT)
- 422: Validation Error (missing query params)
- 500: Internal Server Error (database/service error)

[Source: Epic 4.2 AC 3]

---

### Testing Strategy

**Unit Tests (80% coverage target):**

Test scenarios:
1. No incomplete flows
2. Incomplete flows in source context only
3. Incomplete flows in target context only
4. Urgent flows due today
5. Overdue flows
6. High-priority flows without due dates
7. Mix of priorities and due dates
8. Edge cases (completed flows ignored, timezone handling)

**Integration Tests:**

Test scenarios:
1. End-to-end API endpoint with authentication
2. Query parameter validation
3. Unauthorized access
4. Database integration

**Manual Testing:**
- Test with real MongoDB data
- Verify suggestions accuracy
- Test various time zones
- Validate user isolation

[Source: docs/architecture/13-testing-strategy.md]

---

### File Structure & Dependencies

**New Files to Create:**
- `my_flow_api/src/models/transition.py` - Pydantic models
- `my_flow_api/src/services/transition_service.py` - Business logic
- `my_flow_api/src/routers/transitions.py` - API endpoints
- `my_flow_api/tests/unit/services/test_transition_service.py` - Unit tests
- `my_flow_api/tests/integration/test_transitions_router.py` - Integration tests

**Existing Files to Modify:**
- `my_flow_api/src/main.py` - Register transitions router

**Dependencies:**
- `FlowRepository` (existing) - Fetch flows by context
- `ContextRepository` (existing) - Validate contexts
- `FlowResponse` model (existing) - Flow response schema
- Authentication middleware (existing) - JWT validation

[Source: docs/architecture/backend-architecture.md - Service Organization]

---

### Python Code Standards

**Async/Await:**
- All repository methods are async (MongoDB operations)
- All service methods are async (call repositories)
- Use `await` for all async calls

**Type Hints:**
- All function parameters have type hints
- All return types specified
- Use `List[T]`, `Optional[T]` from `typing`

**Error Handling:**
- Use try/except for database operations
- Raise HTTPException with appropriate status codes
- Log errors for debugging

**Docstrings:**
- All classes have docstrings
- All public methods have docstrings
- Use Google-style docstrings with Args/Returns sections

[Source: docs/architecture/backend-architecture.md]

---

### DateTime Handling

**Critical Rules:**
1. **Always use timezone-aware datetimes** (`timezone.utc`)
2. **Parse ISO 8601 strings** with `.replace('Z', '+00:00')`
3. **Compare datetimes** in UTC timezone
4. **Store datetimes** as ISO 8601 strings in MongoDB

**Example:**
```python
from datetime import datetime, timezone

# Current time (UTC)
now = datetime.now(timezone.utc)

# Parse ISO 8601 string
due_dt = datetime.fromisoformat(
    flow.due_date.replace('Z', '+00:00')
)

# Compare
is_overdue = due_dt < now

# End of today (UTC)
today_end = (now + timedelta(days=1)).replace(
    hour=0, minute=0, second=0, microsecond=0
)
```

[Source: docs/architecture/backend-architecture.md]

---

## Testing

### Test File Organization

**Unit Tests:**
```
my_flow_api/tests/unit/services/
└── test_transition_service.py  (NEW - create in this story)
```

**Integration Tests:**
```
my_flow_api/tests/integration/
└── test_transitions_router.py  (NEW - create in this story)
```

[Source: docs/architecture/13-testing-strategy.md]

---

### Running Tests

```bash
# Run unit tests
cd my_flow_api
pytest tests/unit/services/test_transition_service.py -v

# Run with coverage
pytest tests/unit/services/test_transition_service.py \
    --cov=src/services/transition_service \
    --cov-report=term-missing

# Run integration tests
pytest tests/integration/test_transitions_router.py -v

# Run all tests
pytest tests/ -v
```

[Source: docs/architecture/13-testing-strategy.md]

---

### Manual Testing Workflow

**Setup:**
1. Start backend: `cd my_flow_api && python -m src.main`
2. Open API docs: `http://localhost:8000/docs`
3. Authenticate with test JWT token

**Test Scenario 1: Incomplete Flows in Source**
1. Create "Work" context
2. Add 3 incomplete flows (1 high, 1 medium, 1 low priority)
3. Create "Personal" context with no flows
4. Call `/api/v1/transitions/suggestions?from=ctx-work&to=ctx-personal`
5. ✓ Verify warnings about 3 incomplete flows
6. ✓ Verify "1 of them are high priority" in warnings

**Test Scenario 2: Urgent Flows in Target**
1. Create flows in "Personal" context:
   - Flow 1: High priority, due today
   - Flow 2: Medium priority, overdue (2 days ago)
2. Call `/api/v1/transitions/suggestions?from=ctx-work&to=ctx-personal`
3. ✓ Verify "1 flow overdue" in suggestions
4. ✓ Verify "1 high-priority flow due today" in suggestions
5. ✓ Verify `urgent_flows` array contains both flows

**Test Scenario 3: No Incomplete Flows**
1. Complete all flows in both contexts
2. Call `/api/v1/transitions/suggestions?from=ctx-work&to=ctx-personal`
3. ✓ Verify no warnings
4. ✓ Verify "No pending flows in this context" in suggestions
5. ✓ Verify `urgent_flows` array is empty

**Test Scenario 4: Edge Cases**
1. Test with non-existent context IDs
2. Test with invalid JWT token
3. Test with missing query parameters
4. Verify appropriate error responses

[Source: Epic 4.2 AC 4]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-12 | 1.0 | Story created for Epic 4.2 - Transition Suggestions Service | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (via Cursor IDE)

### Debug Log References
- Unit tests: All 9 tests passed with 100% coverage of transition_service.py
- Integration tests: All 9 tests passed with 88% coverage of transitions.py router
- Linting: Ruff checks passed with no issues
- Type checking: Mypy validation passed with no issues

### Completion Notes List
- Created TransitionSuggestions Pydantic model with comprehensive example for OpenAPI docs
- Implemented TransitionService with intelligent suggestion logic:
  - Analyzes incomplete flows in source and target contexts
  - Identifies urgent flows (due today, overdue, high priority)
  - Generates contextual warnings and suggestions
  - Sorts urgent flows by due date (overdue first)
- Created API endpoint `GET /api/v1/transitions/suggestions` with query params `from` and `to`
- Registered transitions router in main.py
- Wrote comprehensive unit tests (9 tests) covering all scenarios
- Wrote integration tests (9 tests) for API endpoint validation
- Fixed all linting and type checking errors
- All tests pass successfully with excellent coverage

### File List
**New Files Created:**
- `my_flow_api/src/models/transition.py` - Pydantic model for transition suggestions
- `my_flow_api/src/services/transition_service.py` - Business logic for transition suggestions
- `my_flow_api/src/routers/transitions.py` - API endpoint for suggestions
- `my_flow_api/tests/unit/services/test_transition_service.py` - Unit tests (100% coverage)
- `my_flow_api/tests/integration/routers/test_transitions.py` - Integration tests

**Modified Files:**
- `my_flow_api/src/main.py` - Added transitions router registration

## QA Results

### Review Date
(To be populated by QA Agent)

### Reviewed By
(To be populated by QA Agent)

### Executive Summary
(To be populated by QA Agent)

