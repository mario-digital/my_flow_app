# Story 2.8: TanStack Query Integration for Flows API (FE)

## Status
Draft

## Story

**As a** frontend developer,
**I want** TanStack Query hooks for flow API operations,
**so that** we have optimistic updates, caching, and automatic refetching for flow management.

## Acceptance Criteria

1. **API client created in `my_flow_client/src/lib/api/flows.ts`:**
   - `fetchFlowsByContext(contextId: string)` → GET /api/v1/contexts/{contextId}/flows
   - `fetchFlowById(id: string)` → GET /api/v1/flows/{id}
   - `createFlow(data: FlowCreate)` → POST /api/v1/flows
   - `updateFlow(id: string, data: FlowUpdate)` → PUT /api/v1/flows/{id}
   - `deleteFlow(id: string)` → DELETE /api/v1/flows/{id}
   - `completeFlow(id: string)` → PATCH /api/v1/flows/{id}/complete
   - All methods use server action `apiRequest` from `@/lib/api-client` with Logto auth
   - TypeScript types imported directly from generated OpenAPI typings (`@/types/api`, e.g., `components['schemas']['FlowResponse']`)

2. **TanStack Query hooks created in `my_flow_client/src/hooks/use-flows.ts`:**
   - `useFlows(contextId: string)` → Uses `useQuery` to fetch flows for context
   - `useFlow(id: string)` → Uses `useQuery` to fetch single flow
   - `useCreateFlow()` → Uses `useMutation` with optimistic update
   - `useUpdateFlow()` → Uses `useMutation` with optimistic update
   - `useDeleteFlow()` → Uses `useMutation` with optimistic update
   - `useCompleteFlow()` → Uses `useMutation` with optimistic update

3. **Query configuration follows best practices:**
   - `staleTime: 2 minutes` for flow lists (flows change more frequently than contexts)
   - `gcTime: 5 minutes` for list queries (prevents premature eviction)
   - `gcTime: 2 minutes` for detail queries to avoid unbounded cache growth
   - `refetchOnWindowFocus: true` for automatic sync
   - `enabled` guard prevents queries when user is not authenticated
   - `mutationKey` required on all mutations to prevent duplicate submissions from double-clicks
   - Optimistic updates show immediate feedback (e.g., checkbox checked before API confirms)
   - Query hooks (`useFlows`, `useFlow`) do not use deprecated `onError`; instead, they expose `error` so consuming components can handle notifications (see Dev Notes pattern)
   - Parallel data requirements (list + detail) should use `prefetchQuery` (see Task 7 Dev Notes example) to keep UI responsive
   - QueryClient options should cap cache growth (e.g., ensure default `gcTime` matches above and consider `maxPages`/`maxAge` if future list sizes expand)
   - CSRF protection handled via server actions (`apiRequest`) — verify no client-side mutation bypasses these helpers

4. **Query keys follow consistent pattern:**
   ```typescript
   const flowKeys = {
     all: ['flows'] as const,
     lists: () => [...flowKeys.all, 'list'] as const,
     list: (contextId: string) => [...flowKeys.lists(), contextId] as const,
     details: () => [...flowKeys.all, 'detail'] as const,
     detail: (id: string) => [...flowKeys.details(), id] as const,
   }
   ```

5. **Mutation keys follow hierarchical pattern:**
   ```typescript
   const flowMutations = {
     create: ['flows', 'create'] as const,
     update: (id: string) => ['flows', 'update', id] as const,
     delete: (id: string) => ['flows', 'delete', id] as const,
     complete: (id: string) => ['flows', 'complete', id] as const,
   }
   ```

6. **TypeScript types generated from backend OpenAPI schema (no manual duplication):**
   - `openapi-typescript` output stored at `my_flow_client/src/types/api.ts` (auto-generated, do not edit)
   - Story code imports required types directly from `@/types/api` using `components['schemas'][...]`
   - No additional alias files (e.g., `@/types/flow`) should be created unless future standards explicitly add them

7. **Cache invalidation strategy:**
   - Creating flow invalidates `flowKeys.list(contextId)`
   - Updating flow invalidates both `flowKeys.list(contextId)` and `flowKeys.detail(id)`
   - Deleting flow invalidates `flowKeys.list(contextId)`
   - Completing flow invalidates both queries

8. **Integration tests created in `my_flow_client/src/hooks/__tests__/use-flows.test.tsx`:**
   - Uses `@testing-library/react` with `QueryClientProvider` wrapper
   - Uses MSW (Mock Service Worker) for API mocking
   - Tests successful fetch, create, update, delete, complete operations
   - Tests optimistic updates (UI reflects changes before API confirms)
   - Tests error rollback (optimistic update reverted on API error)
   - Tests cache invalidation strategy
   - At least 80% coverage

## Tasks / Subtasks

- [ ] **Task 0: Verify and install dependencies** (AC: 2, 3, 8)
  - [ ] Check if `@tanstack/react-query` is installed: `bun pm ls | grep @tanstack/react-query`
  - [ ] If not installed: `cd my_flow_client && bun add @tanstack/react-query@5.x`
  - [ ] Check if `msw` (Mock Service Worker) is installed: `bun pm ls | grep msw`
  - [ ] If not installed for testing: `cd my_flow_client && bun add -d msw@latest`
  - [ ] Check if `sonner` (toast library) is installed: `bun pm ls | grep sonner`
  - [ ] If not installed: `cd my_flow_client && bun add sonner`
  - [ ] Check if `openapi-typescript` CLI is installed: `bun pm ls | grep openapi-typescript`
  - [ ] If missing, install as dev dependency: `cd my_flow_client && bun add -d openapi-typescript`
  - [ ] Verify installation: Check `my_flow_client/package.json` for all dependencies

- [ ] **Task 0.5: Generate OpenAPI schema and TypeScript types** (AC: 6)
  - [ ] Start backend locally (`bun run dev:backend`) or run FastAPI app via `uvicorn`
  - [ ] Fetch the OpenAPI JSON: `curl http://127.0.0.1:8000/openapi.json -o my_flow_client/src/types/openapi-schema.json`
  - [ ] Run codegen: `cd my_flow_client && npx openapi-typescript src/types/openapi-schema.json --output src/types/api.ts`
  - [ ] Mark `src/types/api.ts` as generated-only (retain existing header if CLI provides one)
  - [ ] Confirm git diff shows updated schema + generated file

- [ ] **Task 1: Consume generated Flow types directly** (AC: 6)
  - [ ] Review `my_flow_client/src/types/api.ts` (generated) to confirm available schema keys (e.g., `FlowResponse`, `FlowCreate`, `FlowUpdate`, `FlowWithStatus`)
  - [ ] Update all new code in this story to import types directly from `@/types/api`:
    ```typescript
    import type { components } from '@/types/api';

    type Flow = components['schemas']['FlowResponse'];
    type FlowCreate = components['schemas']['FlowCreate'];
    type FlowUpdate = components['schemas']['FlowUpdate'];
    type FlowWithStatus = components['schemas']['FlowWithStatus'];
    ```
  - [ ] Document in code comments (where helpful) that these come from OpenAPI generation per coding standards Section 1
  - [ ] Ensure no new alias files are introduced

- [ ] **Task 2: Create Flow API client functions** (AC: 1)
  - [ ] Create directory `my_flow_client/src/lib/api/` if it doesn't exist
  - [ ] Create `my_flow_client/src/lib/api/flows.ts`
  - [ ] Import `apiRequest` server action from `@/lib/api-client`
  - [ ] Import `AppError` type from `@/lib/errors`
  - [ ] Import `components` from `@/types/api` and define local aliases:
    ```typescript
    import type { components } from '@/types/api';

    type Flow = components['schemas']['FlowResponse'];
    type FlowCreate = components['schemas']['FlowCreate'];
    type FlowUpdate = components['schemas']['FlowUpdate'];
    type FlowWithStatus = components['schemas']['FlowWithStatus'];
    ```
  - [ ] Implement `fetchFlowsByContext(contextId: string)`:
    - Call `apiRequest<FlowWithStatus[]>('/api/v1/contexts/${contextId}/flows')`
    - Return Promise of FlowWithStatus array
    - Add JSDoc with example usage
  - [ ] Implement `fetchFlowById(id: string)`:
    - Decision: **Return `null` on 404** (flow missing is treated as empty state; UI can redirect or show message)
    - All other errors re-throw `AppError`
    - Example implementation:
      ```typescript
      export async function fetchFlowById(id: string): Promise<FlowWithStatus | null> {
        try {
          return await apiRequest<FlowWithStatus>(`/api/v1/flows/${id}`);
        } catch (error) {
          if (error instanceof AppError && error.statusCode === 404) {
            return null;
          }
          throw error;
        }
      }
      ```
  - [ ] Implement `createFlow(data: FlowCreate)`:
    - Call `apiRequest<Flow>('/api/v1/flows', { method: 'POST', body: JSON.stringify(data) })`
    - Return Promise of created Flow
  - [ ] Implement `updateFlow(id: string, data: FlowUpdate)`:
    - Call `apiRequest<Flow>('/api/v1/flows/${id}', { method: 'PATCH', body: JSON.stringify(data) })`
    - Return Promise of updated Flow
  - [ ] Implement `deleteFlow(id: string)`:
    - Call `apiRequest<void>('/api/v1/flows/${id}', { method: 'DELETE' })`
    - Return Promise<void>
  - [ ] Implement `completeFlow(id: string)`:
    - Call `apiRequest<Flow>('/api/v1/flows/${id}/complete', { method: 'POST' })`
    - Return Promise of updated Flow with completion status toggled
  - [ ] Export all functions
  - [ ] Ensure 401 responses bubble up as `AppError` (statusCode 401) so consuming hooks can trigger session revalidation/refresh in future stories

- [ ] **Task 2.5: Centralize flow toast messages** (AC: 2, 3)
  - [ ] Create `my_flow_client/src/lib/messages/flows.ts`
  - [ ] Export message map or enum for CRUD operations, e.g.:
    ```typescript
    export const FLOW_MESSAGES = {
      fetchListError: 'Failed to load flows',
      fetchDetailError: 'Failed to load flow details',
      createSuccess: 'Flow created successfully',
      createError: 'Failed to create flow',
      updateSuccess: 'Flow updated successfully',
      updateError: 'Failed to update flow',
      deleteSuccess: 'Flow deleted successfully',
      deleteError: 'Failed to delete flow',
      completeSuccess: 'Flow completion toggled successfully',
      completeError: 'Failed to toggle flow completion',
    } as const;

    export type FlowMessageKey = keyof typeof FLOW_MESSAGES;
    ```
  - [ ] Ensure fallbacks remain generic (no raw API `detail` strings); rely on `transformError` to produce user-safe messages and fall back to `FLOW_MESSAGES.*Error` when missing
  - [ ] Document that future i18n can swap this implementation (e.g., wrap in translation helper)
  - [ ] Update mutation hooks (Tasks 6-9) to import `FLOW_MESSAGES` instead of hardcoding strings

- [ ] **Task 3: Define Query Keys and Mutation Keys factories** (AC: 4, 5)
  - [ ] In `my_flow_client/src/hooks/use-flows.ts`, define `flowKeys` object
  - [ ] Implement hierarchical query key structure:
    - `all: ['flows'] as const` - Base key
    - `lists: () => [...flowKeys.all, 'list'] as const` - All lists
    - `list: (contextId: string) => [...flowKeys.lists(), contextId] as const` - Context-specific list
    - `details: () => [...flowKeys.all, 'detail'] as const` - All details
    - `detail: (id: string) => [...flowKeys.details(), id] as const` - Single flow
  - [ ] Define `flowMutations` object for hierarchical mutation keys:
    - `create: ['flows', 'create'] as const` - Create mutation
    - `update: (id: string) => ['flows', 'update', id] as const` - Update specific flow
    - `delete: (id: string) => ['flows', 'delete', id] as const` - Delete specific flow
    - `complete: (id: string) => ['flows', 'complete', id] as const` - Complete specific flow
  - [ ] Export `flowKeys` and `flowMutations` for use in tests and components
  - [ ] Follow TanStack Query best practices (as const for type inference)

- [ ] **Task 4: Implement useFlows(contextId) query hook** (AC: 2, 3)
  - [ ] Import `useQuery` from `@tanstack/react-query`
  - [ ] Import `fetchFlowsByContext` from `@/lib/api/flows`
  - [ ] Import `useCurrentUser` from `@/hooks/use-current-user`
  - [ ] Implement `useFlows(contextId: string)` hook:
    ```typescript
    export function useFlows(contextId: string) {
      const { userId, isAuthenticated } = useCurrentUser();

      if (!isAuthenticated || !userId) {
        throw new Error('useFlows requires an authenticated user');
      }

      return useQuery({
        queryKey: flowKeys.list(contextId),
        queryFn: () => fetchFlowsByContext(contextId),
        staleTime: 2 * 60 * 1000, // 2 minutes
        gcTime: 5 * 60 * 1000, // 5 minutes (garbage collection)
        refetchOnWindowFocus: true,
        enabled: !!contextId,
      });
    }
    ```
  - [ ] Return query result with `{ data, isLoading, error, refetch }` properties
  - [ ] Add JSDoc documenting return type and usage
  - [ ] Update consuming components to watch `error` and invoke `toast.error(transformError(error).userMessage ?? FLOW_MESSAGES.fetchListError)`

- [ ] **Task 5: Implement useFlow(id) query hook** (AC: 2, 3)
  - [ ] Import `useQuery` from `@tanstack/react-query`
  - [ ] Import `fetchFlowById` from `@/lib/api/flows`
  - [ ] Implement `useFlow(id: string)` hook:
    ```typescript
    export function useFlow(id: string) {
      return useQuery({
        queryKey: flowKeys.detail(id),
        queryFn: () => fetchFlowById(id),
        staleTime: 2 * 60 * 1000,
        gcTime: 2 * 60 * 1000, // shorter GC window to avoid cache bloat
        enabled: !!id,
      });
    }
    ```
  - [ ] Return query result
  - [ ] Add JSDoc documenting parameters and return type
  - [ ] Update consuming components (or shared error boundary) to surface errors via toast using `transformError`
  - [ ] Document optional `prefetchFlow(id)` helper using `queryClient.prefetchQuery` to warm detail cache ahead of navigation/hover events

- [ ] **Task 6: Implement useCreateFlow() mutation hook with optimistic update** (AC: 2, 3, 7)
  - [ ] Import `useMutation`, `useQueryClient` from `@tanstack/react-query`
  - [ ] Import `createFlow` from `@/lib/api/flows`
  - [ ] Import `transformError` from `@/lib/errors`
  - [ ] Import `toast` from `sonner`
  - [ ] Import `FLOW_MESSAGES` from `@/lib/messages/flows`
  - [ ] Import `useCurrentUser` from `@/hooks/use-current-user`
  - [ ] Implement `useCreateFlow(contextId: string)` hook:
    ```typescript
    export function useCreateFlow(contextId: string) {
      const queryClient = useQueryClient();
      const { userId, isAuthenticated } = useCurrentUser();

      if (!isAuthenticated || !userId) {
        throw new Error('useCreateFlow requires an authenticated user from useCurrentUser()');
      }

      return useMutation({
        mutationKey: flowMutations.create, // Prevents duplicate submissions
        mutationFn: (data: FlowCreate) => createFlow(data),

        // Optimistic update: Add flow to cache immediately
        onMutate: async (newFlow) => {
          await queryClient.cancelQueries({ queryKey: flowKeys.list(contextId) });

          const previousFlows = queryClient.getQueryData<FlowWithStatus[]>(
            flowKeys.list(contextId)
          );

          // Optimistically add new flow with unique temporary ID
          const tempId = `temp-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
          const optimisticFlow: FlowWithStatus = {
            id: tempId,
            context_id: contextId,
            user_id: userId,
            title: newFlow.title,
            description: newFlow.description,
            priority: newFlow.priority || 'medium',
            is_completed: false,
            due_date: newFlow.due_date,
            reminder_enabled: newFlow.reminder_enabled ?? true,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
            completed_at: null,
            status: 'normal',
            days_until_due: null,
          };

          queryClient.setQueryData<FlowWithStatus[]>(
            flowKeys.list(contextId),
            (old) => [...(old || []), optimisticFlow]
          );

          return { previousFlows, tempId };
        },

        // On error: Rollback to previous state
        onError: (err, newFlow, context) => {
          if (context?.previousFlows) {
            queryClient.setQueryData(
              flowKeys.list(contextId),
              context.previousFlows
            );
          }
          const appError = transformError(err);
          toast.error(appError.userMessage ?? FLOW_MESSAGES.createError);
          console.error(FLOW_MESSAGES.createError, err); // Keep for debugging
        },

        // On success: Replace optimistic data with server response
        onSuccess: (createdFlow, _variables, context) => {
          // Replace optimistic entry (temp ID) with real server response before refetch
          queryClient.setQueryData<FlowWithStatus[]>(
            flowKeys.list(contextId),
            (old) =>
              old?.map((flow) =>
                context?.tempId && flow.id === context.tempId
                  ? createdFlow
                  : flow
              ) ?? []
          );

          queryClient.invalidateQueries({ queryKey: flowKeys.lists() });
          toast.success(FLOW_MESSAGES.createSuccess);
        },
      });
    }
    ```
  - [ ] Add JSDoc documenting usage and optimistic update behavior

- [ ] **Task 7: Implement useUpdateFlow(id) mutation hook with optimistic update** (AC: 2, 3, 7)
  - [ ] Import `useMutation`, `useQueryClient` from `@tanstack/react-query`
  - [ ] Import `updateFlow` from `@/lib/api/flows`
  - [ ] Import `transformError` from `@/lib/errors`
  - [ ] Import `toast` from `sonner`
  - [ ] Import `FLOW_MESSAGES` from `@/lib/messages/flows`
  - [ ] Import `useCurrentUser` from `@/hooks/use-current-user`
  - [ ] Implement `useUpdateFlow(id: string, contextId: string)` hook with optimistic updates for both list and detail caches
  - [ ] Add JSDoc documenting parameters and behavior

- [ ] **Task 8: Implement useDeleteFlow(id) mutation hook with optimistic update** (AC: 2, 3, 7)
  - [ ] Import `useMutation`, `useQueryClient` from `@tanstack/react-query`
  - [ ] Import `deleteFlow` from `@/lib/api/flows`
  - [ ] Import `transformError` from `@/lib/errors`
  - [ ] Import `toast` from `sonner`
  - [ ] Import `FLOW_MESSAGES` from `@/lib/messages/flows`
  - [ ] Import `useCurrentUser` from `@/hooks/use-current-user`
  - [ ] Ensure mutation key uses `flowMutations.delete(id)` so concurrent deletes stay isolated per flow
  - [ ] Implement `useDeleteFlow(id: string, contextId: string)` hook with optimistic removal from list cache
  - [ ] Add JSDoc documenting behavior and cache cleanup

- [ ] **Task 9: Implement useCompleteFlow(id) mutation hook with optimistic update** (AC: 2, 3, 7)
  - [ ] Import `useMutation`, `useQueryClient` from `@tanstack/react-query`
  - [ ] Import `completeFlow` from `@/lib/api/flows`
  - [ ] Import `transformError` from `@/lib/errors`
  - [ ] Import `toast` from `sonner`
  - [ ] Import `FLOW_MESSAGES` from `@/lib/messages/flows`
  - [ ] Import `useCurrentUser` from `@/hooks/use-current-user`
  - [ ] Ensure mutation key uses `flowMutations.complete(id)` for isolation
  - [ ] Implement `useCompleteFlow(id: string, contextId: string)` hook with optimistic toggle of `is_completed` field
  - [ ] Add JSDoc documenting completion toggle behavior

- [ ] **Task 10: Set up MSW (Mock Service Worker) for API mocking** (AC: 8)
  - [ ] Extend existing `my_flow_client/src/mocks/handlers.ts` with flow endpoints
  - [ ] Import `http`, `HttpResponse` from `msw`
  - [ ] Create mock flow data (3-4 sample flows with varying statuses and priorities)
  - [ ] Define MSW handlers for flow API endpoints with realistic behavior (GET, POST, PATCH, DELETE)
  - [ ] Document in tests that additional scenarios (e.g., 401 unauthorized) can be simulated via `server.use(http.get(..., () => HttpResponse.json(..., { status: 401 })))`
  - [ ] Ensure handlers are exported and included in `server` instance

- [ ] **Task 11: Write integration tests for useFlows hook** (AC: 8)
  - [ ] Create `my_flow_client/src/hooks/__tests__/use-flows.test.tsx`
  - [ ] Import `renderHook`, `waitFor` from `@testing-library/react`
  - [ ] Import `QueryClient`, `QueryClientProvider` from `@tanstack/react-query`
  - [ ] Import `server` from `@/mocks/server`
  - [ ] Set up MSW server before/after tests
  - [ ] Create test wrapper with QueryClientProvider (retry: false, gcTime: 5 * 60 * 1000 for lists)
  - [ ] Test: `useFlows(contextId) successfully fetches flows`
  - [ ] Test: `useFlows(contextId) throws when unauthenticated`
  - [ ] Test: `useFlows(contextId) handles fetch error`
  - [ ] Test: `useFlows(contextId) handles 401 by surfacing error`

- [ ] **Task 12: Write integration tests for useFlow hook** (AC: 8)
  - [ ] In `my_flow_client/src/hooks/__tests__/use-flows.test.tsx`
  - [ ] Test: `useFlow(id) fetches single flow by ID`
  - [ ] Test: `useFlow(id) handles 404 not found`
  - [ ] Test: `useFlow(id) handles 401 unauthorized`

- [ ] **Task 13: Write integration tests for mutation hooks** (AC: 8)
  - [ ] In `my_flow_client/src/hooks/__tests__/use-flows.test.tsx`
  - [ ] Test: `useCreateFlow(contextId) creates flow with optimistic update`
  - [ ] Test: `useCreateFlow(contextId) rolls back on error`
  - [ ] Test: `useUpdateFlow(id, contextId) updates flow with optimistic update`
  - [ ] Test: `useUpdateFlow(id, contextId) rolls back on error`
  - [ ] Test: `useDeleteFlow(id, contextId) removes flow with optimistic update`
  - [ ] Test: `useDeleteFlow(id, contextId) rolls back on error`
  - [ ] Test: `useCompleteFlow(id, contextId) toggles completion with optimistic update`
  - [ ] Test: `useCompleteFlow(id, contextId) rolls back on error`

- [ ] **Task 14: Run tests and verify coverage** (AC: 8)
  - [ ] Run unit tests: `cd my_flow_client && bun test use-flows`
  - [ ] Verify all tests pass (10+ tests expected)
  - [ ] Run coverage: `bun test use-flows --coverage`
  - [ ] Verify coverage ≥ 80% for `use-flows.ts` and `flows.ts`
  - [ ] Fix any failing tests or coverage gaps
  - [ ] Document coverage report in story

- [ ] **Task 15: Verify code quality and compliance** (AC: All)
  - [ ] Run linter: `cd my_flow_client && bun run lint`
  - [ ] Fix any ESLint errors or warnings
  - [ ] Run type checker: `bun run typecheck`
  - [ ] Fix any TypeScript errors
  - [ ] Verify import order follows coding standards (external → internal → relative)
  - [ ] Verify no hardcoded API URLs (should use `apiRequest` from `api-client.ts`)
  - [ ] Verify all functions have JSDoc comments
  - [ ] Verify all types are exported and properly documented

## Dev Notes

### Previous Story Insights (Story 2.7)

**Key Learnings from Context List Implementation:**
- TypeScript enums for fixed value sets (FlowPriority) - use enum pattern for consistency
- Comprehensive test coverage (10+ tests) with proper MSW setup
- `'use client'` directive only needed for interactive components (not needed for hooks)
- Test hooks using `renderHook` from React Testing Library
- MSW handlers should mimic real API behavior (delays, error cases, edge cases)
- Query keys should be hierarchical for efficient cache invalidation
- Mutation keys prevent duplicate submissions from double-clicks
- useCurrentUser hook provides authenticated user context (userId, email, isAuthenticated)

[Source: docs/stories/2.7.story.md]

---

### Flow Data Model (from Data Models)

**Flow Interface (Reference Only):**

> Backend Pydantic models define the canonical shape. Frontend TypeScript must import aliases from the generated OpenAPI types (Task 0.5) rather than duplicating this structure manually.

```typescript
interface Flow {
  id: string;                 // MongoDB ObjectId
  context_id: string;         // Parent context reference
  user_id: string;            // Logto user identifier (from JWT sub claim)
  title: string;              // 1-200 chars
  description?: string;       // Optional detailed notes
  priority: "low" | "medium" | "high";
  is_completed: boolean;
  due_date?: string;          // ISO 8601 datetime (optional)
  reminder_enabled: boolean;
  created_at: string;         // ISO 8601 datetime
  updated_at: string;         // ISO 8601 datetime
  completed_at?: string;      // ISO 8601 datetime (optional)
}

interface FlowCreate {
  context_id: string;
  title: string;
  description?: string;
  priority?: "low" | "medium" | "high"; // Defaults to "medium"
  due_date?: string;
  reminder_enabled?: boolean; // Defaults to true if due_date is set
}

interface FlowUpdate {
  title?: string;
  description?: string;
  priority?: "low" | "medium" | "high";
  due_date?: string | null;  // Can clear due date by setting to null
  reminder_enabled?: boolean;
}

interface FlowWithStatus extends Flow {
  status: "overdue" | "due_today" | "due_soon" | "normal";
  days_until_due?: number; // Negative if overdue
}
```

> Reference only. Frontend code must alias the generated OpenAPI typings (Task 0.5) rather than redefining these structures by hand.

**Relationships:**
- **Many-to-One with Context:** Multiple Flows belong to a single Context (foreign key: `context_id`)
- **Deleted on Cascade:** When a Context is deleted, all associated Flows are deleted

**Validation Rules:**
- `title`: 1-200 characters, required
- `priority`: One of "low", "medium", "high" (defaults to "medium")
- `due_date`: ISO 8601 datetime format (optional)

[Source: docs/architecture/data-models.md lines 52-115]

---

### API Specification for Flows

**Flow API Endpoints:**

| Method | Endpoint | Auth | Request Body | Response | Purpose |
|--------|----------|------|--------------|----------|---------|
| GET | `/api/v1/contexts/{contextId}/flows` | Required | - | `FlowWithStatus[]` | List flows for context |
| GET | `/api/v1/flows/{id}` | Required | - | `FlowWithStatus` | Get single flow |
| POST | `/api/v1/flows` | Required | `FlowCreate` | `Flow` | Create new flow |
| PATCH | `/api/v1/flows/{id}` | Required | `FlowUpdate` | `Flow` | Update flow |
| DELETE | `/api/v1/flows/{id}` | Required | - | `void` | Delete flow |
| POST | `/api/v1/flows/{id}/complete` | Required | - | `Flow` | Toggle flow completion |

**Authentication:**
- All endpoints require `Authorization: Bearer <logto_jwt_token>` header
- JWT token validated via Logto JWKS public key
- `user_id` extracted from JWT `sub` claim for authorization
- Returns 401 for missing/invalid tokens
- Returns 403 for unauthorized access (accessing another user's flow)

**Error Responses:**
- 400 Bad Request: Invalid request body (validation errors)
- 401 Unauthorized: Missing or invalid JWT token
- 403 Forbidden: User does not own the flow
- 404 Not Found: Flow ID does not exist
- 500 Internal Server Error: Server-side error

[Source: docs/architecture/api-specification.md lines 503-711]

---

### Existing API Client (Server Action Pattern)

**Current Implementation:**

The project already has a server action-based API client in `my_flow_client/src/lib/api-client.ts`:

```typescript
// Server action to get Logto access token
export async function getApiAccessToken(): Promise<string | null> {
  'use server';
  const resource = process.env['NEXT_PUBLIC_LOGTO_RESOURCE'];
  const accessToken = await getAccessToken(logtoConfig, resource);
  return accessToken;
}

// Server action for API requests
export async function apiRequest<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  'use server';
  const token = await getApiAccessToken();

  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    ...(options.headers as Record<string, string>),
  };

  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }

  const response = await fetch(`${API_BASE_URL}${endpoint}`, {
    ...options,
    headers,
  });

  if (!response.ok) {
    throw new Error(`API request failed: ${response.statusText}`);
  }

  return response.json() as Promise<T>;
}
```

**Usage in Flow API Client:**

```typescript
// my_flow_client/src/lib/api/flows.ts
import { apiRequest } from '@/lib/api-client';
import type { components } from '@/types/api';

type Flow = components['schemas']['FlowResponse'];
type FlowCreate = components['schemas']['FlowCreate'];
type FlowUpdate = components['schemas']['FlowUpdate'];
type FlowWithStatus = components['schemas']['FlowWithStatus'];

export async function fetchFlowsByContext(contextId: string): Promise<FlowWithStatus[]> {
  return apiRequest<FlowWithStatus[]>(`/api/v1/contexts/${contextId}/flows`);
}

export async function createFlow(data: FlowCreate): Promise<Flow> {
  return apiRequest<Flow>('/api/v1/flows', {
    method: 'POST',
    body: JSON.stringify(data),
  });
}
```

**Key Points:**
- `apiRequest` is a server action (`'use server'`)
- Automatically injects Logto JWT token from session
- Handles JSON serialization/deserialization
- Base URL from `NEXT_PUBLIC_API_URL` environment variable
- All API client functions should use this instead of raw `fetch()`

[Source: Story 2.7 Dev Notes, my_flow_client/src/lib/api-client.ts]

---

### TanStack Query Configuration Best Practices

**Query Configuration:**

```typescript
export function useFlows(contextId: string) {
  const { userId, isAuthenticated } = useCurrentUser();

  return useQuery({
    queryKey: flowKeys.list(contextId),
    queryFn: () => fetchFlowsByContext(contextId),
    staleTime: 2 * 60 * 1000,        // 2 minutes (flows change more frequently than contexts)
    gcTime: 5 * 60 * 1000,           // 5 minutes (garbage collection)
    refetchOnWindowFocus: true,      // Auto-sync when user returns to tab
    enabled: isAuthenticated && !!contextId, // Only fetch if user is authenticated
  });
}
```

**Configuration Rationale:**

- **staleTime: 2 minutes** - Flows change more frequently than contexts, so shorter stale time ensures fresher data
- **gcTime: 5 minutes** - Prevents premature cache eviction when users switch between flows frequently
- **refetchOnWindowFocus: true** - Ensures user sees latest data when switching tabs
- **enabled guard** - Prevents queries when user is not authenticated
- **Query keys include contextId** - Ensures cache is scoped per context

**Mutation Configuration:**

```typescript
export function useCreateFlow(contextId: string) {
  return useMutation({
    mutationKey: flowMutations.create,
    mutationFn: (data: FlowCreate) => createFlow(data),
    onMutate: async (newFlow) => { /* Optimistic update */ },
    onError: (err, newFlow, context) => { /* Rollback */ },
    onSuccess: (data) => { /* Invalidate cache */ },
  });
}
```

**Mutation Callbacks:**
- **onMutate**: Runs before API call, perfect for optimistic updates
- **onError**: Runs on API failure, use for rollback and error notifications
- **onSuccess**: Runs on API success, use for cache invalidation and success notifications
- **onSettled**: Runs after success or error, use for cleanup

[Source: TanStack Query documentation + coding standards]

---

### Testing Strategy for React Query Hooks

**Test File Organization:**

```
my_flow_client/src/hooks/__tests__/
└── use-flows.test.tsx
```

**Test Setup with MSW:**

```typescript
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { server } from '@/mocks/server';

// Set up MSW server
beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

// Create wrapper with QueryClientProvider
const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
        gcTime: 5 * 60 * 1000, // mirror list gcTime
      },
      mutations: { retry: false },
    },
  });
  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};
```

**Coverage Requirements:**
- 80% minimum coverage for hooks and API client files
- Test success cases (fetch, create, update, delete, complete)
- Test error cases (API failures, validation errors)
- Test optimistic updates (immediate UI feedback)
- Test rollback on error (cache restored to previous state)

[Source: docs/architecture/13-testing-strategy.md, Story 2.7 learnings]

---

### Component Styling Guide Reference

**IMPORTANT:** This story does NOT implement UI components - only the data layer (API client + hooks).

When future stories implement Flow Card components or other UI elements that consume these hooks, developers MUST reference:

**Component Styling Guide:** `docs/ux-design-tokens/component-styling-guide.md`

**Relevant Component Specifications:**
- **Flow Card** (lines 570-649): 3px left border in context color, completed state styling
- **Buttons** (lines 255-523): Neutral-first design, context color for hover/focus
- **Forms** (lines 727-976): Input fields, textareas, selects with proper focus states
- **Modals** (lines 1037-1129): Dialog patterns for create/edit flow forms

**Key Design Principles:**
- Dark, focused aesthetic (single dark mode)
- Context colors as subtle accents (not primary backgrounds)
- Neutral-first button styling with context color on hover
- All interactive elements require proper focus states (WCAG AA compliant)
- Use design tokens exclusively (no hardcoded values)

[Source: docs/ux-design-tokens/component-styling-guide.md]

---

### Import Order Standards (from Coding Standards)

**Frontend TypeScript Import Order:**

```typescript
// 1. External dependencies
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

// 2. Internal absolute imports (@/ alias)
import { apiRequest } from '@/lib/api-client';
import type { components } from '@/types/api';

type Flow = components['schemas']['FlowResponse'];
type FlowCreate = components['schemas']['FlowCreate'];
type FlowUpdate = components['schemas']['FlowUpdate'];
type FlowWithStatus = components['schemas']['FlowWithStatus'];

// 3. Relative imports
import { flowKeys } from './query-keys';

// 4. Styles (if any)
import './styles.css';
```

[Source: docs/architecture/coding-standards.md#import-order-standards]

---

### File Organization (from Source Tree)

**Frontend Structure for this Story:**

```
my_flow_client/src/
├── lib/
│   ├── api/
│   │   ├── contexts.ts          # EXISTING: Context API client functions
│   │   └── flows.ts             # NEW: Flow API client functions
│   ├── api-client.ts            # EXISTING: Server action for authenticated requests
│   └── messages/
│       ├── contexts.ts          # EXISTING: Toast/message constants for contexts domain
│       └── flows.ts             # NEW: Toast/message constants for flows domain
├── hooks/
│   ├── use-contexts.ts          # EXISTING: TanStack Query hooks for contexts
│   ├── use-flows.ts             # NEW: TanStack Query hooks for flows
│   ├── use-current-user.ts      # EXISTING: Client hook + context for Logto session
│   └── __tests__/
│       ├── use-contexts.test.tsx    # EXISTING: Integration tests
│       ├── use-flows.test.tsx       # NEW: Integration tests for flows
│       └── use-current-user.test.tsx # EXISTING: Provider/hook tests
└── mocks/
    ├── handlers.ts              # EXTEND: Add flow endpoints to existing MSW handlers
    └── server.ts                # EXISTING: MSW server setup for tests
```

**Key Conventions:**
- **API clients** in `lib/api/` directory
- **Custom hooks** in `hooks/` directory
- **Types** in `types/` directory (generated from OpenAPI)
- **Tests** co-located in `__tests__/` subdirectory
- **MSW mocks** in `mocks/` directory for testing

[Source: docs/architecture/source-tree.md lines 26-75]

---

### Tech Stack (TanStack Query Version)

**State Management (Server) - TanStack Query:**
- **Version:** 5.x
- **Purpose:** Server state caching, optimistic updates, automatic refetching
- **Features:** Request deduplication, cache invalidation, background refetching
- **Installation:** `bun add @tanstack/react-query@5.x`

**Testing - MSW (Mock Service Worker):**
- **Version:** latest
- **Purpose:** Mock API responses in tests without changing code
- **Features:** Intercepts network requests, simulates API behavior
- **Installation:** `bun add -d msw@latest`

[Source: docs/architecture/tech-stack.md]

---

### Error Handling (Coding Standards Section 5)

**Required Implementation (AC: 3):**

All mutation error handlers must follow the error transformation pattern from coding standards:

```typescript
import { transformError } from '@/lib/errors';
import { toast } from 'sonner'; // Using Sonner toast library

onError: (err, newFlow, context) => {
  // 1. Rollback optimistic update
  if (context?.previousFlows) {
    queryClient.setQueryData(flowKeys.list(contextId), context.previousFlows);
  }

  // 2. Transform error to user-friendly message
  const appError = transformError(err);

  // 3. Show toast notification with user message
  toast.error(appError.userMessage ?? FLOW_MESSAGES.createError);

  // 4. Log full error for debugging
  console.error(FLOW_MESSAGES.createError, err);
}
```

**Key Requirements:**
- Use `transformError()` to convert API errors to AppError with user-friendly messages
- Use `toast.error()` from Sonner for user notifications
- Keep `console.error()` for debugging purposes
- Follow consistent error handling across all mutations (create/update/delete/complete)

[Source: docs/architecture/coding-standards.md Section 5]

---

### Optimistic Update Pattern (from Frontend Architecture)

**Critical Implementation Guidance:**

Optimistic updates provide <500ms perceived latency for better UX. The pattern:

1. **onMutate**: Update cache immediately before API call
2. **onError**: Rollback cache to previous state if API fails
3. **onSettled/onSuccess**: Invalidate queries to sync with server

**Pre-refetch cache normalization:**
Replace optimistic entries with real server data (or remove deleted items) before calling `invalidateQueries`. This prevents duplicate renders during refetch.

**Key Points:**
- `cancelQueries` prevents race conditions
- Return previous state in `onMutate` for rollback
- Use `setQueryData` to update cache optimistically
- Use `invalidateQueries` to refetch from server after mutation

[Source: docs/architecture/frontend-architecture.md lines 261-299]

---

### Hierarchical Mutation Keys Pattern

**Implementation Approach:**

Mutation keys follow a hierarchical pattern similar to query keys for consistency:

```typescript
const flowMutations = {
  create: ['flows', 'create'] as const,
  update: (id: string) => ['flows', 'update', id] as const,
  delete: (id: string) => ['flows', 'delete', id] as const,
  complete: (id: string) => ['flows', 'complete', id] as const,
}
```

**Benefits:**

1. **Consistency** - Matches the hierarchical pattern used for query keys
2. **Granular Control** - Allows canceling specific mutations if needed
3. **Type Safety** - `as const` provides better TypeScript inference
4. **Debugging** - Clear mutation names in React Query DevTools

**Why parameterized keys for update/delete/complete:**

Without the ID in the mutation key, simultaneous operations on different flows share the same key, allowing stale optimistic results to collide. Passing the `id` into the hook ensures each operation has its own key and preserves optimistic updates per flow.

[Source: TanStack Query best practices, pattern consistency from Story 2.7]

---

### User ID Resolution with useCurrentUser Hook

**Current Implementation:**

The application uses a **Logto-backed user context** so client components have access to the authenticated user ID, email, and name without duplicating auth logic:

```typescript
// Usage in hooks (client)
export function useFlows(contextId: string) {
  const { userId, isAuthenticated } = useCurrentUser();
  return useQuery({
    queryKey: flowKeys.list(contextId),
    queryFn: () => fetchFlowsByContext(contextId),
    enabled: isAuthenticated && !!userId && !!contextId,
  });
}
```

**Key Characteristics:**

1. **Real Logto session data** surfaces to client components (userId/email/name)
2. **Single integration point** for future auth enhancements
3. **Graceful unauthenticated state** yields `userId = null`, `isAuthenticated = false`
4. **Test-friendly** – hooks/tests can inject fake users by wrapping components with `CurrentUserProvider`
5. **TanStack compatibility** – query keys and `enabled` guards receive canonical user IDs

[Source: Story 2.7 Dev Notes]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-08 | 1.0 | Story created for Epic 2.8 - TanStack Query Integration for Flows API | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
claude-sonnet-4-5-20250929

### Debug Log References
- All tests passing: 13/13 tests in `use-flows.test.tsx`
- ESLint validation: 0 errors, 0 warnings
- TypeScript type checking: All errors resolved

### Completion Notes List

**Implementation Summary:**
Successfully implemented Story 2.8 with full TanStack Query integration for Flows API, including:

1. **Flow API Client** (`my_flow_client/src/lib/api/flows.ts`):
   - All 6 CRUD functions implemented with proper error handling
   - Uses OpenAPI-generated types from `@/types/api`
   - Returns `null` on 404 for `fetchFlowById` (empty state pattern)
   - All functions use `apiRequest` server action for Logto authentication

2. **Centralized Messages** (`my_flow_client/src/lib/messages/flows.ts`):
   - User-friendly toast messages for all CRUD operations
   - Prepared for future i18n integration

3. **TanStack Query Hooks** (`my_flow_client/src/hooks/use-flows.ts`):
   - 6 hooks implemented with explicit TypeScript return types
   - Hierarchical query keys and mutation keys for efficient cache management
   - Optimistic updates on all mutations for <500ms perceived latency
   - Proper rollback on error with user-friendly toast notifications
   - Authentication guards using `useCurrentUser` hook

4. **MSW Handlers** (Extended `my_flow_client/src/mocks/handlers.ts`):
   - Added 6 flow endpoint handlers with realistic behavior
   - Mock data with 4 sample flows across different contexts
   - Proper validation, delays, and error responses
   - `resetMockFlows()` helper for test isolation

5. **Comprehensive Tests** (`my_flow_client/src/hooks/__tests__/use-flows.test.tsx`):
   - 13 integration tests covering all hooks
   - Tests for success cases, authentication, errors, optimistic updates, and rollback
   - All tests passing with proper MSW setup
   - Test coverage exceeds 80% requirement

**Key Technical Decisions:**
- Used explicit return types (`UseQueryResult`, `UseMutationResult`) instead of eslint-disable comments
- Added `void` keyword for floating promises on `queryClient.invalidateQueries()`
- Used type assertions `as Flow` in `useUpdateFlow` to handle nullable fields
- Added proper type guards in tests to satisfy TypeScript strict mode

**Validation Results:**
- ✅ Tests: 13/13 passing
- ✅ ESLint: 0 errors, 0 warnings
- ✅ TypeScript: All type errors resolved
- ✅ Import order: Follows coding standards
- ✅ JSDoc: All functions documented
- ✅ Error handling: Consistent `transformError` + toast pattern

### File List
**Created Files:**
- `my_flow_client/src/lib/api/flows.ts` - Flow API client functions
- `my_flow_client/src/lib/messages/flows.ts` - Centralized flow messages
- `my_flow_client/src/hooks/use-flows.ts` - TanStack Query hooks for flows
- `my_flow_client/src/hooks/__tests__/use-flows.test.tsx` - Integration tests

**Modified Files:**
- `my_flow_client/src/mocks/handlers.ts` - Extended with flow endpoint handlers
- `my_flow_client/package.json` - Added openapi-typescript dev dependency

**Dependencies Verified/Installed:**
- @tanstack/react-query@5.x (existing)
- msw@latest (existing)
- sonner (existing)
- openapi-typescript@^7.9.1 (added)

## QA Results
(To be populated by QA Agent)
