# Story 3.6: WebSocket/SSE Client for AI Streaming

## Status
Draft

## Story

**As a** frontend developer,
**I want** a WebSocket/SSE client hook for AI streaming,
**so that** messages stream in real-time as the AI generates them.

## Acceptance Criteria

1. **WebSocket client hook created in `my_flow_client/hooks/use-chat-stream.ts`:**
   - `useChatStream(contextId: string, conversationId?: string)`
   - Opens WebSocket connection to `/api/v1/chat/stream`
   - Sends user message via WebSocket
   - Receives streaming tokens and appends to current assistant message
   - Handles `flows_extracted` event and calls callback

2. **Streaming state management:**
   - Returns `{ messages, sendMessage, isStreaming, error }`
   - `isStreaming` is true while AI is generating response
   - `error` contains any connection or API errors

3. **Authentication:**
   - Includes Logto JWT token in WebSocket connection headers
   - Automatically reconnects if connection drops (max 3 retries)

4. **Integration with TanStack Query:**
   - After flow extraction event, invalidates `flowKeys.list(contextId)` to refresh flow list
   - Optimistic UI update shows extracted flows immediately

5. **Integration tests created in `my_flow_client/__tests__/hooks/use-chat-stream.test.tsx`:**
   - Uses mock WebSocket server for testing
   - Tests sending message and receiving streamed response
   - Tests flow extraction event handling
   - Tests error handling and reconnection
   - At least 80% coverage

6. **Manual testing with 1Password:**
   - Can run `op run -- bun dev` and test streaming in browser
   - Messages stream smoothly without flickering
   - Flow extraction notifications appear correctly

## Tasks / Subtasks

- [ ] **Task 0: Research WebSocket libraries for React** (AC: 1)
  - [ ] Evaluate native WebSocket API vs libraries (e.g., `socket.io-client`, `reconnecting-websocket`)
  - [ ] Check if Next.js 15 has any WebSocket helper utilities
  - [ ] Decision: Use native WebSocket API with custom reconnection logic (lighter weight, no extra dependencies)
  - [ ] Document decision in Dev Notes

- [ ] **Task 1: Create WebSocket connection types** (AC: 1, 2)
  - [ ] Create `my_flow_client/src/types/websocket.ts`
  - [ ] Define `WebSocketMessage` interface:
    ```typescript
    export interface WebSocketMessage {
      type: 'user_message' | 'assistant_token' | 'flows_extracted' | 'error' | 'connection_status';
      payload: any;
      timestamp?: string;
    }
    ```
  - [ ] Define `ChatStreamOptions` interface:
    ```typescript
    export interface ChatStreamOptions {
      contextId: string;
      conversationId?: string;
      onFlowsExtracted?: (flows: Flow[]) => void;
      onError?: (error: Error) => void;
    }
    ```
  - [ ] Define `ChatStreamState` interface:
    ```typescript
    export interface ChatStreamState {
      messages: Message[];
      sendMessage: (content: string) => void;
      isStreaming: boolean;
      error: string | null;
      connectionStatus: 'connecting' | 'connected' | 'disconnected' | 'error';
    }
    ```
  - [ ] Export all types from this file

- [ ] **Task 2: Create WebSocket connection manager utility** (AC: 3)
  - [ ] Create `my_flow_client/src/lib/websocket-manager.ts`
  - [ ] Implement `WebSocketManager` class:
    - `connect(url: string, token: string): Promise<WebSocket>`
    - `disconnect(): void`
    - `send(message: any): void`
    - `onMessage(callback: (data: any) => void): void`
    - `onError(callback: (error: Event) => void): void`
    - `onClose(callback: (event: CloseEvent) => void): void`
  - [ ] Add reconnection logic:
    - Max 3 retry attempts
    - Exponential backoff: 1s, 2s, 4s
    - Store retry count in class state
    - Reset retry count on successful connection
  - [ ] Add authentication:
    - Accept JWT token as constructor parameter
    - Add token to WebSocket connection headers (if supported) or initial message
  - [ ] Handle connection lifecycle events (open, close, error)

- [ ] **Task 3: Create useChatStream hook - Core structure** (AC: 1, 2)
  - [ ] Create `my_flow_client/src/hooks/use-chat-stream.ts`
  - [ ] Add `'use client'` directive at top of file
  - [ ] Import required dependencies:
    ```typescript
    import { useEffect, useState, useRef, useCallback } from 'react';
    import type { Message } from '@/types/chat';
    import type { ChatStreamState, ChatStreamOptions, WebSocketMessage } from '@/types/websocket';
    import { WebSocketManager } from '@/lib/websocket-manager';
    ```
  - [ ] Define hook signature:
    ```typescript
    export function useChatStream(
      contextId: string,
      conversationId?: string,
      options?: ChatStreamOptions
    ): ChatStreamState
    ```
  - [ ] Initialize state variables:
    - `const [messages, setMessages] = useState<Message[]>([])`
    - `const [isStreaming, setIsStreaming] = useState(false)`
    - `const [error, setError] = useState<string | null>(null)`
    - `const [connectionStatus, setConnectionStatus] = useState<'connecting' | 'connected' | 'disconnected' | 'error'>('disconnected')`
  - [ ] Create refs:
    - `const wsManagerRef = useRef<WebSocketManager | null>(null)`
    - `const currentAssistantMessageRef = useRef<Message | null>(null)`

- [ ] **Task 4: Implement WebSocket connection logic** (AC: 1, 3)
  - [ ] Create `useEffect` for WebSocket connection initialization:
    - Dependency array: `[contextId, conversationId]`
    - Get Logto JWT token from session (use existing auth helper)
    - Create WebSocket URL: `/api/v1/chat/stream?contextId=${contextId}&conversationId=${conversationId}`
    - Instantiate `WebSocketManager` with URL and token
    - Set connection status to 'connecting'
  - [ ] Setup WebSocket event handlers:
    - `onOpen`: Set status to 'connected'
    - `onClose`: Set status to 'disconnected', trigger reconnection if needed
    - `onError`: Set status to 'error', store error message
  - [ ] Cleanup function:
    - Disconnect WebSocket on unmount
    - Clear refs and reset state

- [ ] **Task 5: Implement message sending logic** (AC: 1)
  - [ ] Create `sendMessage` callback using `useCallback`:
    ```typescript
    const sendMessage = useCallback((content: string) => {
      if (!wsManagerRef.current) {
        setError('WebSocket not connected');
        return;
      }
      
      // Create user message
      const userMessage: Message = {
        id: crypto.randomUUID(),
        role: 'user',
        content,
        timestamp: new Date().toISOString()
      };
      
      // Add to messages immediately (optimistic UI)
      setMessages(prev => [...prev, userMessage]);
      
      // Send via WebSocket
      wsManagerRef.current.send({
        type: 'user_message',
        payload: userMessage,
        contextId,
        conversationId
      });
      
      // Set streaming state
      setIsStreaming(true);
    }, [contextId, conversationId]);
    ```
  - [ ] Dependency: `[contextId, conversationId]`

- [ ] **Task 6: Implement streaming token reception** (AC: 1)
  - [ ] Setup WebSocket `onMessage` handler in `useEffect`:
    ```typescript
    wsManagerRef.current.onMessage((data: WebSocketMessage) => {
      switch (data.type) {
        case 'assistant_token':
          handleAssistantToken(data.payload);
          break;
        case 'flows_extracted':
          handleFlowsExtracted(data.payload);
          break;
        case 'error':
          handleError(data.payload);
          break;
      }
    });
    ```
  - [ ] Implement `handleAssistantToken`:
    - If no current assistant message exists, create new message with empty content
    - Append token to current assistant message content
    - Update message in state array
    - Use `currentAssistantMessageRef` to track message being built
  - [ ] When streaming completes:
    - Set `isStreaming` to false
    - Clear `currentAssistantMessageRef`

- [ ] **Task 7: Implement flows_extracted event handling** (AC: 4)
  - [ ] Implement `handleFlowsExtracted` function:
    ```typescript
    const handleFlowsExtracted = useCallback((flows: Flow[]) => {
      // Call optional callback from options
      if (options?.onFlowsExtracted) {
        options.onFlowsExtracted(flows);
      }
      
      // Invalidate TanStack Query cache to trigger refetch
      queryClient.invalidateQueries({ 
        queryKey: ['flows', contextId] 
      });
    }, [contextId, options]);
    ```
  - [ ] Import `useQueryClient` from TanStack Query
  - [ ] Call `const queryClient = useQueryClient()` in hook body

- [ ] **Task 8: Implement error handling** (AC: 2)
  - [ ] Implement `handleError` function:
    ```typescript
    const handleError = useCallback((errorData: any) => {
      const errorMessage = errorData.message || 'An error occurred during streaming';
      setError(errorMessage);
      setIsStreaming(false);
      
      // Call optional error callback
      if (options?.onError) {
        options.onError(new Error(errorMessage));
      }
    }, [options]);
    ```
  - [ ] Handle network errors separately (WebSocket close events with error codes)
  - [ ] Store error in state for UI display

- [ ] **Task 9: Implement automatic reconnection** (AC: 3)
  - [ ] In WebSocket `onClose` handler:
    - Check if close was intentional (clean disconnect vs error)
    - If error and retries < 3, attempt reconnection after backoff delay
    - Use exponential backoff: 1s, 2s, 4s
    - Show reconnection attempt in connection status
  - [ ] Reset retry count on successful connection
  - [ ] Update connection status during reconnection attempts
  - [ ] Surface reconnection status to UI via `connectionStatus` state

- [ ] **Task 10: Integration with TanStack Query** (AC: 4)
  - [ ] Ensure `useQueryClient` is called in hook
  - [ ] After `flows_extracted` event:
    - Invalidate query: `queryClient.invalidateQueries({ queryKey: ['flows', contextId] })`
    - This triggers automatic refetch of flow list
  - [ ] Consider optimistic update for extracted flows (optional enhancement)
  - [ ] Document integration pattern in Dev Notes

- [ ] **Task 11: Create mock WebSocket server for tests** (AC: 5)
  - [ ] Create `my_flow_client/src/__tests__/helpers/mock-websocket-server.ts`
  - [ ] Implement `MockWebSocketServer` class:
    - Simulates WebSocket server behavior
    - Can emit messages to clients
    - Can simulate delays for streaming
    - Can simulate errors and disconnections
  - [ ] Export helper functions:
    - `createMockWebSocketServer(): MockWebSocketServer`
    - `simulateStreamingMessage(server, tokens: string[]): void`
    - `simulateFlowsExtractedEvent(server, flows: Flow[]): void`
    - `simulateError(server, errorMessage: string): void`

- [ ] **Task 12: Create unit tests for useChatStream** (AC: 5)
  - [ ] Create `my_flow_client/src/hooks/__tests__/use-chat-stream.test.tsx`
  - [ ] Import required testing utilities:
    ```typescript
    import { renderHook, waitFor, act } from '@testing-library/react';
    import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
    import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
    import { useChatStream } from '../use-chat-stream';
    import { MockWebSocketServer } from '@/__tests__/helpers/mock-websocket-server';
    ```
  - [ ] Setup test wrapper with QueryClient:
    ```typescript
    const queryClient = new QueryClient({
      defaultOptions: { queries: { retry: false } }
    });
    
    const wrapper = ({ children }: { children: React.ReactNode }) => (
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    );
    ```
  - [ ] Test: Initial state
    - Hook returns correct initial state
    - `messages` is empty array
    - `isStreaming` is false
    - `error` is null
    - `connectionStatus` is 'disconnected'
  - [ ] Test: WebSocket connection establishment
    - Mock WebSocket connection
    - Hook establishes connection on mount
    - Connection status changes to 'connected'
  - [ ] Test: Send user message
    - Call `sendMessage` with test content
    - User message added to messages array immediately
    - WebSocket sends message to server
    - `isStreaming` becomes true
  - [ ] Test: Receive streaming tokens
    - Mock server sends multiple `assistant_token` messages
    - Tokens are appended to current assistant message
    - Message updates in real-time
    - `isStreaming` remains true during streaming
  - [ ] Test: Streaming completes
    - Mock final token with completion flag
    - `isStreaming` becomes false
    - Complete assistant message in messages array
  - [ ] Test: flows_extracted event
    - Mock `flows_extracted` event with test flows
    - Callback is invoked with flows
    - TanStack Query cache is invalidated
  - [ ] Test: Error handling
    - Mock error event from server
    - `error` state is populated with error message
    - `isStreaming` becomes false
    - Error callback is invoked
  - [ ] Test: Automatic reconnection
    - Simulate WebSocket disconnect
    - Hook attempts reconnection (max 3 retries)
    - Exponential backoff delays applied
    - Connection status updates during retries
  - [ ] Test: Cleanup on unmount
    - Unmount hook
    - WebSocket connection is closed
    - No memory leaks or dangling connections

- [ ] **Task 13: Code quality and compliance** (AC: All)
  - [ ] Run linter: `cd my_flow_client && bun run lint`
  - [ ] Fix any linting errors or warnings
  - [ ] Run type checker: `bun run typecheck`
  - [ ] Fix any type errors
  - [ ] Verify import order follows coding standards (external → internal → relative)
  - [ ] Verify hook naming follows conventions (`use-chat-stream.ts`)
  - [ ] Verify all types have TypeScript interfaces
  - [ ] Run all tests: `bun test`
  - [ ] Verify 80%+ coverage: `bun test --coverage`

## Dev Notes

### Tech Stack (Frontend - WebSocket Integration)

**WebSocket Implementation:**
- **Native WebSocket API**: No external dependencies (lighter weight)
- **Custom reconnection logic**: Max 3 retries with exponential backoff
- **Authentication**: Logto JWT token sent in connection headers or initial message
- **Protocol**: WebSocket upgrade from HTTP(S)

**State Management:**
- **React hooks**: `useState`, `useEffect`, `useRef`, `useCallback`
- **TanStack Query**: Cache invalidation for flow list after extraction
- **Message buffering**: Use ref to track current assistant message during streaming

[Source: docs/architecture/tech-stack.md, lines 15-17: "State Management (Server) | TanStack Query | 5.x | Server state caching"]
[Source: docs/architecture/tech-stack.md, lines 16: "State Management (Local) | React Context | native | Minimal global UI state"]

---

### WebSocket Connection Pattern

**Connection URL:**
```typescript
const wsUrl = process.env.NEXT_PUBLIC_API_URL?.replace('http', 'ws') + `/api/v1/chat/stream`;
// Example: ws://localhost:8000/api/v1/chat/stream?contextId=ctx-1
```

**Authentication Strategy:**
- **Option 1 (Preferred)**: Add JWT to WebSocket headers (if supported by backend)
  ```typescript
  const ws = new WebSocket(wsUrl, {
    headers: { Authorization: `Bearer ${token}` }
  });
  ```
- **Option 2 (Fallback)**: Send token in first message after connection
  ```typescript
  ws.onopen = () => {
    ws.send(JSON.stringify({ type: 'auth', token }));
  };
  ```

**Message Protocol:**
```typescript
// Client → Server: User message
{
  type: 'user_message',
  payload: {
    id: 'msg-123',
    role: 'user',
    content: 'Hello AI',
    timestamp: '2025-10-11T10:00:00Z'
  },
  contextId: 'ctx-1',
  conversationId: 'conv-456' // optional
}

// Server → Client: Streaming token
{
  type: 'assistant_token',
  payload: {
    token: 'Hello',  // Single token
    messageId: 'msg-124', // ID of assistant message being built
    isComplete: false
  }
}

// Server → Client: Flows extracted
{
  type: 'flows_extracted',
  payload: {
    flows: [
      { id: 'flow-1', title: 'Task 1', context_id: 'ctx-1', ... },
      { id: 'flow-2', title: 'Task 2', context_id: 'ctx-1', ... }
    ]
  }
}

// Server → Client: Error
{
  type: 'error',
  payload: {
    message: 'Rate limit exceeded',
    code: 'RATE_LIMIT',
    retryAfter: 60 // seconds
  }
}
```

[Source: docs/prd/epic-3-ai-conversational-interface-flow-extraction.md, lines 129-142: "WebSocket endpoint accepts contextId and message, streams AI response"]

---

### React Hooks Best Practices

**Hook Rules:**
- Hooks MUST be called at top level (not in conditionals, loops, or nested functions)
- Custom hooks MUST start with `use` prefix
- `useEffect` dependencies MUST be exhaustive (include all used variables)
- `useCallback` dependencies MUST match usage

**State Update Patterns:**
```typescript
// ✅ CORRECT: Functional update (safe for concurrent rendering)
setMessages(prev => [...prev, newMessage]);

// ❌ WRONG: Direct state reference (stale closure risk)
setMessages([...messages, newMessage]);
```

**Ref Usage:**
```typescript
// ✅ CORRECT: Use ref for values that don't trigger re-renders
const wsRef = useRef<WebSocket | null>(null);

// ❌ WRONG: Using state for WebSocket instance (unnecessary re-renders)
const [ws, setWs] = useState<WebSocket | null>(null);
```

[Source: docs/architecture/frontend-architecture.md, lines 424-449: "React Hooks and State Management - State Update Best Practices"]

---

### WebSocket Reconnection Strategy

**Exponential Backoff Algorithm:**
```typescript
const RETRY_DELAYS = [1000, 2000, 4000]; // 1s, 2s, 4s
let retryCount = 0;

function attemptReconnect() {
  if (retryCount >= RETRY_DELAYS.length) {
    console.error('Max reconnection attempts reached');
    return;
  }
  
  const delay = RETRY_DELAYS[retryCount];
  console.log(`Reconnecting in ${delay}ms (attempt ${retryCount + 1}/3)...`);
  
  setTimeout(() => {
    retryCount++;
    connectWebSocket();
  }, delay);
}

function connectWebSocket() {
  const ws = new WebSocket(wsUrl);
  
  ws.onopen = () => {
    retryCount = 0; // Reset on successful connection
    console.log('WebSocket connected');
  };
  
  ws.onclose = (event) => {
    if (!event.wasClean) {
      attemptReconnect();
    }
  };
}
```

**Reconnection Triggers:**
- `onclose` event with `wasClean: false` (unexpected disconnect)
- `onerror` event (network failure, timeout)
- NOT triggered on intentional disconnect (user closes tab, logs out)

[Source: Story 3.6 AC 3: "Automatically reconnects if connection drops (max 3 retries)"]

---

### TanStack Query Integration

**Cache Invalidation Pattern:**
```typescript
import { useQueryClient } from '@tanstack/react-query';

const queryClient = useQueryClient();

// After flows_extracted event:
queryClient.invalidateQueries({ 
  queryKey: ['flows', contextId] 
});

// This triggers automatic refetch of:
// - useFlows(contextId) hook
// - Any other query using flowKeys.list(contextId)
```

**Query Key Convention:**
```typescript
// flows query key structure
['flows', contextId]  // List flows for context
['flows', flowId]     // Single flow detail
['flows']             // All flows (cross-context)
```

**Optimistic Update (Optional Enhancement):**
```typescript
// Before API call, update cache optimistically
queryClient.setQueryData(['flows', contextId], (old: Flow[]) => [
  ...old,
  ...extractedFlows
]);

// If extraction fails, roll back
onError: () => {
  queryClient.setQueryData(['flows', contextId], previousFlows);
}
```

[Source: docs/architecture/frontend-architecture.md, lines 239-301: "State Management Architecture - TanStack Query mutation pattern"]

---

### Testing Strategy (React Hooks)

**Test File Organization:**
```
my_flow_client/src/hooks/
├── use-chat-stream.ts
└── __tests__/
    └── use-chat-stream.test.tsx
```

**Testing Framework:**
- **Vitest**: Fast test runner, Vite-native
- **@testing-library/react-hooks**: Hook testing utilities (`renderHook`)
- **Mock WebSocket**: Custom mock server for controlled testing

**Test Patterns for Hooks:**
```typescript
import { renderHook, waitFor, act } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';

describe('useChatStream', () => {
  it('establishes WebSocket connection on mount', async () => {
    const { result } = renderHook(() => useChatStream('ctx-1'));
    
    await waitFor(() => {
      expect(result.current.connectionStatus).toBe('connected');
    });
  });
  
  it('sends message and updates state', async () => {
    const { result } = renderHook(() => useChatStream('ctx-1'));
    
    act(() => {
      result.current.sendMessage('Hello AI');
    });
    
    expect(result.current.messages).toHaveLength(1);
    expect(result.current.messages[0].content).toBe('Hello AI');
    expect(result.current.isStreaming).toBe(true);
  });
});
```

**Mocking WebSocket:**
```typescript
// Option 1: Manual mock
class MockWebSocket {
  onopen: (() => void) | null = null;
  onmessage: ((event: any) => void) | null = null;
  onerror: ((event: any) => void) | null = null;
  onclose: ((event: any) => void) | null = null;
  
  send(data: string) {
    // Track sent messages
  }
  
  close() {
    // Simulate close
  }
  
  // Helper to simulate server messages
  simulateMessage(data: any) {
    if (this.onmessage) {
      this.onmessage({ data: JSON.stringify(data) });
    }
  }
}

global.WebSocket = MockWebSocket as any;

// Option 2: Use mock-socket library (if needed)
import { Server as MockWebSocketServer } from 'mock-socket';
```

**Coverage Requirements:**
- 80% minimum line coverage
- All hook branches tested (success, error, reconnection)
- All event handlers tested (onopen, onmessage, onerror, onclose)

[Source: docs/architecture/13-testing-strategy.md, lines 142-189: "Frontend Hook Test examples"]

---

### TypeScript Type Definitions

**Type Organization:**
- Chat types: `my_flow_client/src/types/chat.ts` (already exists from Story 3.5)
- WebSocket types: `my_flow_client/src/types/websocket.ts` (new file for this story)

**Required Types:**
```typescript
// src/types/websocket.ts
export interface WebSocketMessage {
  type: 'user_message' | 'assistant_token' | 'flows_extracted' | 'error' | 'connection_status';
  payload: any;
  timestamp?: string;
}

export interface ChatStreamOptions {
  contextId: string;
  conversationId?: string;
  onFlowsExtracted?: (flows: Flow[]) => void;
  onError?: (error: Error) => void;
}

export interface ChatStreamState {
  messages: Message[];
  sendMessage: (content: string) => void;
  isStreaming: boolean;
  error: string | null;
  connectionStatus: 'connecting' | 'connected' | 'disconnected' | 'error';
}

export interface WebSocketManagerOptions {
  url: string;
  token: string;
  maxRetries?: number;
  retryDelays?: number[];
}
```

**Type Safety Rules:**
- ALL hook return types must have TypeScript interfaces
- Use `type` for union types, `interface` for object shapes
- Export all types for reuse across components
- Import types with `import type { ... }`

[Source: docs/architecture/coding-standards.md, lines 7-31: "Type Sharing Pattern"]

---

### Error Handling Standards

**Error Types:**
```typescript
// Network errors
class WebSocketNetworkError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'WebSocketNetworkError';
  }
}

// Authentication errors
class WebSocketAuthError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'WebSocketAuthError';
  }
}

// Rate limit errors
class WebSocketRateLimitError extends Error {
  retryAfter: number;
  constructor(message: string, retryAfter: number) {
    super(message);
    this.name = 'WebSocketRateLimitError';
    this.retryAfter = retryAfter;
  }
}
```

**Error Handling Pattern:**
```typescript
// In hook:
const handleError = useCallback((error: any) => {
  let errorMessage = 'An error occurred during streaming';
  
  if (error.code === 'RATE_LIMIT') {
    errorMessage = `Rate limit exceeded. Try again in ${error.retryAfter} seconds.`;
  } else if (error.code === 'AUTH_FAILED') {
    errorMessage = 'Authentication failed. Please sign in again.';
  } else if (error.message) {
    errorMessage = error.message;
  }
  
  setError(errorMessage);
  setIsStreaming(false);
  
  // Call optional error callback
  if (options?.onError) {
    options.onError(new Error(errorMessage));
  }
}, [options]);
```

[Source: docs/architecture/coding-standards.md, lines 105-130: "Error Handling Standards"]

---

### Project Structure Alignment

**Files to Create:**
- `my_flow_client/src/hooks/use-chat-stream.ts` (main hook)
- `my_flow_client/src/types/websocket.ts` (WebSocket types)
- `my_flow_client/src/lib/websocket-manager.ts` (WebSocket connection manager)
- `my_flow_client/src/hooks/__tests__/use-chat-stream.test.tsx` (unit tests)
- `my_flow_client/src/__tests__/helpers/mock-websocket-server.ts` (test helper)

**Files to Reference (DO NOT MODIFY):**
- `my_flow_client/src/types/chat.ts` (Message type from Story 3.5)
- `my_flow_client/src/lib/api-client.ts` (for auth token retrieval)
- `my_flow_client/src/hooks/use-flows.ts` (for query key reference - if exists)

[Source: docs/architecture/9-unified-project-structure.md, lines 17-66: "Frontend structure"]

---

### Previous Story Insights

From Story 3.5 (Chat UI Component):
- **Message type already defined**: `interface Message { id, role, content, timestamp }`
- **Chat interface expects streaming**: Designed with typing indicator and message appending
- **State management established**: Uses `useState` for messages array, `useRef` for scroll
- **Integration point**: ChatInterface will consume `useChatStream` hook via:
  ```typescript
  const { messages, sendMessage, isStreaming, error } = useChatStream(contextId, conversationId);
  ```

**Key Integration Requirements:**
- Hook must return `messages` array compatible with `MessageBubble` component
- `isStreaming` state controls typing indicator display
- `sendMessage` function must be memoized with `useCallback` to prevent re-renders

[Source: docs/stories/3.5.story.md, lines 422-451: "React Hooks and State Management"]

---

### Performance Considerations

**Optimization Strategies:**
1. **Message Buffering**: Use `useRef` to accumulate streaming tokens, batch state updates every 50ms to reduce re-renders
2. **Memoization**: Wrap `sendMessage` with `useCallback` to prevent prop changes in child components
3. **Debounce UI Updates**: For rapid token streaming (100+ tokens/sec), debounce message state updates

**Implementation:**
```typescript
// Token buffering (optional optimization)
const tokenBufferRef = useRef<string>('');
const flushTimeoutRef = useRef<NodeJS.Timeout | null>(null);

const appendToken = (token: string) => {
  tokenBufferRef.current += token;
  
  // Clear existing timeout
  if (flushTimeoutRef.current) {
    clearTimeout(flushTimeoutRef.current);
  }
  
  // Debounce state update (50ms)
  flushTimeoutRef.current = setTimeout(() => {
    setMessages(prev => {
      const lastMessage = prev[prev.length - 1];
      if (lastMessage.role === 'assistant') {
        return [
          ...prev.slice(0, -1),
          { ...lastMessage, content: lastMessage.content + tokenBufferRef.current }
        ];
      }
      return prev;
    });
    tokenBufferRef.current = '';
  }, 50);
};
```

[Source: docs/architecture/frontend-architecture.md, lines 559-570: "Performance Optimizations"]

---

### Accessibility Considerations

**WebSocket Status Announcements:**
- Use `aria-live="polite"` region to announce connection status changes
- Screen reader should announce: "Connected to AI assistant", "Disconnected, attempting to reconnect", "Error: [message]"

**Example:**
```tsx
<div 
  role="status" 
  aria-live="polite" 
  aria-atomic="true"
  className="sr-only"
>
  {connectionStatus === 'connecting' && 'Connecting to AI assistant...'}
  {connectionStatus === 'connected' && 'Connected to AI assistant'}
  {connectionStatus === 'disconnected' && 'Disconnected, attempting to reconnect'}
  {error && `Error: ${error}`}
</div>
```

[Source: docs/architecture/frontend-architecture.md, lines 836-874: "Accessibility Considerations"]

---

### Manual Testing Checklist

When testing with `op run -- bun dev`:

1. **Initial Connection:**
   - [ ] Hook establishes WebSocket connection on mount
   - [ ] Connection status shows "connected" in UI
   - [ ] No console errors

2. **Message Sending:**
   - [ ] Send "Hello AI" message
   - [ ] User message appears immediately in chat
   - [ ] Typing indicator shows while streaming

3. **Token Streaming:**
   - [ ] Assistant message streams token-by-token
   - [ ] No flickering or UI jank
   - [ ] Message builds smoothly without lag
   - [ ] Typing indicator disappears when complete

4. **Flow Extraction:**
   - [ ] Send message: "I need to finish the presentation, call the client, and book a flight"
   - [ ] After streaming completes, flow extraction notification appears
   - [ ] Extracted flows show in notification (3 flows expected)
   - [ ] Flow list refreshes automatically

5. **Error Handling:**
   - [ ] Disconnect network mid-stream
   - [ ] Error message displays in UI
   - [ ] Hook attempts reconnection (3 retries visible in status)
   - [ ] After successful reconnect, can resume conversation

6. **Reconnection:**
   - [ ] Close backend server
   - [ ] Hook shows "disconnected" status
   - [ ] Automatically attempts reconnection
   - [ ] After 3 failed attempts, stops trying

7. **Authentication:**
   - [ ] Sign out and sign back in
   - [ ] WebSocket reconnects with new JWT token
   - [ ] No "Unauthorized" errors in console

8. **Performance:**
   - [ ] Send long message (500+ words)
   - [ ] Streaming remains smooth (no frame drops)
   - [ ] UI stays responsive during streaming
   - [ ] Memory usage stable (no leaks after 10 messages)

---

## Testing

### Test File Locations
- Unit tests: `my_flow_client/src/hooks/__tests__/use-chat-stream.test.tsx`
- Mock helpers: `my_flow_client/src/__tests__/helpers/mock-websocket-server.ts`

### Testing Framework
- **Vitest**: Fast test runner, Vite-native
- **@testing-library/react**: Hook rendering utilities
- **@testing-library/react-hooks**: Hook testing helpers
- **mock-socket** (optional): WebSocket mock library

### Test Standards
- **Coverage Target**: 80% minimum line coverage
- **Test Structure**: `describe` blocks for hook grouping, `it` blocks for individual tests
- **Async Testing**: Use `waitFor` for async state updates, `act` for synchronous actions

### Test Patterns
```typescript
// Test WebSocket connection
it('establishes WebSocket connection on mount', async () => {
  const { result } = renderHook(() => useChatStream('ctx-1'));
  
  await waitFor(() => {
    expect(result.current.connectionStatus).toBe('connected');
  });
});

// Test message sending
it('sends message and updates state', () => {
  const { result } = renderHook(() => useChatStream('ctx-1'));
  
  act(() => {
    result.current.sendMessage('Hello AI');
  });
  
  expect(result.current.messages).toHaveLength(1);
  expect(result.current.isStreaming).toBe(true);
});

// Test error handling
it('handles WebSocket errors gracefully', async () => {
  const mockServer = createMockWebSocketServer();
  const { result } = renderHook(() => useChatStream('ctx-1'));
  
  act(() => {
    mockServer.simulateError('Connection failed');
  });
  
  await waitFor(() => {
    expect(result.current.error).toBe('Connection failed');
    expect(result.current.isStreaming).toBe(false);
  });
});
```

### Running Tests
```bash
cd my_flow_client
bun test use-chat-stream.test.tsx      # Run hook tests
bun test --coverage                     # Run with coverage
bun test --watch                        # Watch mode
```

[Source: docs/architecture/13-testing-strategy.md, lines 19-76: "Test Organization"]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-11 | 1.0 | Story created for Epic 3.6 - WebSocket/SSE Client for AI Streaming | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
None

### Debug Log References
None

### Completion Notes List
None

### File List
None

## QA Results

None

