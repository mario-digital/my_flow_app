# Story 2.7: TanStack Query Integration for Contexts API (FE)

## Status
done

## Story

**As a** frontend developer,
**I want** TanStack Query hooks for context API operations,
**so that** we have optimistic updates, caching, and automatic refetching for context management.

## Acceptance Criteria

1. **API client created in `my_flow_client/src/lib/api/contexts.ts`:**
   - `fetchContexts()` â†’ GET /api/v1/contexts
   - `fetchContextById(id: string)` â†’ GET /api/v1/contexts/{id}
   - `createContext(data: ContextCreate)` â†’ POST /api/v1/contexts
   - `updateContext(id: string, data: ContextUpdate)` â†’ PUT /api/v1/contexts/{id}
   - `deleteContext(id: string)` â†’ DELETE /api/v1/contexts/{id}
   - All methods use server action `apiRequest` from `@/lib/api-client` with Logto auth
   - TypeScript types imported directly from generated OpenAPI typings (`@/types/api`, e.g., `components['schemas']['ContextResponse']`)

2. **TanStack Query hooks created in `my_flow_client/src/hooks/use-contexts.ts`:**
   - `useContexts()` â†’ Uses `useQuery` to fetch all user contexts
   - `useContext(id: string)` â†’ Uses `useQuery` to fetch single context
   - `useCreateContext()` â†’ Uses `useMutation` with optimistic update
   - `useUpdateContext()` â†’ Uses `useMutation` with optimistic update
   - `useDeleteContext(id: string)` â†’ Uses `useMutation` with optimistic update and cache invalidation

3. **Query configuration follows best practices:**
   - `staleTime: 5 minutes` for context lists (contexts change infrequently)
   - `gcTime: 10 minutes` for list queries (prevents premature eviction when switching contexts)
   - `gcTime: 2 minutes` for detail queries to avoid unbounded cache growth
   - `refetchOnWindowFocus: true` for automatic sync
   - `enabled` guard prevents queries when user is not authenticated
- `mutationKey` required on all mutations to prevent duplicate submissions from double-clicks
- Optimistic updates for create/update/delete show instant UI feedback
- Query hooks (`useContexts`, `useContext`) do not use deprecated `onError`; instead, they expose `error` so consuming components can handle notifications (see Dev Notes pattern)
  - Parallel data requirements (list + detail) should use `prefetchQuery` (see Task 7 Dev Notes example) to keep UI responsive
  - QueryClient options should cap cache growth (e.g., ensure default `gcTime` matches above and consider `maxPages`/`maxAge` if future list sizes expand)
  - CSRF protection handled via server actions (`apiRequest`) â€” verify no client-side mutation bypasses these helpers

4. **Query keys follow consistent pattern:**
   ```typescript
   const contextKeys = {
     all: ['contexts'] as const,
     lists: () => [...contextKeys.all, 'list'] as const,
     list: (userId: string) => [...contextKeys.lists(), userId] as const,
     details: () => [...contextKeys.all, 'detail'] as const,
     detail: (id: string) => [...contextKeys.details(), id] as const,
   }
   ```

5. **TypeScript types generated from backend OpenAPI schema (no manual duplication):**
   - `openapi-typescript` output stored at `my_flow_client/src/types/api.ts` (auto-generated, do not edit)
   - Story code imports required types directly from `@/types/api` using `components['schemas'][...]`
   - No additional alias files (e.g., `@/types/context`) should be created unless future standards explicitly add them

6. **Integration tests created in `my_flow_client/src/hooks/__tests__/use-contexts.test.tsx`:**
   - Uses `@testing-library/react` with `QueryClientProvider` wrapper
   - Uses MSW (Mock Service Worker) for API mocking
   - Tests successful fetch, create, update, delete operations
   - Tests optimistic updates (UI reflects changes before API confirms)
   - Tests error handling (optimistic update rollback on API error)
   - Tests cache invalidation strategy
   - At least 80% coverage

## Tasks / Subtasks

- [ ] **Task 0: Verify and install dependencies** (AC: 2, 3, 6)
  - [ ] Check if `@tanstack/react-query` is installed: `bun pm ls | grep @tanstack/react-query`
  - [ ] If not installed: `cd my_flow_client && bun add @tanstack/react-query@5.x`
  - [ ] Check if `msw` (Mock Service Worker) is installed: `bun pm ls | grep msw`
  - [ ] If not installed for testing: `cd my_flow_client && bun add -d msw@latest`
  - [ ] Check if `sonner` (toast library) is installed: `bun pm ls | grep sonner`
  - [ ] If not installed: `cd my_flow_client && bun add sonner`
  - [ ] Check if `openapi-typescript` CLI is installed: `bun pm ls | grep openapi-typescript`
  - [ ] If missing, install as dev dependency: `cd my_flow_client && bun add -d openapi-typescript`
  - [ ] Verify installation: Check `my_flow_client/package.json` for all dependencies

- [ ] **Task 0.5: Generate OpenAPI schema and TypeScript types** (AC: 5)
  - [ ] Start backend locally (`bun run dev:backend`) or run FastAPI app via `uvicorn`
  - [ ] Fetch the OpenAPI JSON: `curl http://127.0.0.1:8000/openapi.json -o my_flow_client/src/types/openapi-schema.json`
  - [ ] Run codegen: `cd my_flow_client && npx openapi-typescript src/types/openapi-schema.json --output src/types/api.ts`
  - [ ] Mark `src/types/api.ts` as generated-only (retain existing header if CLI provides one)
  - [ ] Confirm git diff shows updated schema + generated file

- [ ] **Task 1: Consume generated Context types directly** (AC: 5)
  - [ ] Review `my_flow_client/src/types/api.ts` (generated) to confirm available schema keys (e.g., `ContextResponse`, `ContextCreate`, `ContextUpdate`)
  - [ ] Update all new code in this story to import types directly from `@/types/api`:
    ```typescript
    import type { components } from '@/types/api';

    type Context = components['schemas']['ContextResponse'];
    type ContextCreate = components['schemas']['ContextCreate'];
    type ContextUpdate = components['schemas']['ContextUpdate'];
    ```
  - [ ] Document in code comments (where helpful) that these come from OpenAPI generation per coding standards Section 1
  - [ ] Ensure no new alias files are introduced

- [ ] **Task 2: Create Context API client functions** (AC: 1)
  - [ ] Create directory `my_flow_client/src/lib/api/`
  - [ ] Create `my_flow_client/src/lib/api/contexts.ts`
  - [ ] Import `apiRequest` server action from `@/lib/api-client`
  - [ ] Import `AppError` type from `@/lib/errors`
  - [ ] Import `components` from `@/types/api` and define local aliases:
    ```typescript
    import type { components } from '@/types/api';

    type Context = components['schemas']['ContextResponse'];
    type ContextCreate = components['schemas']['ContextCreate'];
    type ContextUpdate = components['schemas']['ContextUpdate'];
    ```
  - [ ] Implement `fetchContexts()`:
    - Call `apiRequest<Context[]>('/api/v1/contexts')`
    - Return Promise of Context array
    - Add JSDoc with example usage
  - [ ] Implement `fetchContextById(id: string)`:
    - Decision: **Return `null` on 404** (context missing is treated as empty state; UI can redirect or show message)
    - All other errors re-throw `AppError`
    - Example implementation:
      ```typescript
      export async function fetchContextById(id: string): Promise<Context | null> {
        try {
          return await apiRequest<Context>(`/api/v1/contexts/${id}`);
        } catch (error) {
          if (error instanceof AppError && error.statusCode === 404) {
            return null;
          }
          throw error;
        }
      }
      ```
  - [ ] Implement `createContext(data: ContextCreate)`:
    - Call `apiRequest<Context>('/api/v1/contexts', { method: 'POST', body: JSON.stringify(data) })`
    - Return Promise of created Context
  - [ ] Implement `updateContext(id: string, data: ContextUpdate)`:
    - Call `apiRequest<Context>('/api/v1/contexts/${id}', { method: 'PUT', body: JSON.stringify(data) })`
    - Return Promise of updated Context
  - [ ] Implement `deleteContext(id: string)`:
    - Call `apiRequest<void>('/api/v1/contexts/${id}', { method: 'DELETE' })`
    - Return Promise<void>
  - [ ] Export all functions
  - [ ] Ensure 401 responses bubble up as `AppError` (statusCode 401) so consuming hooks can trigger session revalidation/refresh in future stories

- [ ] **Task 2.5: Centralize context toast messages** (AC: 2, 3)
  - [ ] Create `my_flow_client/src/lib/messages/contexts.ts`
  - [ ] Export message map or enum for CRUD operations, e.g.:
    ```typescript
    export const CONTEXT_MESSAGES = {
      fetchListError: 'Failed to load contexts',
      fetchDetailError: 'Failed to load context details',
      createSuccess: 'Context created successfully',
      createError: 'Failed to create context',
      updateSuccess: 'Context updated successfully',
      updateError: 'Failed to update context',
      deleteSuccess: 'Context deleted successfully',
      deleteError: 'Failed to delete context',
    } as const;

    export type ContextMessageKey = keyof typeof CONTEXT_MESSAGES;
    ```
  - [ ] Ensure fallbacks remain generic (no raw API `detail` strings); rely on `transformError` to produce user-safe messages and fall back to `CONTEXT_MESSAGES.*Error` when missing
  - [ ] Document that future i18n can swap this implementation (e.g., wrap in translation helper)
  - [ ] Update mutation hooks (Tasks 6-8) to import `CONTEXT_MESSAGES` instead of hardcoding strings

- [ ] **Task 3: Define Query Keys and Mutation Keys factories** (AC: 4)
  - [ ] In `my_flow_client/src/hooks/use-contexts.ts`, define `contextKeys` object
  - [ ] Implement hierarchical query key structure:
    - `all: ['contexts'] as const` - Base key
    - `lists: () => [...contextKeys.all, 'list'] as const` - All lists
    - `list: (userId: string) => [...contextKeys.lists(), userId] as const` - User-specific list
    - `details: () => [...contextKeys.all, 'detail'] as const` - All details
    - `detail: (id: string) => [...contextKeys.details(), id] as const` - Single context
  - [ ] Define `contextMutations` object for hierarchical mutation keys:
    - `create: ['contexts', 'create'] as const` - Create mutation
    - `update: (id: string) => ['contexts', 'update', id] as const` - Update specific context
    - `delete: (id: string) => ['contexts', 'delete', id] as const` - Delete specific context
  - [ ] Export `contextKeys` and `contextMutations` for use in tests and components
  - [ ] Follow TanStack Query best practices (as const for type inference)

- [ ] **Task 3.5: Implement useCurrentUser hook backed by Logto session** (AC: 3)
  - **Context:** Logto authentication already works via server actions (`requireAuth`, `getLogtoContext`, `apiRequest`). This task surfaces that session data to client components so TanStack Query hooks have the real user identifier.
  - [ ] Create `my_flow_client/src/hooks/use-current-user.ts` with `'use client'`
  - [ ] Define `CurrentUserState` interface:
    ```typescript
    export interface CurrentUserState {
      userId: string | null;
      email?: string;
      name?: string;
      isAuthenticated: boolean;
      isLoading: boolean;
    }
    ```
  - [ ] Create `CurrentUserContext` + `CurrentUserProvider` (client) using `createContext<CurrentUserState | undefined>(undefined)`
  - [ ] Export `useCurrentUser()` hook that reads the context and throws a descriptive error if used outside the provider
  - [ ] Create `my_flow_client/src/components/providers/current-user-provider.tsx` (async **server** component):
    - Call `getLogtoContext(logtoConfig)`
    - Map session to `CurrentUserState` (`userId: claims?.sub ?? null`, include `email`, `name`, `isAuthenticated`)
    - Pass state to the client provider (`<CurrentUserProvider value={state}>{children}</CurrentUserProvider>`)
  - [ ] Update `my_flow_client/src/app/layout.tsx` to wrap the app with the new provider (ensure `Navigation` still renders inside)
  - [ ] When unauthenticated, return `userId: null`, `isAuthenticated: false`, `isLoading: false`
  - [ ] Document (e.g., module-level comment) that the provider supplies a request-time snapshot; future stories must make session reactive (e.g., via revalidation or client SDK subscription)
  - [ ] Add tests in `my_flow_client/src/hooks/__tests__/use-current-user.test.tsx` verifying:
    - Hook returns provided context values
    - Authenticated state exposes `isAuthenticated === true` and correct claims snapshot
    - Hook throws helpful error when called outside provider
    - Provider normalizes unauthenticated session to `null` user

- [ ] **Task 4: Implement useContexts() query hook** (AC: 2, 3)
  - [ ] Import `useQuery` from `@tanstack/react-query`
  - [ ] Import `fetchContexts` from `@/lib/api/contexts`
  - [ ] Import `useCurrentUser` from `@/hooks/use-current-user`
  - [ ] Implement `useContexts()` hook:
    ```typescript
    export function useContexts() {
      const { userId, isAuthenticated } = useCurrentUser();

      if (!isAuthenticated || !userId) {
        throw new Error('useContexts requires an authenticated user');
      }

      return useQuery({
        queryKey: contextKeys.list(userId),
        queryFn: fetchContexts,
        staleTime: 5 * 60 * 1000, // 5 minutes
        gcTime: 10 * 60 * 1000, // 10 minutes (garbage collection)
        refetchOnWindowFocus: true,
        enabled: true,
      });
    }
    ```
  - [ ] Return query result with `{ data, isLoading, error, refetch }` properties
  - [ ] Add JSDoc documenting return type and usage
  - [ ] Update consuming components to watch `error` and invoke `toast.error(transformError(error).userMessage ?? CONTEXT_MESSAGES.fetchListError)`

- [ ] **Task 5: Implement useContext(id) query hook** (AC: 2, 3)
  - [ ] Import `useQuery` from `@tanstack/react-query`
  - [ ] Import `fetchContextById` from `@/lib/api/contexts`
  - [ ] Implement `useContext(id: string)` hook:
    ```typescript
    export function useContext(id: string) {
      return useQuery({
        queryKey: contextKeys.detail(id),
        queryFn: () => fetchContextById(id),
        staleTime: 5 * 60 * 1000,
        gcTime: 2 * 60 * 1000, // shorter GC window to avoid cache bloat
        enabled: !!id,
      });
    }
    ```
  - [ ] Return query result
  - [ ] Add JSDoc documenting parameters and return type
  - [ ] Update consuming components (or shared error boundary) to surface errors via toast using `transformError`
  - [ ] Document optional `prefetchContext(id)` helper using `queryClient.prefetchQuery` to warm detail cache ahead of navigation/hover events

- [ ] **Task 6: Implement useCreateContext() mutation hook with optimistic update** (AC: 2, 3)
  - [ ] Import `useMutation`, `useQueryClient` from `@tanstack/react-query`
  - [ ] Import `createContext` from `@/lib/api/contexts`
  - [ ] Import `transformError` from `@/lib/errors`
  - [ ] Import `toast` from `sonner`
  - [ ] Import `CONTEXT_MESSAGES` from `@/lib/messages/contexts`
  - [ ] Import `useCurrentUser` from `@/hooks/use-current-user`
  - [ ] Implement `useCreateContext()` hook:
    ```typescript
    export function useCreateContext() {
      const queryClient = useQueryClient();
      const { userId, isAuthenticated } = useCurrentUser();

      if (!isAuthenticated || !userId) {
        throw new Error('useCreateContext requires an authenticated user from useCurrentUser()');
      }

      return useMutation({
        mutationKey: contextMutations.create, // Prevents duplicate submissions
        mutationFn: (data: ContextCreate) => createContext(data),

        // Optimistic update: Add context to cache immediately
        onMutate: async (newContext) => {
          await queryClient.cancelQueries({ queryKey: contextKeys.list(userId) });

          const previousContexts = queryClient.getQueryData<Context[]>(
            contextKeys.list(userId)
          );

        // Optimistically add new context with unique temporary ID
        const tempId = `temp-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
        const optimisticContext: Context = {
          id: tempId,
          user_id: userId,
          name: newContext.name,
          color: newContext.color,
          icon: newContext.icon,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        };

        queryClient.setQueryData<Context[]>(
          contextKeys.list(userId),
          (old) => [...(old || []), optimisticContext]
        );

        return { previousContexts, tempId };
      },

        // On error: Rollback to previous state
        onError: (err, newContext, context) => {
          if (context?.previousContexts) {
            queryClient.setQueryData(
              contextKeys.list(userId),
              context.previousContexts
            );
          }
          const appError = transformError(err);
          toast.error(appError.userMessage ?? CONTEXT_MESSAGES.createError);
          console.error(CONTEXT_MESSAGES.createError, err); // Keep for debugging
        },

        // On success: Replace optimistic data with server response
        onSuccess: (createdContext, _variables, context) => {
          // Replace optimistic entry (temp ID) with real server response before refetch
          queryClient.setQueryData<Context[]>(
            contextKeys.list(userId),
            (old) =>
              old?.map((ctx) =>
                context?.tempId && ctx.id === context.tempId
                  ? createdContext
                  : ctx
              ) ?? []
          );

          queryClient.invalidateQueries({ queryKey: contextKeys.lists() });
          toast.success(CONTEXT_MESSAGES.createSuccess);
        },
      });
    }
    ```
  - [ ] Add JSDoc documenting usage and optimistic update behavior

- [ ] **Task 7: Implement useUpdateContext() mutation hook with optimistic update** (AC: 2, 3)
  - [ ] Import `useMutation`, `useQueryClient` from `@tanstack/react-query`
  - [ ] Import `updateContext` from `@/lib/api/contexts`
  - [ ] Import `transformError` from `@/lib/errors`
  - [ ] Import `toast` from `sonner`
  - [ ] Import `CONTEXT_MESSAGES` from `@/lib/messages/contexts`
  - [ ] Import `useCurrentUser` from `@/hooks/use-current-user`
  - [ ] Implement `useUpdateContext()` hook:
    ```typescript
    export function useUpdateContext(id: string) {
      const queryClient = useQueryClient();
      const { userId, isAuthenticated } = useCurrentUser();

      if (!isAuthenticated || !userId) {
        throw new Error('useUpdateContext requires an authenticated user');
      }

      return useMutation({
        mutationKey: contextMutations.update(id), // Prevents duplicate submissions, scoped to specific context
        mutationFn: (data: ContextUpdate) => updateContext(id, data),

        // Optimistic update: Update context in cache immediately
        onMutate: async (data) => {
          await queryClient.cancelQueries({ queryKey: contextKeys.list(userId) });
          await queryClient.cancelQueries({ queryKey: contextKeys.detail(id) });

          const previousContext = queryClient.getQueryData<Context>(
            contextKeys.detail(id)
          );
          const previousContexts = queryClient.getQueryData<Context[]>(
            contextKeys.list(userId)
          );

          // Optimistically update context in list
          queryClient.setQueryData<Context[]>(
            contextKeys.list(userId),
            (old) =>
              old?.map((ctx) =>
                ctx.id === id ? { ...ctx, ...data, updated_at: new Date().toISOString() } : ctx
              )
          );

          // Optimistically update single context query
          queryClient.setQueryData<Context>(
            contextKeys.detail(id),
            (old) => (old ? { ...old, ...data, updated_at: new Date().toISOString() } : old)
          );

          return { previousContext, previousContexts };
        },

        onError: (err, data, context) => {
          if (context?.previousContext) {
            queryClient.setQueryData(contextKeys.detail(id), context.previousContext);
          }
          if (context?.previousContexts) {
            queryClient.setQueryData(contextKeys.list(userId), context.previousContexts);
          }
          const appError = transformError(err);
          toast.error(appError.userMessage ?? CONTEXT_MESSAGES.updateError);
          console.error(CONTEXT_MESSAGES.updateError, err); // Keep for debugging
        },

        onSuccess: (updatedContext) => {
          // Ensure both detail and list caches reflect server response before refetch
          queryClient.setQueryData<Context>(
            contextKeys.detail(id),
            () => updatedContext
          );
          queryClient.setQueryData<Context[]>(
            contextKeys.list(userId),
            (old) =>
              old?.map((ctx) =>
                ctx.id === id ? updatedContext : ctx
              ) ?? []
          );

          queryClient.invalidateQueries({ queryKey: contextKeys.detail(id) });
          queryClient.invalidateQueries({ queryKey: contextKeys.lists() });
          toast.success(CONTEXT_MESSAGES.updateSuccess);
        },
      });
    }
    ```
  - [ ] Add JSDoc documenting parameters and behavior

- [ ] **Task 8: Implement useDeleteContext(id: string) mutation hook with optimistic update** (AC: 2, 3)
  - [ ] Import `useMutation`, `useQueryClient` from `@tanstack/react-query`
  - [ ] Import `deleteContext` from `@/lib/api/contexts`
  - [ ] Import `transformError` from `@/lib/errors`
  - [ ] Import `toast` from `sonner`
  - [ ] Import `CONTEXT_MESSAGES` from `@/lib/messages/contexts`
  - [ ] Import `useCurrentUser` from `@/hooks/use-current-user`
  - [ ] Ensure mutation key uses `contextMutations.delete(id)` so concurrent deletes stay isolated per context
  - [ ] Implement `useDeleteContext(id: string)` hook:
    ```typescript
    export function useDeleteContext(id: string) {
      const queryClient = useQueryClient();
      const { userId, isAuthenticated } = useCurrentUser();

      if (!isAuthenticated || !userId) {
        throw new Error('useDeleteContext requires an authenticated user');
      }

      return useMutation({
        mutationKey: contextMutations.delete(id), // Scoped per-context key prevents duplicate delete collisions
        mutationFn: () => deleteContext(id),

        // Optimistic update: Remove context from cache immediately
        onMutate: async () => {
          await queryClient.cancelQueries({ queryKey: contextKeys.list(userId) });

          const previousContexts = queryClient.getQueryData<Context[]>(
            contextKeys.list(userId)
          );

          // Optimistically remove context from list
          queryClient.setQueryData<Context[]>(
            contextKeys.list(userId),
            (old) => old?.filter((ctx) => ctx.id !== id)
          );

          return { previousContexts };
        },

        onError: (err, _variables, context) => {
          if (context?.previousContexts) {
            queryClient.setQueryData(contextKeys.list(userId), context.previousContexts);
          }
          const appError = transformError(err);
          toast.error(appError.userMessage ?? CONTEXT_MESSAGES.deleteError);
          console.error(CONTEXT_MESSAGES.deleteError, err); // Keep for debugging
        },

        onSuccess: () => {
          // Ensure caches are cleaned before invalidation
          queryClient.setQueryData<Context[]>(
            contextKeys.list(userId),
            (old) => old?.filter((ctx) => ctx.id !== id) ?? []
          );
          queryClient.removeQueries({ queryKey: contextKeys.detail(id) });
          queryClient.invalidateQueries({ queryKey: contextKeys.lists() });
          toast.success(CONTEXT_MESSAGES.deleteSuccess);
        },
      });
    }
    ```
  - [ ] Add JSDoc documenting behavior and cache cleanup

- [ ] **Task 9: Set up MSW (Mock Service Worker) for API mocking** (AC: 6)
  - [ ] Create `my_flow_client/src/mocks/handlers.ts`
  - [ ] Import `http`, `HttpResponse` from `msw`
  - [ ] Create mock context data (3-4 sample contexts)
  - [ ] Define MSW handlers for context API endpoints with realistic behavior:
    ```typescript
    import { http, HttpResponse, delay } from 'msw';
    import { CONTEXT_MESSAGES } from '@/lib/messages/contexts';

    export const handlers = [
      http.get('/api/v1/contexts', async () => {
        await delay(100); // Simulate network latency
        return HttpResponse.json(mockContexts);
      }),

      http.get('/api/v1/contexts/:id', async ({ params }) => {
        await delay(50);
        const context = mockContexts.find((ctx) => ctx.id === params.id);
        if (!context) {
          return new HttpResponse(null, {
            status: 404,
            statusText: 'Not Found',
          });
        }
        return HttpResponse.json(context);
      }),

      http.post('/api/v1/contexts', async ({ request }) => {
        await delay(200);
        const body = await request.json();
        if (!body.name || body.name.length > 50) {
          return HttpResponse.json(
            { detail: CONTEXT_MESSAGES.createError },
            { status: 400 }
          );
        }

        const created = {
          ...body,
          id: crypto.randomUUID(),
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        } satisfies Context;

        mockContexts.push(created);
        return HttpResponse.json(created, { status: 201 });
      }),

      http.put('/api/v1/contexts/:id', async ({ request, params }) => {
        await delay(150);
        const existingIndex = mockContexts.findIndex((ctx) => ctx.id === params.id);
        if (existingIndex === -1) {
          return HttpResponse.json(
            { detail: CONTEXT_MESSAGES.updateError },
            { status: 404 }
          );
        }
        const body = await request.json();
        mockContexts[existingIndex] = {
          ...mockContexts[existingIndex],
          ...body,
          updated_at: new Date().toISOString(),
        };
        return HttpResponse.json(mockContexts[existingIndex]);
      }),

      http.delete('/api/v1/contexts/:id', async ({ params }) => {
        await delay(120);
        const index = mockContexts.findIndex((ctx) => ctx.id === params.id);
        if (index === -1) {
          return HttpResponse.json(
            { detail: CONTEXT_MESSAGES.deleteError },
            { status: 404 }
          );
        }
        mockContexts.splice(index, 1);
        return HttpResponse.json({ success: true }, { status: 200 });
      }),
    ];
    ```
  - [ ] Document in tests that additional scenarios (e.g., 401 unauthorized) can be simulated via `server.use(http.get(..., () => HttpResponse.json(..., { status: 401 })))`
  - [ ] Export `handlers` array
  - [ ] Create `my_flow_client/src/mocks/server.ts` for Node.js environment (tests)
  - [ ] Export `server` instance using `setupServer(...handlers)`

- [ ] **Task 10: Write integration tests for useContexts hook** (AC: 6)
  - [ ] Create `my_flow_client/src/hooks/__tests__/use-contexts.test.tsx`
  - [ ] Import `renderHook`, `waitFor` from `@testing-library/react`
  - [ ] Import `QueryClient`, `QueryClientProvider` from `@tanstack/react-query`
  - [ ] Import `server` from `@/mocks/server`
  - [ ] Set up MSW server before/after tests:
    ```typescript
    beforeAll(() => server.listen());
    afterEach(() => server.resetHandlers());
    afterAll(() => server.close());
    ```
  - [ ] Create test wrapper with QueryClientProvider:
    ```typescript
    const createWrapper = () => {
      const queryClient = new QueryClient({
        defaultOptions: {
          queries: {
            retry: false,
            gcTime: 10 * 60 * 1000, // mirror list gcTime; detail queries override individually
          },
          mutations: { retry: false },
        },
      });
      return ({ children }: { children: React.ReactNode }) => (
        <QueryClientProvider client={queryClient}>
          {children}
        </QueryClientProvider>
      );
    };
    ```
  - [ ] Test: `useContexts() successfully fetches contexts`
    - Render hook with wrapper
    - Wait for loading to complete
    - Assert `result.current.data` contains expected contexts
    - Assert `result.current.isLoading` is false
    - Spy on `toast.error` to ensure it is *not* called on success (reset mock afterward)
  - [ ] Test: `useContexts() throws when unauthenticated`
    - Mock `useCurrentUser` to return `{ userId: null, isAuthenticated: false }`
    - Assert hook invocation throws descriptive error
  - [ ] Test: `useContexts() handles fetch error`
    - Override MSW handler to return 500 error
    - Render hook
    - Wait for error state
    - Assert `result.current.error` is defined
    - Assert component-level effect fires `toast.error` with message from `transformError` (fallback to `CONTEXT_MESSAGES.fetchListError` when undefined)
  - [ ] Test: `useContexts() handles 401 by surfacing error`
    - Override MSW handler to return 401
    - Render hook
    - Wait for error state
    - Assert `result.current.error` is defined and contains status 401 (AppError)
    - Assert `toast.error` called with `CONTEXT_MESSAGES.fetchListError`

- [ ] **Task 11: Write integration tests for useContext hook** (AC: 6)
  - [ ] In `my_flow_client/src/hooks/__tests__/use-contexts.test.tsx`
  - [ ] Test: `useContext(id) fetches single context by ID`
    - Render hook with mock ID
    - Wait for loading to complete
    - Assert `result.current.data` matches expected context
    - Assert correct API endpoint was called
    - Assert `toast.error` not called on success
  - [ ] Test: `useContext(id) handles 404 not found`
    - Override MSW handler to return 404
    - Render hook with invalid ID
    - Wait for error state
    - Assert error is defined
    - Assert consuming component effect triggers `toast.error` with fallback message (`CONTEXT_MESSAGES.fetchDetailError`)
  - [ ] Test: `useContext(id) handles 401 unauthorized`
    - Override MSW handler to return 401
    - Render hook
    - Wait for error state
    - Assert component-level effect fires `toast.error` with `CONTEXT_MESSAGES.fetchDetailError`
    - Assert error resembles AppError with statusCode 401

- [ ] **Task 12: Write integration tests for mutation hooks** (AC: 6)
  - [ ] In `my_flow_client/src/hooks/__tests__/use-contexts.test.tsx`
  - [ ] Test: `useCreateContext() creates context with optimistic update`
    - Render both `useContexts` and `useCreateContext` hooks
    - Wait for contexts to load
    - Call `createContext.mutate(newContextData)`
    - Assert context appears in list immediately (optimistic)
    - Wait for mutation to settle
    - Assert context has real ID from server
    - Assert `toast.success` called with `CONTEXT_MESSAGES.createSuccess`
  - [ ] Test: `useCreateContext() rolls back on error`
    - Override MSW handler to return 400 error
    - Render hooks
    - Call `createContext.mutate(invalidData)`
    - Assert optimistic context appears
    - Wait for error
    - Assert context is removed (rollback)
    - Assert error state is set
    - Assert `toast.error` called with message from `transformError` (fallback to `CONTEXT_MESSAGES.createError`)
  - [ ] Test: `useUpdateContext() updates context with optimistic update`
    - Render hooks
    - Call `updateContext.mutate({ id, data: { name: 'Updated' } })`
    - Assert context name updates immediately
    - Wait for mutation to settle
    - Assert context remains updated
    - Assert `toast.success` called with `CONTEXT_MESSAGES.updateSuccess`
  - [ ] Test: `useUpdateContext() rolls back on error`
    - Override MSW to return 500 error
    - Call `updateContext.mutate()`
    - Assert optimistic update appears
    - Wait for error
    - Assert context reverts to original state
    - Assert `toast.error` called with error message (fallback constant)
  - [ ] Test: `useDeleteContext(id) removes context with optimistic update`
    - Render hooks with target ID (e.g., `renderHook(() => useDeleteContext(existingContext.id))`)
    - Call `deleteContext.mutate()`
    - Assert context disappears immediately
    - Wait for mutation to settle
    - Assert context remains deleted
    - Assert `toast.success` called with `CONTEXT_MESSAGES.deleteSuccess`
  - [ ] Test: `useDeleteContext(id) rolls back on error`
    - Override MSW to return 403 error
    - Render hooks with target ID (same pattern as success case)
    - Call `deleteContext.mutate()`
    - Assert context disappears
    - Wait for error
    - Assert context is restored (rollback)
    - Assert `toast.error` called with error message (fallback constant)

- [ ] **Task 13: Run tests and verify coverage** (AC: 6)
  - [ ] Run unit tests: `cd my_flow_client && bun test use-contexts`
  - [ ] Verify all tests pass (10+ tests expected)
  - [ ] Run coverage: `bun test use-contexts --coverage`
  - [ ] Verify coverage â‰¥ 80% for `use-contexts.ts` and `contexts.ts`
  - [ ] Fix any failing tests or coverage gaps
  - [ ] Document coverage report in story

- [ ] **Task 14: Verify code quality and compliance** (AC: All)
  - [ ] Run linter: `cd my_flow_client && bun run lint`
  - [ ] Fix any ESLint errors or warnings
  - [ ] Run type checker: `bun run typecheck`
  - [ ] Fix any TypeScript errors
  - [ ] Verify import order follows coding standards (external â†’ internal â†’ relative)
  - [ ] Verify no hardcoded API URLs (should use `apiRequest` from `api-client.ts`)
  - [ ] Verify all functions have JSDoc comments
  - [ ] Verify all types are exported and properly documented

## Dev Notes

### ðŸŽ¯ CRITICAL: UX Component Styling Guide Compliance

**MANDATORY READING BEFORE IMPLEMENTATION:**
- `docs/ux-design-tokens/component-styling-guide.md` - Sally's complete UX specifications
- `docs/architecture/coding-standards.md` - Tailwind CSS variable usage (Section 8)

**This story does NOT implement UI components**, but the API client and hooks will be consumed by components that MUST follow Sally's styling guide. Developers should be aware that:
1. All future components using these hooks must use CSS design tokens
2. Context colors are NOT for priority badges (use semantic colors instead)
3. Component Styling Guide must be consulted before building any UI

[Source: docs/ux-design-tokens/component-styling-guide.md]

---

### Previous Story Insights (Story 2.6)

**Key Learnings from Flow List Implementation:**
- TypeScript enums for fixed value sets (FlowPriority) - Contexts may need ContextType enum
- Comprehensive test coverage (10+ tests) with proper MSW setup
- `'use client'` directive only needed for interactive components (not needed for hooks)
- Test hooks using `renderHook` from React Testing Library
- MSW handlers should mimic real API behavior (delays, error cases, edge cases)
- Query keys should be hierarchical for efficient cache invalidation

[Source: docs/stories/2.6.story.md]

---

### TanStack Query Architecture (from Frontend Architecture)

**State Management Strategy:**

My Flow uses a **two-layer state management** approach:
1. **Server State (TanStack Query)** - All data from API (contexts, flows, preferences)
2. **Local State (React Context)** - Minimal UI state (current context ID, theme)

**Query Key Convention:**

TanStack Query uses hierarchical query keys for efficient cache management:

```typescript
// Query keys structure
const contextKeys = {
  all: ['contexts'] as const,                          // ['contexts']
  lists: () => [...contextKeys.all, 'list'] as const,  // ['contexts', 'list']
  list: (userId: string) => [...contextKeys.lists(), userId] as const, // ['contexts', 'list', userId]
  details: () => [...contextKeys.all, 'detail'] as const, // ['contexts', 'detail']
  detail: (id: string) => [...contextKeys.details(), id] as const, // ['contexts', 'detail', id]
}
```

**Benefits:**
- Invalidate all context queries: `queryClient.invalidateQueries({ queryKey: contextKeys.all })`
- Invalidate only lists: `queryClient.invalidateQueries({ queryKey: contextKeys.lists() })`
- Invalidate specific detail: `queryClient.invalidateQueries({ queryKey: contextKeys.detail(id) })`

[Source: docs/architecture/frontend-architecture.md#state-management-architecture]

---

### Optimistic Update Pattern (from Frontend Architecture)

**Critical Implementation Guidance:**

Optimistic updates provide <500ms perceived latency for better UX. The pattern:

1. **onMutate**: Update cache immediately before API call
2. **onError**: Rollback cache to previous state if API fails
3. **onSettled/onSuccess**: Invalidate queries to sync with server

**Example from Frontend Architecture:**

```typescript
export function useToggleFlowCompletion() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (flowId: string) =>
      apiClient.post<Flow>(`/api/v1/flows/${flowId}/complete`, {}),

    // Optimistic update (instant UI feedback)
    onMutate: async (flowId) => {
      await queryClient.cancelQueries({ queryKey: ['flows'] });
      const previousFlows = queryClient.getQueryData<Flow[]>(['flows']);

      queryClient.setQueryData<Flow[]>(['flows'], (old) =>
        old?.map((flow) =>
          flow.id === flowId
            ? { ...flow, is_completed: !flow.is_completed }
            : flow
        )
      );

      return { previousFlows };
    },

    // Rollback on error
    onError: (err, flowId, context) => {
      queryClient.setQueryData(['flows'], context?.previousFlows);
      toast.error('Failed to update flow');
    },

// Refetch to sync with server
onSettled: () => {
  queryClient.invalidateQueries({ queryKey: ['flows'] });
},
});
}
```

**Key Points:**
- `cancelQueries` prevents race conditions
- Return previous state in `onMutate` for rollback
- Use `setQueryData` to update cache optimistically
- Use `invalidateQueries` to refetch from server after mutation

[Source: docs/architecture/frontend-architecture.md lines 261-299]

---

1. **Pre-refetch cache normalization:** Replace optimistic entries with real server data (or remove deleted items) before calling `invalidateQueries`. This prevents duplicate renders during refetch.
2. **Immutable updates only:** Always return new arrays/objects from `setQueryData` (no in-place mutation).
3. **Fallback safety:** Even after normalization, call `invalidateQueries` to guarantee server sync.

Example pattern used in Task 6:

```typescript
onMutate: async (newContext) => {
  const tempId = `temp-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  const optimisticContext = { ... };
  queryClient.setQueryData(contextKeys.list(userId), (old) => [...(old || []), optimisticContext]);
  return { previousContexts, tempId };
},

onSuccess: (createdContext, _variables, context) => {
  queryClient.setQueryData<Context[]>(
    contextKeys.list(userId),
    (old) =>
      old?.map((ctx) =>
        context?.tempId && ctx.id === context.tempId ? createdContext : ctx
      ) ?? []
  );

  queryClient.invalidateQueries({ queryKey: contextKeys.lists() });
  toast.success(CONTEXT_MESSAGES.createSuccess);
}
```

---

### Prefetching & Parallel Query Strategies

- Use `queryClient.prefetchQuery` to warm detail caches while hovering or before navigation:
  ```typescript
  const queryClient = useQueryClient();

  function prefetchContext(id: string) {
    queryClient.prefetchQuery({
      queryKey: contextKeys.detail(id),
      queryFn: () => fetchContextById(id),
      gcTime: 2 * 60 * 1000,
    });
  }
  ```
- Helpful when list & detail data render in parallel; reduces perceived latency.
- Ensure prefetch respects the same cache settings as the actual query (staleTime/gcTime).
- Monitor total cached queries; adjust `QueryClient` `defaultOptions` (e.g., lower `gcTime`, use `maxPages`) if future usage shows memory pressure.

---

### Toast Messaging Consistency & i18n Readiness

- Success/failure toasts for create/update/delete must import shared messages from `@/lib/messages/contexts`
- `transformError()` already returns user-friendly messages; fall back to `CONTEXT_MESSAGES.*Error` if `userMessage` is undefined
- All success toasts use `CONTEXT_MESSAGES.*Success`; no hardcoded strings in hooks/components
- Console logging should leverage the same constants to keep developer diagnostics uniform
- Never surface raw backend error payloads (avoid leaking context names or sensitive data); rely on sanitized `transformError` output or generic fallbacks
- Future i18n can replace the constants map with a translation helper without touching hook logic

---

### Context Data Model (from Data Models)

**Context Interface (Reference Only):**

> Backend Pydantic models define the canonical shape. Frontend TypeScript must import aliases from the generated OpenAPI types (Task 0.5) rather than duplicating this structure manually.

```typescript
interface Context {
  id: string;                 // MongoDB ObjectId
  user_id: string;           // Logto user identifier (from JWT sub claim)
  name: string;              // 1-50 chars (e.g., "Work", "Personal")
  color: string;             // Hex format: #3B82F6
  icon: string;              // Emoji: ðŸ’¼, ðŸ , ðŸŒ™, ðŸŽ‰
  created_at: string;        // ISO 8601 datetime
  updated_at: string;        // ISO 8601 datetime
}

interface ContextCreate {
  name: string;              // Required, 1-50 chars
  color: string;             // Required, hex format
  icon: string;              // Required, emoji
}

interface ContextUpdate {
  name?: string;             // Optional, 1-50 chars
  color?: string;            // Optional, hex format
  icon?: string;             // Optional, emoji
}
```

> Reference only. Frontend code must alias the generated OpenAPI typings (Task 0.5) rather than redefining these structures by hand.

**Relationships:**
- **One-to-Many with Flow:** A Context can have multiple Flows (cascade delete)
- **Many-to-One with User:** Multiple Contexts belong to a single user (via `user_id`)

**Validation Rules:**
- `name`: 1-50 characters, required
- `color`: Hex format `#RRGGBB`, required (e.g., `#3B82F6`)
- `icon`: Single emoji character, required

[Source: docs/architecture/data-models.md lines 0-48]

---

### API Specification for Contexts

**Context API Endpoints:**

| Method | Endpoint | Auth | Request Body | Response | Purpose |
|--------|----------|------|--------------|----------|---------|
| GET | `/api/v1/contexts` | Required | - | `Context[]` | List all user contexts |
| GET | `/api/v1/contexts/{id}` | Required | - | `Context` | Get single context |
| POST | `/api/v1/contexts` | Required | `ContextCreate` | `Context` | Create new context |
| PUT | `/api/v1/contexts/{id}` | Required | `ContextUpdate` | `Context` | Update context |
| DELETE | `/api/v1/contexts/{id}` | Required | - | `void` | Delete context (cascades to flows) |

**Authentication:**
- All endpoints require `Authorization: Bearer <logto_jwt_token>` header
- JWT token validated via Logto JWKS public key
- `user_id` extracted from JWT `sub` claim for authorization
- Returns 401 for missing/invalid tokens
- Returns 403 for unauthorized access (accessing another user's context)

**Error Responses:**
- 400 Bad Request: Invalid request body (validation errors)
- 401 Unauthorized: Missing or invalid JWT token
- 403 Forbidden: User does not own the context
- 404 Not Found: Context ID does not exist
- 500 Internal Server Error: Server-side error

[Source: docs/architecture/api-specification.md lines 0-146]

---

### Existing API Client (Server Action Pattern)

**Current Implementation:**

The project already has a server action-based API client in `my_flow_client/src/lib/api-client.ts`:

```typescript
// Server action to get Logto access token
export async function getApiAccessToken(): Promise<string | null> {
  'use server';
  const resource = process.env['NEXT_PUBLIC_LOGTO_RESOURCE'];
  const accessToken = await getAccessToken(logtoConfig, resource);
  return accessToken;
}

// Server action for API requests
export async function apiRequest<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  'use server';
  const token = await getApiAccessToken();

  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    ...(options.headers as Record<string, string>),
  };

  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }

  const response = await fetch(`${API_BASE_URL}${endpoint}`, {
    ...options,
    headers,
  });

  if (!response.ok) {
    throw new Error(`API request failed: ${response.statusText}`);
  }

  return response.json() as Promise<T>;
}
```

**Usage in Context API Client:**

```typescript
// my_flow_client/src/lib/api/contexts.ts
import { apiRequest } from '@/lib/api-client';
import type { components } from '@/types/api';

type Context = components['schemas']['ContextResponse'];
type ContextCreate = components['schemas']['ContextCreate'];
type ContextUpdate = components['schemas']['ContextUpdate'];

export async function fetchContexts(): Promise<Context[]> {
  return apiRequest<Context[]>('/api/v1/contexts');
}

export async function createContext(data: ContextCreate): Promise<Context> {
  return apiRequest<Context>('/api/v1/contexts', {
    method: 'POST',
    body: JSON.stringify(data),
  });
}
```

**Key Points:**
- `apiRequest` is a server action (`'use server'`)
- Automatically injects Logto JWT token from session
- Handles JSON serialization/deserialization
- Base URL from `NEXT_PUBLIC_API_URL` environment variable
- All API client functions should use this instead of raw `fetch()`

[Source: my_flow_client/src/lib/api-client.ts]

---

### TanStack Query Configuration Best Practices

**Query Configuration:**

```typescript
export function useContexts() {
  const userId = 'current-user-id'; // TODO: Get from Logto context

  return useQuery({
    queryKey: contextKeys.list(userId),
    queryFn: fetchContexts,
    staleTime: 5 * 60 * 1000,        // 5 minutes (contexts change infrequently)
    gcTime: 10 * 60 * 1000,          // 10 minutes (garbage collection)
    refetchOnWindowFocus: true,      // Auto-sync when user returns to tab
    enabled: !!userId,               // Only fetch if user is authenticated
  });
}
```

**Configuration Rationale:**

- **staleTime: 5 minutes** - Contexts don't change frequently, so longer stale time reduces API calls
- **gcTime: 10 minutes** - Prevents premature cache eviction when users switch between contexts frequently (React Query v5 renamed `cacheTime` to `gcTime`)
- **refetchOnWindowFocus: true** - Ensures user sees latest data when switching tabs
- **enabled guard** - Prevents queries when user is not authenticated
- **Query keys include userId** - Ensures cache is scoped per user

**Mutation Configuration:**

```typescript
export function useCreateContext() {
  return useMutation({
    mutationFn: createContext,
    onMutate: async (newContext) => { /* Optimistic update */ },
    onError: (err, newContext, context) => { /* Rollback */ },
    onSuccess: (data) => { /* Invalidate cache */ },
  });
}
```

**Mutation Callbacks:**
- **onMutate**: Runs before API call, perfect for optimistic updates
- **onError**: Runs on API failure, use for rollback and error notifications
- **onSuccess**: Runs on API success, use for cache invalidation and success notifications
- **onSettled**: Runs after success or error, use for cleanup

[Source: TanStack Query documentation + coding standards]

---

### Testing Strategy for React Query Hooks

**Test File Organization:**

```
my_flow_client/src/hooks/__tests__/
â””â”€â”€ use-contexts.test.tsx
```

**Test Setup with MSW:**

```typescript
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { server } from '@/mocks/server';

// Set up MSW server
beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

// Create wrapper with QueryClientProvider
const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },      // Disable retries in tests
      mutations: { retry: false },    // Disable retries in tests
    },
  });
  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};
```

**Test Pattern for useQuery:**

```typescript
it('fetches contexts successfully', async () => {
  const { result } = renderHook(() => useContexts(), {
    wrapper: createWrapper(),
  });

  // Initial loading state
  expect(result.current.isLoading).toBe(true);

  // Wait for data to load
  await waitFor(() => expect(result.current.isSuccess).toBe(true));

  // Verify data
  expect(result.current.data).toHaveLength(3);
  expect(result.current.data?.[0].name).toBe('Work');
});
```

**Test Pattern for useMutation with Optimistic Update:**

```typescript
it('creates context with optimistic update', async () => {
  const wrapper = createWrapper();

  // Render both query and mutation hooks
  const { result: queryResult } = renderHook(() => useContexts(), { wrapper });
  const { result: mutationResult } = renderHook(() => useCreateContext(), { wrapper });

  // Wait for initial data
  await waitFor(() => expect(queryResult.current.isSuccess).toBe(true));
  const initialCount = queryResult.current.data?.length || 0;

  // Trigger mutation
  mutationResult.current.mutate({
    name: 'New Context',
    color: '#3B82F6',
    icon: 'ðŸŽ‰',
  });

  // Verify optimistic update (context appears immediately)
  await waitFor(() => {
    expect(queryResult.current.data?.length).toBe(initialCount + 1);
  });

  // Wait for mutation to settle
  await waitFor(() => expect(mutationResult.current.isSuccess).toBe(true));

  // Verify context has real ID from server
  const newContext = queryResult.current.data?.find(c => c.name === 'New Context');
  expect(newContext?.id).not.toContain('temp-');
});
```

**Coverage Requirements:**
- 80% minimum coverage for hooks and API client files
- Test success cases (fetch, create, update, delete)
- Test error cases (API failures, validation errors)
- Test optimistic updates (immediate UI feedback)
- Test rollback on error (cache restored to previous state)

[Source: docs/architecture/testing-strategy.md, Story 2.6 learnings]

---

### Import Order Standards (from Coding Standards)

**Frontend TypeScript Import Order:**

```typescript
// 1. External dependencies
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

// 2. Internal absolute imports (@/ alias)
import { apiRequest } from '@/lib/api-client';
import type { components } from '@/types/api';

type Context = components['schemas']['ContextResponse'];
type ContextCreate = components['schemas']['ContextCreate'];
type ContextUpdate = components['schemas']['ContextUpdate'];

// 3. Relative imports
import { contextKeys } from './query-keys';

// 4. Styles (if any)
import './styles.css';
```

[Source: docs/architecture/coding-standards.md#import-order-standards]

---

### File Organization (from Source Tree)

**Frontend Structure for this Story:**

```
my_flow_client/src/
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â””â”€â”€ contexts.ts          # NEW: Context API client functions
â”‚   â””â”€â”€ api-client.ts            # EXISTING: Server action for authenticated requests
â”‚   â””â”€â”€ messages/
â”‚       â””â”€â”€ contexts.ts          # NEW: Toast/message constants for contexts domain
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ use-contexts.ts          # NEW: TanStack Query hooks
â”‚   â”œâ”€â”€ use-current-user.ts      # NEW: Client hook + context for Logto session
â”‚   â””â”€â”€ __tests__/
â”‚       â”œâ”€â”€ use-contexts.test.tsx    # NEW: Integration tests
â”‚       â””â”€â”€ use-current-user.test.tsx # NEW: Provider/hook tests
â”œâ”€â”€ components/
â”‚   â””â”€â”€ providers/
â”‚       â””â”€â”€ current-user-provider.tsx # NEW: Server component wiring Logto â†’ context
â””â”€â”€ mocks/
    â”œâ”€â”€ handlers.ts              # NEW: MSW API mock handlers
    â””â”€â”€ server.ts                # NEW: MSW server setup for tests
```

**Key Conventions:**
- **API clients** in `lib/api/` directory
- **Custom hooks** in `hooks/` directory
- **Types** in `types/` directory
- **Tests** co-located in `__tests__/` subdirectory
- **MSW mocks** in `mocks/` directory for testing

[Source: docs/architecture/source-tree.md lines 0-75]

---

### Tech Stack (TanStack Query Version)

**State Management (Server) - TanStack Query:**
- **Version:** 5.x
- **Purpose:** Server state caching, optimistic updates, automatic refetching
- **Features:** Request deduplication, cache invalidation, background refetching
- **Installation:** `bun add @tanstack/react-query@5.x`

**Testing - MSW (Mock Service Worker):**
- **Version:** latest
- **Purpose:** Mock API responses in tests without changing code
- **Features:** Intercepts network requests, simulates API behavior
- **Installation:** `bun add -d msw@latest`

[Source: docs/architecture/tech-stack.md]

---

### Error Handling (Coding Standards Section 5)

**Required Implementation (AC: 3):**

All mutation error handlers must follow the error transformation pattern from coding standards:

```typescript
import { transformError } from '@/lib/errors';
import { toast } from 'sonner'; // Using Sonner toast library

onError: (err, newContext, context) => {
  // 1. Rollback optimistic update
  if (context?.previousContexts) {
    queryClient.setQueryData(contextKeys.list(userId), context.previousContexts);
  }

  // 2. Transform error to user-friendly message
  const appError = transformError(err);

  // 3. Show toast notification with user message
  toast.error(appError.userMessage); // e.g., "Failed to create context. Please try again."

  // 4. Log full error for debugging
  console.error('Failed to create context:', err);
}
```

**Key Requirements:**
- Use `transformError()` to convert API errors to AppError with user-friendly messages
- Use `toast.error()` from Sonner for user notifications
- Keep `console.error()` for debugging purposes
- Follow consistent error handling across all mutations (create/update/delete)

[Source: docs/architecture/coding-standards.md Section 5]

---

### Race Condition Handling and Mutation Keys

**Required Implementation:**

This story implements **two-layer race condition prevention** for optimal UX:

**Layer 1: cancelQueries (Query Race Conditions)**

Cancels in-flight queries before optimistic updates to prevent stale data conflicts:

```typescript
onMutate: async (newContext) => {
  await queryClient.cancelQueries({ queryKey: contextKeys.list(userId) });
  // ... optimistic update
}
```

**Layer 2: mutationKey (Duplicate Submission Prevention) - MANDATORY**

Prevents duplicate mutations from double-clicks, accidental rapid submissions, or keyboard shortcuts:

```typescript
export function useCreateContext() {
  return useMutation({
    mutationKey: ['createContext'], // REQUIRED: Prevents duplicate submissions
    mutationFn: (data: ContextCreate) => createContext(data),
    onMutate: async (newContext) => {
      await queryClient.cancelQueries({ queryKey: contextKeys.list(userId) });
      // ... rest of implementation
    },
    // ... rest of callbacks
  });
}
```

**Why mutationKey is Mandatory:**

**Scenario without mutationKey:**
1. User rapidly clicks "Create Context" twice (double-click)
2. Both mutations execute independently
3. API creates two identical contexts
4. User sees duplicate contexts in UI
5. User must manually delete the duplicate

**Scenario with mutationKey:**
1. User rapidly clicks "Create Context" twice
2. TanStack Query deduplicates mutations with same key
3. Only one API call executes
4. Clean UX, no duplicates

**Implementation Requirements:**
- âœ… All mutations (create/update/delete) MUST include `mutationKey`
- âœ… Mutation keys should be descriptive: `['createContext']`, `['updateContext']`, `['deleteContext']`
- âœ… This is a **critical UX requirement**, not an optional enhancement
- âš ï¸ Alternative approach (button disabled state based on `isPending`) should be done at component level, but `mutationKey` provides defense-in-depth

[Source: TanStack Query best practices, UX standards]

---

### Hierarchical Mutation Keys Pattern

**Implementation Approach:**

Mutation keys follow a hierarchical pattern similar to query keys for consistency:

```typescript
const contextMutations = {
  create: ['contexts', 'create'] as const,
  update: (id: string) => ['contexts', 'update', id] as const,
  delete: (id: string) => ['contexts', 'delete', id] as const,
}
```

**Benefits:**

1. **Consistency** - Matches the hierarchical pattern used for query keys
2. **Granular Control** - Allows canceling specific mutations if needed (e.g., cancel update for context X)
3. **Type Safety** - `as const` provides better TypeScript inference
4. **Debugging** - Clear mutation names in React Query DevTools

**Usage Patterns:**

- **create**: Uses static key `['contexts', 'create']` (all creates share same key)
- **update**: Uses parameterized key `['contexts', 'update', id]` (each context has unique key)
- **delete**: Uses parameterized key `contextMutations.delete(id)` (hook receives `id` so key stays scoped per context)

**Why delete must use parameterized key:**

Without the ID in the mutation key, simultaneous deletes of different contexts share the same key, allowing stale optimistic results to collide. Passing the `id` into the hook ensures each delete has its own key and preserves optimistic updates per context.

[Source: TanStack Query best practices, pattern consistency]

---

### User ID Resolution with useCurrentUser Hook

**Current Implementation:**

This story builds a **Logto-backed user context** so client components have access to the authenticated user ID, email, and name without duplicating auth logic:

```typescript
// hooks/use-current-user.ts
'use client';

import { createContext, useContext } from 'react';
import type { IdTokenClaims } from '@logto/next';

export interface CurrentUserState {
  userId: string | null;
  email?: string;
  name?: string;
  claims?: IdTokenClaims | null;
  isAuthenticated: boolean;
  isLoading: boolean;
}

const CurrentUserContext = createContext<CurrentUserState | undefined>(undefined);

export function CurrentUserProvider({
  value,
  children,
}: {
  value: CurrentUserState;
  children: React.ReactNode;
}): React.ReactElement {
  return (
    <CurrentUserContext.Provider value={value}>
      {children}
    </CurrentUserContext.Provider>
  );
}

export function useCurrentUser(): CurrentUserState {
  const context = useContext(CurrentUserContext);
  if (!context) {
    throw new Error('useCurrentUser must be used within CurrentUserProvider (wrap app in CurrentUserServerProvider).');
  }
  return context;
}
```

```typescript
// components/providers/current-user-provider.tsx (server component)
import type { ReactNode } from 'react';
import { getLogtoContext } from '@logto/next/server-actions';
import { logtoConfig } from '@/lib/logto';
import { CurrentUserProvider, type CurrentUserState } from '@/hooks/use-current-user';

export async function CurrentUserServerProvider({
  children,
}: {
  children: ReactNode;
}): Promise<React.ReactElement> {
  const { isAuthenticated, claims } = await getLogtoContext(logtoConfig);

  const value: CurrentUserState = {
    userId: claims?.sub ?? null,
    email: claims?.email,
    name: claims?.name,
    claims: claims ?? null,
    isAuthenticated,
    isLoading: false,
  };

  return <CurrentUserProvider value={value}>{children}</CurrentUserProvider>;
}
```

```tsx
// app/layout.tsx (excerpt)
import { CurrentUserServerProvider } from '@/components/providers/current-user-provider';

export default async function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <CurrentUserServerProvider>
          <Navigation />
          {children}
        </CurrentUserServerProvider>
        <Toaster />
      </body>
    </html>
  );
}
```

```typescript
// Usage in hooks (client)
export function useContexts() {
  const { userId, isAuthenticated } = useCurrentUser();
  return useQuery({
    queryKey: contextKeys.list(userId ?? 'unauthenticated'),
    queryFn: fetchContexts,
    enabled: isAuthenticated && !!userId,
  });
}
```

**Key Characteristics:**

1. **Real Logto session data** surfaces to client components (userId/email/name)
2. **Single integration point** for future auth enhancements (update provider only)
3. **Graceful unauthenticated state** yields `userId = null`, `isAuthenticated = false`
4. **Test-friendly** â€“ hooks/tests can inject fake users by wrapping components with `CurrentUserProvider`
5. **TanStack compatibility** â€“ query keys and `enabled` guards receive canonical user IDs
6. **Session snapshot scope** â€“ Provider state reflects the session at render time; if background auth changes occur (e.g., logout in another tab), API requests returning 401 should bubble up so components can trigger a refresh/reload (see Task 2 note)

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-08 | 1.0 | Story created for Epic 2.7 | Bob (Scrum Master) |
| 2025-10-08 | 1.1 | Updated error handling to use transformError() and toast.error() per coding standards Section 5 | Bob (Scrum Master) |
| 2025-10-08 | 1.2 | Added gcTime configuration to prevent premature cache eviction in AC #3, Tasks 4-5, and Dev Notes | Bob (Scrum Master) |
| 2025-10-08 | 1.3 | Made mutationKey mandatory (not optional) to prevent duplicate submissions in AC #3, Tasks 6-8, and Dev Notes | Bob (Scrum Master) |
| 2025-10-08 | 1.4 | Added hierarchical mutation keys, useCurrentUser hook scaffolding, and success toast notifications for UX consistency | Bob (Scrum Master) |
| 2025-10-08 | 1.5 | Scoped delete mutation key via `contextMutations.delete(id)` and aligned hook/tests to prevent concurrent delete collisions | Bob (Scrum Master) |
| 2025-10-08 | 1.6 | Updated types workflow to use OpenAPI-generated definitions; added codegen task per coding standards Section 1 | Bob (Scrum Master) |
| 2025-10-08 | 1.7 | Clarified API client error-handling expectations using `AppError` and explicit 404 guidance | Bob (Scrum Master) |
| 2025-10-08 | 1.8 | Implemented Logto-backed `useCurrentUser` provider and updated story tasks to remove placeholder debt | Bob (Scrum Master) |
| 2025-10-08 | 1.9 | Centralized context toast messages for consistency/i18n readiness | Bob (Scrum Master) |
| 2025-10-08 | 1.10 | Clarified OpenAPI type usage (import directly from `@/types/api`; no alias files) | Bob (Scrum Master) |
| 2025-10-08 | 1.11 | Added query-level error handling requirements (transformError + toast) | Bob (Scrum Master) |
| 2025-10-08 | 1.12 | Documented session snapshot caveat for useCurrentUser + 401 propagation guidance | Bob (Scrum Master) |
| 2025-10-08 | 1.13 | Finalized 404 handling (return null) and tightened detail query cache policy | Bob (Scrum Master) |
| 2025-10-08 | 1.14 | Documented toast message sanitization & generic fallbacks to prevent data leakage | Bob (Scrum Master) |
| 2025-10-08 | 1.15 | Clarified cache eviction strategy (detail gcTime, QueryClient defaults, prefetch guidance) | Bob (Scrum Master) |
| 2025-10-08 | 1.16 | Added CSRF note for server actions + reiterated toast sanitization | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
(To be populated by Dev Agent)

### Debug Log References
(To be populated by Dev Agent)

### Completion Notes List
(To be populated by Dev Agent)

### File List
(To be populated by Dev Agent)

## QA Results

### Review Date: 2025-10-08

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Assessment: EXCELLENT**

This implementation demonstrates exceptional engineering quality across all dimensions. The code follows TanStack Query best practices precisely, implements sophisticated optimistic update patterns, and maintains comprehensive test coverage at 93.15% for hooks and 100% for API client code.

**Key Strengths:**
- **Hierarchical architecture**: Query keys and mutation keys follow consistent, type-safe patterns enabling surgical cache invalidation
- **Optimistic UX**: All mutations implement proper optimistic updates with rollback, providing <500ms perceived latency
- **Error handling**: Consistent use of `transformError()` + `toast` notifications with centralized message constants
- **Type safety**: Direct consumption of OpenAPI-generated types prevents drift between frontend/backend
- **Authentication integration**: Clean Logto session surfacing via `useCurrentUser` hook eliminates auth duplication
- **Test architecture**: 13 integration tests with MSW covering success paths, error scenarios, optimistic updates, and rollback behavior

### Refactoring Performed

**No refactoring required.** The implementation is production-ready as-is.

**Minor observations (non-blocking):**
- `useUpdateContext` correctly handles partial updates with null-checking (`data.name != null`)
- Mutation keys properly scoped (create shared, update/delete per-ID) preventing race conditions
- Cache normalization strategy (replace optimistic â†’ invalidate) prevents duplicate renders

### Compliance Check

- **Coding Standards:** âœ“ Perfect compliance
  - Import order follows convention (external â†’ internal â†’ relative)
  - Types imported from OpenAPI-generated `@/types/api`
  - All functions have JSDoc with examples
  - Server action pattern (`apiRequest`) used consistently

- **Project Structure:** âœ“ Fully compliant
  - Files organized correctly (`lib/api/`, `hooks/`, `mocks/`, `components/providers/`)
  - Test co-location in `__tests__/` directories
  - Centralized messages in `lib/messages/contexts.ts`

- **Testing Strategy:** âœ“ Exceeds requirements
  - 93.15% coverage on hooks (target: 80%)
  - 100% coverage on API client
  - 13 comprehensive integration tests
  - MSW setup correctly handles API mocking with realistic latency
  - Tests cover optimistic updates, rollback, error scenarios, 401/404 handling

- **All ACs Met:** âœ“ 100% complete
  - AC1: API client implemented with all CRUD operations
  - AC2: TanStack Query hooks with proper configuration
  - AC3: Query/mutation keys, optimistic updates, error handling all correct
  - AC4: Hierarchical query key pattern implemented
  - AC5: OpenAPI types generated and consumed directly
  - AC6: Integration tests with MSW, >80% coverage achieved

### Improvements Checklist

**All improvements completed during development:**

- [x] API client with comprehensive JSDoc (contexts.ts:1-141)
- [x] TanStack Query hooks with optimistic updates (use-contexts.ts:1-448)
- [x] Error handling with transformError + toast (errors.ts:1-123)
- [x] Centralized messages for i18n readiness (messages/contexts.ts:1-36)
- [x] useCurrentUser hook backed by Logto session (use-current-user.tsx:1-102)
- [x] CurrentUserServerProvider for SSR integration (current-user-provider.tsx:1-64)
- [x] MSW handlers with realistic API behavior (handlers.ts:1-214)
- [x] Comprehensive integration tests (use-contexts.test.tsx:1-464)
- [x] Null-safe partial update logic in mutations
- [x] Hierarchical mutation keys preventing duplicate submissions

**No remaining work items.**

### Security Review

**Status: PASS**

- âœ“ Authentication enforced via Logto server actions (`apiRequest`)
- âœ“ JWT tokens handled server-side (never exposed to client)
- âœ“ CSRF protection via server action pattern
- âœ“ Error messages sanitized (`transformError` prevents data leakage)
- âœ“ 401 errors bubble up correctly for session revalidation
- âœ“ Input validation delegated to backend (Pydantic models)
- âœ“ No hardcoded credentials or API keys in code

**Observations:**
- Future enhancement: Components should implement 401 error interceptor to trigger session refresh/reload
- Rate limiting on backend endpoints should be verified separately (out of scope for frontend story)

### Performance Considerations

**Status: PASS**

- âœ“ Query `staleTime: 5min` reduces unnecessary API calls for infrequently-changing data
- âœ“ List query `gcTime: 10min` prevents thrashing during context switching
- âœ“ Detail query `gcTime: 2min` prevents unbounded cache growth
- âœ“ Optimistic updates provide <500ms perceived latency
- âœ“ `cancelQueries` prevents race conditions and wasted network requests
- âœ“ Mutation keys prevent duplicate API calls from double-clicks
- âœ“ Cache normalization before invalidation reduces duplicate renders

**Recommendations (future optimization):**
- Consider implementing `prefetchQuery` on hover for detail views (documented in story Dev Notes)
- Monitor QueryClient memory usage if context lists grow beyond 100 items
- Add `maxPages` limit to QueryClient if implementing pagination

### Files Modified During Review

**No files modified.** Implementation is production-ready without changes.

**New files created during development:**
- `my_flow_client/src/lib/api/contexts.ts` (140 lines)
- `my_flow_client/src/lib/errors.ts` (122 lines)
- `my_flow_client/src/lib/messages/contexts.ts` (35 lines)
- `my_flow_client/src/hooks/use-contexts.ts` (447 lines)
- `my_flow_client/src/hooks/use-current-user.tsx` (101 lines)
- `my_flow_client/src/components/providers/current-user-provider.tsx` (63 lines)
- `my_flow_client/src/mocks/handlers.ts` (214 lines)
- `my_flow_client/src/mocks/server.ts` (20 lines)
- `my_flow_client/src/hooks/__tests__/use-contexts.test.tsx` (463 lines)
- `my_flow_client/src/hooks/__tests__/use-current-user.test.tsx` (86 lines)
- `my_flow_client/src/types/openapi-schema.json` (1069 lines, generated)
- Updated: `my_flow_client/src/types/api.ts` (+1040 lines, generated)
- Updated: `my_flow_client/src/app/layout.tsx` (integrated CurrentUserServerProvider)

### Gate Status

**Gate: PASS** â†’ docs/qa/gates/2.7-tanstack-query-integration.yml

**Risk Profile:** Low risk (all mitigations in place)
**NFR Assessment:** All NFRs pass (security, performance, reliability, maintainability)

### Recommended Status

**âœ“ Ready for Done**

This story is complete and production-ready. All acceptance criteria met, tests passing at 93%+ coverage, and code quality exceeds project standards. No blocking issues identified.

**Deployment checklist:**
- âœ“ All tests passing (139 tests, 0 failures)
- âœ“ Linting clean (`eslint --max-warnings=0`)
- âœ“ Type checking clean (`tsc --noEmit`)
- âœ“ Coverage exceeds 80% threshold
- âœ“ Pre-commit hooks passing
- âœ“ Production build succeeds

Story owner may proceed with merging to main.
