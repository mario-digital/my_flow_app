# Story 2.7: TanStack Query Integration for Contexts API (FE)

## Status
Draft

## Story

**As a** frontend developer,
**I want** TanStack Query hooks for context API operations,
**so that** we have optimistic updates, caching, and automatic refetching for context management.

## Acceptance Criteria

1. **API client created in `my_flow_client/src/lib/api/contexts.ts`:**
   - `fetchContexts()` ‚Üí GET /api/v1/contexts
   - `fetchContextById(id: string)` ‚Üí GET /api/v1/contexts/{id}
   - `createContext(data: ContextCreate)` ‚Üí POST /api/v1/contexts
   - `updateContext(id: string, data: ContextUpdate)` ‚Üí PUT /api/v1/contexts/{id}
   - `deleteContext(id: string)` ‚Üí DELETE /api/v1/contexts/{id}
   - All methods use server action `apiRequest` from `@/lib/api-client` with Logto auth
   - TypeScript types imported from `@/types` (Context, ContextCreate, ContextUpdate)

2. **TanStack Query hooks created in `my_flow_client/src/hooks/use-contexts.ts`:**
   - `useContexts()` ‚Üí Uses `useQuery` to fetch all user contexts
   - `useContext(id: string)` ‚Üí Uses `useQuery` to fetch single context
   - `useCreateContext()` ‚Üí Uses `useMutation` with optimistic update
   - `useUpdateContext()` ‚Üí Uses `useMutation` with optimistic update
   - `useDeleteContext()` ‚Üí Uses `useMutation` with optimistic update and cache invalidation

3. **Query configuration follows best practices:**
   - `staleTime: 5 minutes` for context lists (contexts change infrequently)
   - `gcTime: 10 minutes` (garbage collection) prevents premature cache eviction when switching contexts
   - `refetchOnWindowFocus: true` for automatic sync
   - `enabled` guard prevents queries when user is not authenticated
   - `mutationKey` required on all mutations to prevent duplicate submissions from double-clicks
   - Error handling via `onError` callback with toast notifications
   - Optimistic updates for create/update/delete show instant UI feedback

4. **Query keys follow consistent pattern:**
   ```typescript
   const contextKeys = {
     all: ['contexts'] as const,
     lists: () => [...contextKeys.all, 'list'] as const,
     list: (userId: string) => [...contextKeys.lists(), userId] as const,
     details: () => [...contextKeys.all, 'detail'] as const,
     detail: (id: string) => [...contextKeys.details(), id] as const,
   }
   ```

5. **TypeScript types created in `my_flow_client/src/types/context.ts`:**
   - `Context` interface matching backend Pydantic model
   - `ContextCreate` interface for POST requests
   - `ContextUpdate` interface for PUT requests
   - Export types for use across components

6. **Integration tests created in `my_flow_client/src/hooks/__tests__/use-contexts.test.tsx`:**
   - Uses `@testing-library/react` with `QueryClientProvider` wrapper
   - Uses MSW (Mock Service Worker) for API mocking
   - Tests successful fetch, create, update, delete operations
   - Tests optimistic updates (UI reflects changes before API confirms)
   - Tests error handling (optimistic update rollback on API error)
   - Tests cache invalidation strategy
   - At least 80% coverage

## Tasks / Subtasks

- [ ] **Task 0: Verify and install dependencies** (AC: 2, 3, 6)
  - [ ] Check if `@tanstack/react-query` is installed: `bun pm ls | grep @tanstack/react-query`
  - [ ] If not installed: `cd my_flow_client && bun add @tanstack/react-query@5.x`
  - [ ] Check if `msw` (Mock Service Worker) is installed: `bun pm ls | grep msw`
  - [ ] If not installed for testing: `cd my_flow_client && bun add -d msw@latest`
  - [ ] Check if `sonner` (toast library) is installed: `bun pm ls | grep sonner`
  - [ ] If not installed: `cd my_flow_client && bun add sonner`
  - [ ] Verify installation: Check `my_flow_client/package.json` for all dependencies

- [ ] **Task 1: Create Context TypeScript interfaces** (AC: 5)
  - [ ] Create `my_flow_client/src/types/context.ts`
  - [ ] Define `Context` interface matching backend Pydantic model:
    - `id: string` (MongoDB ObjectId)
    - `user_id: string` (Logto user identifier)
    - `name: string` (1-50 chars)
    - `color: string` (hex format `#RRGGBB`)
    - `icon: string` (emoji)
    - `created_at: string` (ISO 8601 datetime)
    - `updated_at: string` (ISO 8601 datetime)
  - [ ] Define `ContextCreate` interface for POST requests:
    - `name: string`
    - `color: string`
    - `icon: string`
  - [ ] Define `ContextUpdate` interface for PUT requests:
    - `name?: string`
    - `color?: string`
    - `icon?: string`
  - [ ] Export all interfaces
  - [ ] Add JSDoc comments documenting field constraints

- [ ] **Task 2: Create Context API client functions** (AC: 1)
  - [ ] Create directory `my_flow_client/src/lib/api/`
  - [ ] Create `my_flow_client/src/lib/api/contexts.ts`
  - [ ] Import `apiRequest` server action from `@/lib/api-client`
  - [ ] Import types from `@/types/context`
  - [ ] Implement `fetchContexts()`:
    - Call `apiRequest<Context[]>('/api/v1/contexts')`
    - Return Promise of Context array
    - Add JSDoc with example usage
  - [ ] Implement `fetchContextById(id: string)`:
    - Call `apiRequest<Context>('/api/v1/contexts/${id}')`
    - Return Promise of single Context
    - Handle 404 errors gracefully
  - [ ] Implement `createContext(data: ContextCreate)`:
    - Call `apiRequest<Context>('/api/v1/contexts', { method: 'POST', body: JSON.stringify(data) })`
    - Return Promise of created Context
  - [ ] Implement `updateContext(id: string, data: ContextUpdate)`:
    - Call `apiRequest<Context>('/api/v1/contexts/${id}', { method: 'PUT', body: JSON.stringify(data) })`
    - Return Promise of updated Context
  - [ ] Implement `deleteContext(id: string)`:
    - Call `apiRequest<void>('/api/v1/contexts/${id}', { method: 'DELETE' })`
    - Return Promise<void>
  - [ ] Export all functions

- [ ] **Task 3: Define Query Keys and Mutation Keys factories** (AC: 4)
  - [ ] In `my_flow_client/src/hooks/use-contexts.ts`, define `contextKeys` object
  - [ ] Implement hierarchical query key structure:
    - `all: ['contexts'] as const` - Base key
    - `lists: () => [...contextKeys.all, 'list'] as const` - All lists
    - `list: (userId: string) => [...contextKeys.lists(), userId] as const` - User-specific list
    - `details: () => [...contextKeys.all, 'detail'] as const` - All details
    - `detail: (id: string) => [...contextKeys.details(), id] as const` - Single context
  - [ ] Define `contextMutations` object for hierarchical mutation keys:
    - `create: ['contexts', 'create'] as const` - Create mutation
    - `update: (id: string) => ['contexts', 'update', id] as const` - Update specific context
    - `delete: (id: string) => ['contexts', 'delete', id] as const` - Delete specific context
  - [ ] Export `contextKeys` and `contextMutations` for use in tests and components
  - [ ] Follow TanStack Query best practices (as const for type inference)

- [ ] **Task 3.5: Create useCurrentUser placeholder hook** (AC: 3)
  - [ ] Create `my_flow_client/src/hooks/use-current-user.ts`
  - [ ] Implement placeholder hook:
    ```typescript
    /**
     * Placeholder hook for current user information.
     * TODO: Integrate with Logto authentication in Story 2.8+
     *
     * @returns Object containing userId and authentication status
     */
    export function useCurrentUser() {
      // TODO: Replace with actual Logto integration
      // This will use useUser() from '@logto/next' in future stories
      return {
        userId: 'current-user-id',
        isAuthenticated: true,
      };
    }
    ```
  - [ ] Export hook for use in other hooks and components
  - [ ] Add JSDoc comment clearly marking this as a TODO for Logto integration
  - [ ] This makes the integration point explicit and easier to find/replace later

- [ ] **Task 4: Implement useContexts() query hook** (AC: 2, 3)
  - [ ] Import `useQuery` from `@tanstack/react-query`
  - [ ] Import `fetchContexts` from `@/lib/api/contexts`
  - [ ] Import `useCurrentUser` from `@/hooks/use-current-user`
  - [ ] Implement `useContexts()` hook:
    ```typescript
    export function useContexts() {
      const { userId } = useCurrentUser();
      return useQuery({
        queryKey: contextKeys.list(userId),
        queryFn: fetchContexts,
        staleTime: 5 * 60 * 1000, // 5 minutes
        gcTime: 10 * 60 * 1000, // 10 minutes (garbage collection)
        refetchOnWindowFocus: true,
        enabled: !!userId,
      });
    }
    ```
  - [ ] Return query result with `{ data, isLoading, error, refetch }` properties
  - [ ] Add JSDoc documenting return type and usage

- [ ] **Task 5: Implement useContext(id) query hook** (AC: 2, 3)
  - [ ] Import `useQuery` from `@tanstack/react-query`
  - [ ] Import `fetchContextById` from `@/lib/api/contexts`
  - [ ] Implement `useContext(id: string)` hook:
    ```typescript
    export function useContext(id: string) {
      return useQuery({
        queryKey: contextKeys.detail(id),
        queryFn: () => fetchContextById(id),
        staleTime: 5 * 60 * 1000,
        gcTime: 10 * 60 * 1000, // 10 minutes (garbage collection)
        enabled: !!id,
      });
    }
    ```
  - [ ] Return query result
  - [ ] Add JSDoc documenting parameters and return type

- [ ] **Task 6: Implement useCreateContext() mutation hook with optimistic update** (AC: 2, 3)
  - [ ] Import `useMutation`, `useQueryClient` from `@tanstack/react-query`
  - [ ] Import `createContext` from `@/lib/api/contexts`
  - [ ] Import `transformError` from `@/lib/errors`
  - [ ] Import `toast` from `sonner`
  - [ ] Import `useCurrentUser` from `@/hooks/use-current-user`
  - [ ] Implement `useCreateContext()` hook:
    ```typescript
    export function useCreateContext() {
      const queryClient = useQueryClient();
      const { userId } = useCurrentUser();

      return useMutation({
        mutationKey: contextMutations.create, // Prevents duplicate submissions
        mutationFn: (data: ContextCreate) => createContext(data),

        // Optimistic update: Add context to cache immediately
        onMutate: async (newContext) => {
          await queryClient.cancelQueries({ queryKey: contextKeys.list(userId) });

          const previousContexts = queryClient.getQueryData<Context[]>(
            contextKeys.list(userId)
          );

          // Optimistically add new context with temporary ID
          const optimisticContext: Context = {
            id: `temp-${Date.now()}`,
            user_id: userId,
            name: newContext.name,
            color: newContext.color,
            icon: newContext.icon,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
          };

          queryClient.setQueryData<Context[]>(
            contextKeys.list(userId),
            (old) => [...(old || []), optimisticContext]
          );

          return { previousContexts };
        },

        // On error: Rollback to previous state
        onError: (err, newContext, context) => {
          if (context?.previousContexts) {
            queryClient.setQueryData(
              contextKeys.list(userId),
              context.previousContexts
            );
          }
          const appError = transformError(err);
          toast.error(appError.userMessage); // e.g., "Failed to create context. Please try again."
          console.error('Failed to create context:', err); // Keep for debugging
        },

        // On success: Replace optimistic data with server response
        onSuccess: (data) => {
          queryClient.invalidateQueries({ queryKey: contextKeys.lists() });
          toast.success('Context created successfully');
        },
      });
    }
    ```
  - [ ] Add JSDoc documenting usage and optimistic update behavior

- [ ] **Task 7: Implement useUpdateContext() mutation hook with optimistic update** (AC: 2, 3)
  - [ ] Import `useMutation`, `useQueryClient` from `@tanstack/react-query`
  - [ ] Import `updateContext` from `@/lib/api/contexts`
  - [ ] Import `transformError` from `@/lib/errors`
  - [ ] Import `toast` from `sonner`
  - [ ] Import `useCurrentUser` from `@/hooks/use-current-user`
  - [ ] Implement `useUpdateContext()` hook:
    ```typescript
    export function useUpdateContext(id: string) {
      const queryClient = useQueryClient();
      const { userId } = useCurrentUser();

      return useMutation({
        mutationKey: contextMutations.update(id), // Prevents duplicate submissions, scoped to specific context
        mutationFn: (data: ContextUpdate) => updateContext(id, data),

        // Optimistic update: Update context in cache immediately
        onMutate: async (data) => {
          await queryClient.cancelQueries({ queryKey: contextKeys.list(userId) });
          await queryClient.cancelQueries({ queryKey: contextKeys.detail(id) });

          const previousContext = queryClient.getQueryData<Context>(
            contextKeys.detail(id)
          );
          const previousContexts = queryClient.getQueryData<Context[]>(
            contextKeys.list(userId)
          );

          // Optimistically update context in list
          queryClient.setQueryData<Context[]>(
            contextKeys.list(userId),
            (old) =>
              old?.map((ctx) =>
                ctx.id === id ? { ...ctx, ...data, updated_at: new Date().toISOString() } : ctx
              )
          );

          // Optimistically update single context query
          queryClient.setQueryData<Context>(
            contextKeys.detail(id),
            (old) => (old ? { ...old, ...data, updated_at: new Date().toISOString() } : old)
          );

          return { previousContext, previousContexts };
        },

        onError: (err, data, context) => {
          if (context?.previousContext) {
            queryClient.setQueryData(contextKeys.detail(id), context.previousContext);
          }
          if (context?.previousContexts) {
            queryClient.setQueryData(contextKeys.list(userId), context.previousContexts);
          }
          const appError = transformError(err);
          toast.error(appError.userMessage); // e.g., "Failed to update context. Please try again."
          console.error('Failed to update context:', err); // Keep for debugging
        },

        onSuccess: (data) => {
          queryClient.invalidateQueries({ queryKey: contextKeys.detail(id) });
          queryClient.invalidateQueries({ queryKey: contextKeys.lists() });
          toast.success('Context updated successfully');
        },
      });
    }
    ```
  - [ ] Add JSDoc documenting parameters and behavior

- [ ] **Task 8: Implement useDeleteContext() mutation hook with optimistic update** (AC: 2, 3)
  - [ ] Import `useMutation`, `useQueryClient` from `@tanstack/react-query`
  - [ ] Import `deleteContext` from `@/lib/api/contexts`
  - [ ] Import `transformError` from `@/lib/errors`
  - [ ] Import `toast` from `sonner`
  - [ ] Import `useCurrentUser` from `@/hooks/use-current-user`
  - [ ] Implement `useDeleteContext()` hook:
    ```typescript
    export function useDeleteContext() {
      const queryClient = useQueryClient();
      const { userId } = useCurrentUser();

      return useMutation({
        mutationKey: ['contexts', 'delete'] as const, // Generic delete key (ID varies per call)
        mutationFn: (id: string) => deleteContext(id),

        // Optimistic update: Remove context from cache immediately
        onMutate: async (id) => {
          await queryClient.cancelQueries({ queryKey: contextKeys.list(userId) });

          const previousContexts = queryClient.getQueryData<Context[]>(
            contextKeys.list(userId)
          );

          // Optimistically remove context from list
          queryClient.setQueryData<Context[]>(
            contextKeys.list(userId),
            (old) => old?.filter((ctx) => ctx.id !== id)
          );

          return { previousContexts };
        },

        onError: (err, id, context) => {
          if (context?.previousContexts) {
            queryClient.setQueryData(contextKeys.list(userId), context.previousContexts);
          }
          const appError = transformError(err);
          toast.error(appError.userMessage); // e.g., "Failed to delete context. Please try again."
          console.error('Failed to delete context:', err); // Keep for debugging
        },

        onSuccess: (data, id) => {
          queryClient.invalidateQueries({ queryKey: contextKeys.lists() });
          queryClient.removeQueries({ queryKey: contextKeys.detail(id) });
          toast.success('Context deleted successfully');
        },
      });
    }
    ```
  - [ ] Add JSDoc documenting behavior and cache cleanup

- [ ] **Task 9: Set up MSW (Mock Service Worker) for API mocking** (AC: 6)
  - [ ] Create `my_flow_client/src/mocks/handlers.ts`
  - [ ] Import `http`, `HttpResponse` from `msw`
  - [ ] Create mock context data (3-4 sample contexts)
  - [ ] Define MSW handlers for context API endpoints:
    - `http.get('/api/v1/contexts', () => HttpResponse.json(mockContexts))`
    - `http.get('/api/v1/contexts/:id', ({ params }) => {...})`
    - `http.post('/api/v1/contexts', async ({ request }) => {...})`
    - `http.put('/api/v1/contexts/:id', async ({ request, params }) => {...})`
    - `http.delete('/api/v1/contexts/:id', ({ params }) => {...})`
  - [ ] Export `handlers` array
  - [ ] Create `my_flow_client/src/mocks/server.ts` for Node.js environment (tests)
  - [ ] Export `server` instance using `setupServer(...handlers)`

- [ ] **Task 10: Write integration tests for useContexts hook** (AC: 6)
  - [ ] Create `my_flow_client/src/hooks/__tests__/use-contexts.test.tsx`
  - [ ] Import `renderHook`, `waitFor` from `@testing-library/react`
  - [ ] Import `QueryClient`, `QueryClientProvider` from `@tanstack/react-query`
  - [ ] Import `server` from `@/mocks/server`
  - [ ] Set up MSW server before/after tests:
    ```typescript
    beforeAll(() => server.listen());
    afterEach(() => server.resetHandlers());
    afterAll(() => server.close());
    ```
  - [ ] Create test wrapper with QueryClientProvider:
    ```typescript
    const createWrapper = () => {
      const queryClient = new QueryClient({
        defaultOptions: {
          queries: { retry: false },
          mutations: { retry: false },
        },
      });
      return ({ children }: { children: React.ReactNode }) => (
        <QueryClientProvider client={queryClient}>
          {children}
        </QueryClientProvider>
      );
    };
    ```
  - [ ] Test: `useContexts() successfully fetches contexts`
    - Render hook with wrapper
    - Wait for loading to complete
    - Assert `result.current.data` contains expected contexts
    - Assert `result.current.isLoading` is false
  - [ ] Test: `useContexts() handles fetch error`
    - Override MSW handler to return 500 error
    - Render hook
    - Wait for error state
    - Assert `result.current.error` is defined

- [ ] **Task 11: Write integration tests for useContext hook** (AC: 6)
  - [ ] In `my_flow_client/src/hooks/__tests__/use-contexts.test.tsx`
  - [ ] Test: `useContext(id) fetches single context by ID`
    - Render hook with mock ID
    - Wait for loading to complete
    - Assert `result.current.data` matches expected context
    - Assert correct API endpoint was called
  - [ ] Test: `useContext(id) handles 404 not found`
    - Override MSW handler to return 404
    - Render hook with invalid ID
    - Wait for error state
    - Assert error is defined

- [ ] **Task 12: Write integration tests for mutation hooks** (AC: 6)
  - [ ] In `my_flow_client/src/hooks/__tests__/use-contexts.test.tsx`
  - [ ] Test: `useCreateContext() creates context with optimistic update`
    - Render both `useContexts` and `useCreateContext` hooks
    - Wait for contexts to load
    - Call `createContext.mutate(newContextData)`
    - Assert context appears in list immediately (optimistic)
    - Wait for mutation to settle
    - Assert context has real ID from server
  - [ ] Test: `useCreateContext() rolls back on error`
    - Override MSW handler to return 400 error
    - Render hooks
    - Call `createContext.mutate(invalidData)`
    - Assert optimistic context appears
    - Wait for error
    - Assert context is removed (rollback)
    - Assert error state is set
  - [ ] Test: `useUpdateContext() updates context with optimistic update`
    - Render hooks
    - Call `updateContext.mutate({ id, data: { name: 'Updated' } })`
    - Assert context name updates immediately
    - Wait for mutation to settle
    - Assert context remains updated
  - [ ] Test: `useUpdateContext() rolls back on error`
    - Override MSW to return 500 error
    - Call `updateContext.mutate()`
    - Assert optimistic update appears
    - Wait for error
    - Assert context reverts to original state
  - [ ] Test: `useDeleteContext() removes context with optimistic update`
    - Render hooks
    - Call `deleteContext.mutate(id)`
    - Assert context disappears immediately
    - Wait for mutation to settle
    - Assert context remains deleted
  - [ ] Test: `useDeleteContext() rolls back on error`
    - Override MSW to return 403 error
    - Call `deleteContext.mutate(id)`
    - Assert context disappears
    - Wait for error
    - Assert context is restored (rollback)

- [ ] **Task 13: Run tests and verify coverage** (AC: 6)
  - [ ] Run unit tests: `cd my_flow_client && bun test use-contexts`
  - [ ] Verify all tests pass (10+ tests expected)
  - [ ] Run coverage: `bun test use-contexts --coverage`
  - [ ] Verify coverage ‚â• 80% for `use-contexts.ts` and `contexts.ts`
  - [ ] Fix any failing tests or coverage gaps
  - [ ] Document coverage report in story

- [ ] **Task 14: Verify code quality and compliance** (AC: All)
  - [ ] Run linter: `cd my_flow_client && bun run lint`
  - [ ] Fix any ESLint errors or warnings
  - [ ] Run type checker: `bun run typecheck`
  - [ ] Fix any TypeScript errors
  - [ ] Verify import order follows coding standards (external ‚Üí internal ‚Üí relative)
  - [ ] Verify no hardcoded API URLs (should use `apiRequest` from `api-client.ts`)
  - [ ] Verify all functions have JSDoc comments
  - [ ] Verify all types are exported and properly documented

## Dev Notes

### üéØ CRITICAL: UX Component Styling Guide Compliance

**MANDATORY READING BEFORE IMPLEMENTATION:**
- `docs/ux-design-tokens/component-styling-guide.md` - Sally's complete UX specifications
- `docs/architecture/coding-standards.md` - Tailwind CSS variable usage (Section 8)

**This story does NOT implement UI components**, but the API client and hooks will be consumed by components that MUST follow Sally's styling guide. Developers should be aware that:
1. All future components using these hooks must use CSS design tokens
2. Context colors are NOT for priority badges (use semantic colors instead)
3. Component Styling Guide must be consulted before building any UI

[Source: docs/ux-design-tokens/component-styling-guide.md]

---

### Previous Story Insights (Story 2.6)

**Key Learnings from Flow List Implementation:**
- TypeScript enums for fixed value sets (FlowPriority) - Contexts may need ContextType enum
- Comprehensive test coverage (10+ tests) with proper MSW setup
- `'use client'` directive only needed for interactive components (not needed for hooks)
- Test hooks using `renderHook` from React Testing Library
- MSW handlers should mimic real API behavior (delays, error cases, edge cases)
- Query keys should be hierarchical for efficient cache invalidation

[Source: docs/stories/2.6.story.md]

---

### TanStack Query Architecture (from Frontend Architecture)

**State Management Strategy:**

My Flow uses a **two-layer state management** approach:
1. **Server State (TanStack Query)** - All data from API (contexts, flows, preferences)
2. **Local State (React Context)** - Minimal UI state (current context ID, theme)

**Query Key Convention:**

TanStack Query uses hierarchical query keys for efficient cache management:

```typescript
// Query keys structure
const contextKeys = {
  all: ['contexts'] as const,                          // ['contexts']
  lists: () => [...contextKeys.all, 'list'] as const,  // ['contexts', 'list']
  list: (userId: string) => [...contextKeys.lists(), userId] as const, // ['contexts', 'list', userId]
  details: () => [...contextKeys.all, 'detail'] as const, // ['contexts', 'detail']
  detail: (id: string) => [...contextKeys.details(), id] as const, // ['contexts', 'detail', id]
}
```

**Benefits:**
- Invalidate all context queries: `queryClient.invalidateQueries({ queryKey: contextKeys.all })`
- Invalidate only lists: `queryClient.invalidateQueries({ queryKey: contextKeys.lists() })`
- Invalidate specific detail: `queryClient.invalidateQueries({ queryKey: contextKeys.detail(id) })`

[Source: docs/architecture/frontend-architecture.md#state-management-architecture]

---

### Optimistic Update Pattern (from Frontend Architecture)

**Critical Implementation Guidance:**

Optimistic updates provide <500ms perceived latency for better UX. The pattern:

1. **onMutate**: Update cache immediately before API call
2. **onError**: Rollback cache to previous state if API fails
3. **onSettled/onSuccess**: Invalidate queries to sync with server

**Example from Frontend Architecture:**

```typescript
export function useToggleFlowCompletion() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (flowId: string) =>
      apiClient.post<Flow>(`/api/v1/flows/${flowId}/complete`, {}),

    // Optimistic update (instant UI feedback)
    onMutate: async (flowId) => {
      await queryClient.cancelQueries({ queryKey: ['flows'] });
      const previousFlows = queryClient.getQueryData<Flow[]>(['flows']);

      queryClient.setQueryData<Flow[]>(['flows'], (old) =>
        old?.map((flow) =>
          flow.id === flowId
            ? { ...flow, is_completed: !flow.is_completed }
            : flow
        )
      );

      return { previousFlows };
    },

    // Rollback on error
    onError: (err, flowId, context) => {
      queryClient.setQueryData(['flows'], context?.previousFlows);
      toast.error('Failed to update flow');
    },

    // Refetch to sync with server
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['flows'] });
    },
  });
}
```

**Key Points:**
- `cancelQueries` prevents race conditions
- Return previous state in `onMutate` for rollback
- Use `setQueryData` to update cache optimistically
- Use `invalidateQueries` to refetch from server after mutation

[Source: docs/architecture/frontend-architecture.md lines 261-299]

---

### Context Data Model (from Data Models)

**Context Interface:**

```typescript
interface Context {
  id: string;                 // MongoDB ObjectId
  user_id: string;           // Logto user identifier (from JWT sub claim)
  name: string;              // 1-50 chars (e.g., "Work", "Personal")
  color: string;             // Hex format: #3B82F6
  icon: string;              // Emoji: üíº, üè†, üåô, üéâ
  created_at: string;        // ISO 8601 datetime
  updated_at: string;        // ISO 8601 datetime
}

interface ContextCreate {
  name: string;              // Required, 1-50 chars
  color: string;             // Required, hex format
  icon: string;              // Required, emoji
}

interface ContextUpdate {
  name?: string;             // Optional, 1-50 chars
  color?: string;            // Optional, hex format
  icon?: string;             // Optional, emoji
}
```

**Relationships:**
- **One-to-Many with Flow:** A Context can have multiple Flows (cascade delete)
- **Many-to-One with User:** Multiple Contexts belong to a single user (via `user_id`)

**Validation Rules:**
- `name`: 1-50 characters, required
- `color`: Hex format `#RRGGBB`, required (e.g., `#3B82F6`)
- `icon`: Single emoji character, required

[Source: docs/architecture/data-models.md lines 0-48]

---

### API Specification for Contexts

**Context API Endpoints:**

| Method | Endpoint | Auth | Request Body | Response | Purpose |
|--------|----------|------|--------------|----------|---------|
| GET | `/api/v1/contexts` | Required | - | `Context[]` | List all user contexts |
| GET | `/api/v1/contexts/{id}` | Required | - | `Context` | Get single context |
| POST | `/api/v1/contexts` | Required | `ContextCreate` | `Context` | Create new context |
| PUT | `/api/v1/contexts/{id}` | Required | `ContextUpdate` | `Context` | Update context |
| DELETE | `/api/v1/contexts/{id}` | Required | - | `void` | Delete context (cascades to flows) |

**Authentication:**
- All endpoints require `Authorization: Bearer <logto_jwt_token>` header
- JWT token validated via Logto JWKS public key
- `user_id` extracted from JWT `sub` claim for authorization
- Returns 401 for missing/invalid tokens
- Returns 403 for unauthorized access (accessing another user's context)

**Error Responses:**
- 400 Bad Request: Invalid request body (validation errors)
- 401 Unauthorized: Missing or invalid JWT token
- 403 Forbidden: User does not own the context
- 404 Not Found: Context ID does not exist
- 500 Internal Server Error: Server-side error

[Source: docs/architecture/api-specification.md lines 0-146]

---

### Existing API Client (Server Action Pattern)

**Current Implementation:**

The project already has a server action-based API client in `my_flow_client/src/lib/api-client.ts`:

```typescript
// Server action to get Logto access token
export async function getApiAccessToken(): Promise<string | null> {
  'use server';
  const resource = process.env['NEXT_PUBLIC_LOGTO_RESOURCE'];
  const accessToken = await getAccessToken(logtoConfig, resource);
  return accessToken;
}

// Server action for API requests
export async function apiRequest<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  'use server';
  const token = await getApiAccessToken();

  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    ...(options.headers as Record<string, string>),
  };

  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }

  const response = await fetch(`${API_BASE_URL}${endpoint}`, {
    ...options,
    headers,
  });

  if (!response.ok) {
    throw new Error(`API request failed: ${response.statusText}`);
  }

  return response.json() as Promise<T>;
}
```

**Usage in Context API Client:**

```typescript
// my_flow_client/src/lib/api/contexts.ts
import { apiRequest } from '@/lib/api-client';
import type { Context, ContextCreate, ContextUpdate } from '@/types/context';

export async function fetchContexts(): Promise<Context[]> {
  return apiRequest<Context[]>('/api/v1/contexts');
}

export async function createContext(data: ContextCreate): Promise<Context> {
  return apiRequest<Context>('/api/v1/contexts', {
    method: 'POST',
    body: JSON.stringify(data),
  });
}
```

**Key Points:**
- `apiRequest` is a server action (`'use server'`)
- Automatically injects Logto JWT token from session
- Handles JSON serialization/deserialization
- Base URL from `NEXT_PUBLIC_API_URL` environment variable
- All API client functions should use this instead of raw `fetch()`

[Source: my_flow_client/src/lib/api-client.ts]

---

### TanStack Query Configuration Best Practices

**Query Configuration:**

```typescript
export function useContexts() {
  const userId = 'current-user-id'; // TODO: Get from Logto context

  return useQuery({
    queryKey: contextKeys.list(userId),
    queryFn: fetchContexts,
    staleTime: 5 * 60 * 1000,        // 5 minutes (contexts change infrequently)
    gcTime: 10 * 60 * 1000,          // 10 minutes (garbage collection)
    refetchOnWindowFocus: true,      // Auto-sync when user returns to tab
    enabled: !!userId,               // Only fetch if user is authenticated
  });
}
```

**Configuration Rationale:**

- **staleTime: 5 minutes** - Contexts don't change frequently, so longer stale time reduces API calls
- **gcTime: 10 minutes** - Prevents premature cache eviction when users switch between contexts frequently (React Query v5 renamed `cacheTime` to `gcTime`)
- **refetchOnWindowFocus: true** - Ensures user sees latest data when switching tabs
- **enabled guard** - Prevents queries when user is not authenticated
- **Query keys include userId** - Ensures cache is scoped per user

**Mutation Configuration:**

```typescript
export function useCreateContext() {
  return useMutation({
    mutationFn: createContext,
    onMutate: async (newContext) => { /* Optimistic update */ },
    onError: (err, newContext, context) => { /* Rollback */ },
    onSuccess: (data) => { /* Invalidate cache */ },
  });
}
```

**Mutation Callbacks:**
- **onMutate**: Runs before API call, perfect for optimistic updates
- **onError**: Runs on API failure, use for rollback and error notifications
- **onSuccess**: Runs on API success, use for cache invalidation and success notifications
- **onSettled**: Runs after success or error, use for cleanup

[Source: TanStack Query documentation + coding standards]

---

### Testing Strategy for React Query Hooks

**Test File Organization:**

```
my_flow_client/src/hooks/__tests__/
‚îî‚îÄ‚îÄ use-contexts.test.tsx
```

**Test Setup with MSW:**

```typescript
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { server } from '@/mocks/server';

// Set up MSW server
beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

// Create wrapper with QueryClientProvider
const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },      // Disable retries in tests
      mutations: { retry: false },    // Disable retries in tests
    },
  });
  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};
```

**Test Pattern for useQuery:**

```typescript
it('fetches contexts successfully', async () => {
  const { result } = renderHook(() => useContexts(), {
    wrapper: createWrapper(),
  });

  // Initial loading state
  expect(result.current.isLoading).toBe(true);

  // Wait for data to load
  await waitFor(() => expect(result.current.isSuccess).toBe(true));

  // Verify data
  expect(result.current.data).toHaveLength(3);
  expect(result.current.data?.[0].name).toBe('Work');
});
```

**Test Pattern for useMutation with Optimistic Update:**

```typescript
it('creates context with optimistic update', async () => {
  const wrapper = createWrapper();

  // Render both query and mutation hooks
  const { result: queryResult } = renderHook(() => useContexts(), { wrapper });
  const { result: mutationResult } = renderHook(() => useCreateContext(), { wrapper });

  // Wait for initial data
  await waitFor(() => expect(queryResult.current.isSuccess).toBe(true));
  const initialCount = queryResult.current.data?.length || 0;

  // Trigger mutation
  mutationResult.current.mutate({
    name: 'New Context',
    color: '#3B82F6',
    icon: 'üéâ',
  });

  // Verify optimistic update (context appears immediately)
  await waitFor(() => {
    expect(queryResult.current.data?.length).toBe(initialCount + 1);
  });

  // Wait for mutation to settle
  await waitFor(() => expect(mutationResult.current.isSuccess).toBe(true));

  // Verify context has real ID from server
  const newContext = queryResult.current.data?.find(c => c.name === 'New Context');
  expect(newContext?.id).not.toContain('temp-');
});
```

**Coverage Requirements:**
- 80% minimum coverage for hooks and API client files
- Test success cases (fetch, create, update, delete)
- Test error cases (API failures, validation errors)
- Test optimistic updates (immediate UI feedback)
- Test rollback on error (cache restored to previous state)

[Source: docs/architecture/testing-strategy.md, Story 2.6 learnings]

---

### Import Order Standards (from Coding Standards)

**Frontend TypeScript Import Order:**

```typescript
// 1. External dependencies
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

// 2. Internal absolute imports (@/ alias)
import { apiRequest } from '@/lib/api-client';
import type { Context, ContextCreate, ContextUpdate } from '@/types/context';

// 3. Relative imports
import { contextKeys } from './query-keys';

// 4. Styles (if any)
import './styles.css';
```

[Source: docs/architecture/coding-standards.md#import-order-standards]

---

### File Organization (from Source Tree)

**Frontend Structure for this Story:**

```
my_flow_client/src/
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ contexts.ts          # NEW: Context API client functions
‚îÇ   ‚îî‚îÄ‚îÄ api-client.ts            # EXISTING: Server action for authenticated requests
‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îú‚îÄ‚îÄ use-contexts.ts          # NEW: TanStack Query hooks
‚îÇ   ‚îî‚îÄ‚îÄ __tests__/
‚îÇ       ‚îî‚îÄ‚îÄ use-contexts.test.tsx # NEW: Integration tests
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îî‚îÄ‚îÄ context.ts               # NEW: Context TypeScript interfaces
‚îî‚îÄ‚îÄ mocks/
    ‚îú‚îÄ‚îÄ handlers.ts              # NEW: MSW API mock handlers
    ‚îî‚îÄ‚îÄ server.ts                # NEW: MSW server setup for tests
```

**Key Conventions:**
- **API clients** in `lib/api/` directory
- **Custom hooks** in `hooks/` directory
- **Types** in `types/` directory
- **Tests** co-located in `__tests__/` subdirectory
- **MSW mocks** in `mocks/` directory for testing

[Source: docs/architecture/source-tree.md lines 0-75]

---

### Tech Stack (TanStack Query Version)

**State Management (Server) - TanStack Query:**
- **Version:** 5.x
- **Purpose:** Server state caching, optimistic updates, automatic refetching
- **Features:** Request deduplication, cache invalidation, background refetching
- **Installation:** `bun add @tanstack/react-query@5.x`

**Testing - MSW (Mock Service Worker):**
- **Version:** latest
- **Purpose:** Mock API responses in tests without changing code
- **Features:** Intercepts network requests, simulates API behavior
- **Installation:** `bun add -d msw@latest`

[Source: docs/architecture/tech-stack.md]

---

### Error Handling (Coding Standards Section 5)

**Required Implementation (AC: 3):**

All mutation error handlers must follow the error transformation pattern from coding standards:

```typescript
import { transformError } from '@/lib/errors';
import { toast } from 'sonner'; // Using Sonner toast library

onError: (err, newContext, context) => {
  // 1. Rollback optimistic update
  if (context?.previousContexts) {
    queryClient.setQueryData(contextKeys.list(userId), context.previousContexts);
  }

  // 2. Transform error to user-friendly message
  const appError = transformError(err);

  // 3. Show toast notification with user message
  toast.error(appError.userMessage); // e.g., "Failed to create context. Please try again."

  // 4. Log full error for debugging
  console.error('Failed to create context:', err);
}
```

**Key Requirements:**
- Use `transformError()` to convert API errors to AppError with user-friendly messages
- Use `toast.error()` from Sonner for user notifications
- Keep `console.error()` for debugging purposes
- Follow consistent error handling across all mutations (create/update/delete)

[Source: docs/architecture/coding-standards.md Section 5]

---

### Race Condition Handling and Mutation Keys

**Required Implementation:**

This story implements **two-layer race condition prevention** for optimal UX:

**Layer 1: cancelQueries (Query Race Conditions)**

Cancels in-flight queries before optimistic updates to prevent stale data conflicts:

```typescript
onMutate: async (newContext) => {
  await queryClient.cancelQueries({ queryKey: contextKeys.list(userId) });
  // ... optimistic update
}
```

**Layer 2: mutationKey (Duplicate Submission Prevention) - MANDATORY**

Prevents duplicate mutations from double-clicks, accidental rapid submissions, or keyboard shortcuts:

```typescript
export function useCreateContext() {
  return useMutation({
    mutationKey: ['createContext'], // REQUIRED: Prevents duplicate submissions
    mutationFn: (data: ContextCreate) => createContext(data),
    onMutate: async (newContext) => {
      await queryClient.cancelQueries({ queryKey: contextKeys.list(userId) });
      // ... rest of implementation
    },
    // ... rest of callbacks
  });
}
```

**Why mutationKey is Mandatory:**

**Scenario without mutationKey:**
1. User rapidly clicks "Create Context" twice (double-click)
2. Both mutations execute independently
3. API creates two identical contexts
4. User sees duplicate contexts in UI
5. User must manually delete the duplicate

**Scenario with mutationKey:**
1. User rapidly clicks "Create Context" twice
2. TanStack Query deduplicates mutations with same key
3. Only one API call executes
4. Clean UX, no duplicates

**Implementation Requirements:**
- ‚úÖ All mutations (create/update/delete) MUST include `mutationKey`
- ‚úÖ Mutation keys should be descriptive: `['createContext']`, `['updateContext']`, `['deleteContext']`
- ‚úÖ This is a **critical UX requirement**, not an optional enhancement
- ‚ö†Ô∏è Alternative approach (button disabled state based on `isPending`) should be done at component level, but `mutationKey` provides defense-in-depth

[Source: TanStack Query best practices, UX standards]

---

### Hierarchical Mutation Keys Pattern

**Implementation Approach:**

Mutation keys follow a hierarchical pattern similar to query keys for consistency:

```typescript
const contextMutations = {
  create: ['contexts', 'create'] as const,
  update: (id: string) => ['contexts', 'update', id] as const,
  delete: (id: string) => ['contexts', 'delete', id] as const,
}
```

**Benefits:**

1. **Consistency** - Matches the hierarchical pattern used for query keys
2. **Granular Control** - Allows canceling specific mutations if needed (e.g., cancel update for context X)
3. **Type Safety** - `as const` provides better TypeScript inference
4. **Debugging** - Clear mutation names in React Query DevTools

**Usage Patterns:**

- **create**: Uses static key `['contexts', 'create']` (all creates share same key)
- **update**: Uses parameterized key `['contexts', 'update', id]` (each context has unique key)
- **delete**: Uses static key `['contexts', 'delete']` (ID varies per call, so generic key)

**Why delete doesn't use parameterized key:**

The delete hook doesn't know the ID until `mutate()` is called, so we use a generic key. This still prevents duplicate submissions while keeping the API simple.

[Source: TanStack Query best practices, pattern consistency]

---

### User ID Resolution with useCurrentUser Hook

**Current Implementation:**

This story uses a **placeholder hook pattern** to centralize user ID resolution and make Logto integration easier in future stories:

```typescript
// hooks/use-current-user.ts
export function useCurrentUser() {
  // TODO: Replace with actual Logto integration
  // This will use useUser() from '@logto/next' in future stories
  return {
    userId: 'current-user-id',
    isAuthenticated: true,
  };
}

// Usage in hooks
export function useContexts() {
  const { userId } = useCurrentUser();
  return useQuery({
    queryKey: contextKeys.list(userId),
    queryFn: fetchContexts,
    enabled: !!userId,
  });
}
```

**Benefits of Placeholder Hook Pattern:**

1. **Single Integration Point** - Future Logto integration only requires updating one file
2. **Explicit TODO** - Clear JSDoc makes it obvious what needs to be done
3. **Consistent API** - All hooks use same pattern (`useCurrentUser()`)
4. **Easy Find/Replace** - Search for `use-current-user.ts` to find integration point
5. **Type Safety** - Centralized return type for user info

**Future Integration (Story 2.8 or later):**

Replace the placeholder implementation with actual Logto integration:

```typescript
// hooks/use-current-user.ts
import { useUser } from '@logto/next';

export function useCurrentUser() {
  const { data: user, isLoading } = useUser();
  return {
    userId: user?.id ?? null,
    isAuthenticated: !!user,
    isLoading,
  };
}
```

**For This Story:**
- Create `useCurrentUser` hook in Task 3.5
- All hooks (Tasks 4-8) use `useCurrentUser()` instead of hardcoded values
- Ensure `enabled: !!userId` guard is in place for queries
- Focus on query/mutation logic, not auth integration

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-08 | 1.0 | Story created for Epic 2.7 | Bob (Scrum Master) |
| 2025-10-08 | 1.1 | Updated error handling to use transformError() and toast.error() per coding standards Section 5 | Bob (Scrum Master) |
| 2025-10-08 | 1.2 | Added gcTime configuration to prevent premature cache eviction in AC #3, Tasks 4-5, and Dev Notes | Bob (Scrum Master) |
| 2025-10-08 | 1.3 | Made mutationKey mandatory (not optional) to prevent duplicate submissions in AC #3, Tasks 6-8, and Dev Notes | Bob (Scrum Master) |
| 2025-10-08 | 1.4 | Added hierarchical mutation keys, useCurrentUser placeholder hook, and success toast notifications for UX consistency | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
(To be populated by Dev Agent)

### Debug Log References
(To be populated by Dev Agent)

### Completion Notes List
(To be populated by Dev Agent)

### File List
(To be populated by Dev Agent)

## QA Results
(To be populated by QA Agent)
