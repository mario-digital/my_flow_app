# Story 4.3: Incomplete Flow Warnings

## Status
Draft

## Story

**As a** backend developer,
**I want** warnings when users have incomplete flows in a context,
**so that** users are aware of pending tasks before switching away.

## Acceptance Criteria

1. **Warning logic in `my_flow_api/src/services/transition_service.py`:**
   - `check_incomplete_flows(context_id: str, user_id: str) -> IncompleteFlowWarning`
   - Counts incomplete flows
   - Identifies overdue flows (past due date)
   - Returns warning object with counts and flow details

2. **Warning model created in `my_flow_api/src/models/transition.py`:**
   - `IncompleteFlowWarning`: `context_id`, `incomplete_count`, `overdue_count`, `overdue_flows` (List[FlowResponse])

3. **Integration with context switch endpoint:**
   - When user switches context, backend returns warning if incomplete flows exist
   - Frontend displays confirmation dialog: "You have 3 incomplete flows in Work. Switch anyway?"

4. **Unit tests created in `my_flow_api/tests/unit/services/test_transition_service.py`:**
   - Tests warning generation with various flow states
   - Tests overdue detection
   - At least 80% coverage

## Tasks / Subtasks

- [ ] **Task 0: Review existing transition service implementation** (AC: 1)
  - [ ] Open `my_flow_api/src/services/transition_service.py` (from Story 4.2)
  - [ ] Review `TransitionService` class structure
  - [ ] Verify `get_transition_suggestions()` method implementation
  - [ ] Review existing urgency detection logic
  - [ ] Understand flow status computation patterns
  - [ ] Note existing helper methods for reuse

- [ ] **Task 1: Add IncompleteFlowWarning model to transition.py** (AC: 2)
  - [ ] Open `my_flow_api/src/models/transition.py`
  - [ ] Add new Pydantic model:
    ```python
    from pydantic import BaseModel, Field
    from typing import List
    from src.models.flow import FlowResponse
    
    class IncompleteFlowWarning(BaseModel):
        """
        Warning about incomplete flows in a context.
        
        Provides counts and details of incomplete flows,
        including overdue flows that require immediate attention.
        """
        context_id: str = Field(description="Context ID being checked")
        incomplete_count: int = Field(
            description="Total number of incomplete flows in context",
            ge=0
        )
        overdue_count: int = Field(
            description="Number of flows past their due date",
            ge=0
        )
        overdue_flows: List[FlowResponse] = Field(
            default_factory=list,
            description="List of overdue flows for display"
        )
        
        model_config = {
            "json_schema_extra": {
                "example": {
                    "context_id": "ctx-work-123",
                    "incomplete_count": 5,
                    "overdue_count": 2,
                    "overdue_flows": [
                        {
                            "id": "flow-overdue-1",
                            "title": "Submit expense report",
                            "priority": "high",
                            "due_date": "2025-01-10T17:00:00Z",
                            "is_completed": False
                        }
                    ]
                }
            }
        }
    ```
  - [ ] Import `FlowResponse` from `src.models.flow`
  - [ ] Add model config with example for OpenAPI docs
  - [ ] Ensure proper type hints for all fields

- [ ] **Task 2: Implement check_incomplete_flows() method** (AC: 1)
  - [ ] Open `my_flow_api/src/services/transition_service.py`
  - [ ] Add import for new model:
    ```python
    from src.models.transition import TransitionSuggestions, IncompleteFlowWarning
    ```
  - [ ] Add new method to `TransitionService` class:
    ```python
    async def check_incomplete_flows(
        self,
        context_id: str,
        user_id: str
    ) -> IncompleteFlowWarning:
        """
        Check for incomplete flows in a context and generate warnings.
        
        Args:
            context_id: Context to check for incomplete flows
            user_id: User making the request
            
        Returns:
            IncompleteFlowWarning with counts and overdue flow details
        """
        # 1. Fetch all flows for the context
        flows = await self.flow_repository.get_flows_by_context(
            context_id=context_id,
            user_id=user_id
        )
        
        # 2. Filter for incomplete flows
        incomplete_flows = [f for f in flows if not f.is_completed]
        
        # 3. Identify overdue flows
        overdue_flows = self._identify_overdue_flows(incomplete_flows)
        
        # 4. Build warning response
        return IncompleteFlowWarning(
            context_id=context_id,
            incomplete_count=len(incomplete_flows),
            overdue_count=len(overdue_flows),
            overdue_flows=overdue_flows
        )
    ```
  - [ ] Use existing `_identify_urgent_flows()` helper as reference
  - [ ] Ensure async/await for repository calls

- [ ] **Task 3: Implement overdue detection helper** (AC: 1)
  - [ ] Add private helper method to `TransitionService`:
    ```python
    def _identify_overdue_flows(
        self,
        flows: List[FlowResponse]
    ) -> List[FlowResponse]:
        """
        Identify flows that are past their due date.
        
        Args:
            flows: List of flows to check
            
        Returns:
            List of overdue flows sorted by due date (oldest first)
        """
        from datetime import datetime, timezone
        
        now = datetime.now(timezone.utc)
        overdue = []
        
        for flow in flows:
            # Skip flows without due dates
            if not flow.due_date:
                continue
            
            # Parse due_date (ISO 8601 string to datetime)
            due_dt = datetime.fromisoformat(
                flow.due_date.replace('Z', '+00:00')
            )
            
            # Check if overdue
            if due_dt < now:
                overdue.append(flow)
        
        # Sort by due date (oldest overdue first)
        overdue.sort(key=lambda f: f.due_date if f.due_date else "9999-12-31T23:59:59Z")
        
        return overdue
    ```
  - [ ] Handle timezone-aware datetime comparisons
  - [ ] Handle flows without due_date (skip them)
  - [ ] Sort overdue flows by due date (oldest first)

- [ ] **Task 4: Add API endpoint for incomplete flow warnings** (AC: 3)
  - [ ] Open `my_flow_api/src/routers/transitions.py`
  - [ ] Import the new model:
    ```python
    from src.models.transition import TransitionSuggestions, IncompleteFlowWarning
    ```
  - [ ] Add new endpoint:
    ```python
    @router.get("/warnings/{context_id}", response_model=IncompleteFlowWarning)
    async def get_incomplete_flow_warnings(
        context_id: Annotated[str, Path(description="Context ID to check")],
        user_id: Annotated[str, Depends(get_current_user_id)],
        service: Annotated[TransitionService, Depends(get_transition_service)]
    ) -> IncompleteFlowWarning:
        """
        Get warnings about incomplete flows in a context.
        
        Used when user attempts to switch away from a context
        to notify them of pending tasks.
        
        **Path Parameters:**
        - `context_id`: Context ID to check for incomplete flows
        
        **Returns:**
        - Count of incomplete flows
        - Count of overdue flows
        - List of overdue flows for display
        
        **Example:**
        ```
        GET /api/v1/transitions/warnings/ctx-work-123
        ```
        """
        try:
            warning = await service.check_incomplete_flows(
                context_id=context_id,
                user_id=user_id
            )
            return warning
        except Exception as e:
            raise HTTPException(
                status_code=500,
                detail=f"Failed to check incomplete flows: {str(e)}"
            )
    ```
  - [ ] Add comprehensive docstring with example
  - [ ] Add error handling
  - [ ] Use Path parameter for context_id

- [ ] **Task 5: Update existing transitions router imports** (AC: 3)
  - [ ] Verify `my_flow_api/src/main.py` already includes transitions router
  - [ ] If not registered, add:
    ```python
    from src.routers import contexts, flows, preferences, transitions
    app.include_router(transitions.router)
    ```
  - [ ] Verify router appears in OpenAPI docs at `/docs`

- [ ] **Task 6: Write unit tests for check_incomplete_flows()** (AC: 4)
  - [ ] Open `my_flow_api/tests/unit/services/test_transition_service.py`
  - [ ] Add import for new model:
    ```python
    from src.models.transition import TransitionSuggestions, IncompleteFlowWarning
    ```
  - [ ] Test: `test_check_incomplete_flows_no_flows()`:
    ```python
    @pytest.mark.asyncio
    async def test_check_incomplete_flows_no_flows(
        transition_service,
        mock_flow_repo
    ):
        """Test warnings when context has no flows."""
        # Mock: No flows in context
        mock_flow_repo.get_flows_by_context.return_value = []
        
        result = await transition_service.check_incomplete_flows(
            context_id="ctx-work",
            user_id="user123"
        )
        
        assert result.context_id == "ctx-work"
        assert result.incomplete_count == 0
        assert result.overdue_count == 0
        assert len(result.overdue_flows) == 0
    ```
  - [ ] Test: `test_check_incomplete_flows_all_completed()`:
    ```python
    @pytest.mark.asyncio
    async def test_check_incomplete_flows_all_completed(
        transition_service,
        mock_flow_repo
    ):
        """Test warnings when all flows are completed."""
        # Mock: All flows completed
        mock_flow_repo.get_flows_by_context.return_value = [
            FlowResponse(
                id="f1", title="Task 1", priority="high",
                is_completed=True, context_id="ctx-work",
                user_id="user123", created_at=datetime.now(timezone.utc),
                updated_at=datetime.now(timezone.utc)
            )
        ]
        
        result = await transition_service.check_incomplete_flows(
            context_id="ctx-work",
            user_id="user123"
        )
        
        assert result.incomplete_count == 0
        assert result.overdue_count == 0
    ```
  - [ ] Test: `test_check_incomplete_flows_with_incomplete()`:
    ```python
    @pytest.mark.asyncio
    async def test_check_incomplete_flows_with_incomplete(
        transition_service,
        mock_flow_repo
    ):
        """Test warnings with incomplete flows."""
        # Mock: 3 incomplete flows, no overdue
        mock_flow_repo.get_flows_by_context.return_value = [
            FlowResponse(
                id="f1", title="Task 1", priority="high",
                is_completed=False, due_date=None,
                context_id="ctx-work", user_id="user123",
                created_at=datetime.now(timezone.utc),
                updated_at=datetime.now(timezone.utc)
            ),
            FlowResponse(
                id="f2", title="Task 2", priority="medium",
                is_completed=False, due_date=None,
                context_id="ctx-work", user_id="user123",
                created_at=datetime.now(timezone.utc),
                updated_at=datetime.now(timezone.utc)
            ),
            FlowResponse(
                id="f3", title="Task 3", priority="low",
                is_completed=False, due_date=None,
                context_id="ctx-work", user_id="user123",
                created_at=datetime.now(timezone.utc),
                updated_at=datetime.now(timezone.utc)
            )
        ]
        
        result = await transition_service.check_incomplete_flows(
            context_id="ctx-work",
            user_id="user123"
        )
        
        assert result.context_id == "ctx-work"
        assert result.incomplete_count == 3
        assert result.overdue_count == 0
        assert len(result.overdue_flows) == 0
    ```
  - [ ] Test: `test_check_incomplete_flows_with_overdue()`:
    ```python
    @pytest.mark.asyncio
    async def test_check_incomplete_flows_with_overdue(
        transition_service,
        mock_flow_repo
    ):
        """Test warnings with overdue flows."""
        # Mock: 2 overdue flows
        overdue_date = (datetime.now(timezone.utc) - timedelta(days=2)).isoformat()
        
        mock_flow_repo.get_flows_by_context.return_value = [
            FlowResponse(
                id="f1", title="Overdue Task 1", priority="high",
                is_completed=False, due_date=overdue_date,
                context_id="ctx-work", user_id="user123",
                created_at=datetime.now(timezone.utc),
                updated_at=datetime.now(timezone.utc)
            ),
            FlowResponse(
                id="f2", title="Overdue Task 2", priority="medium",
                is_completed=False, due_date=overdue_date,
                context_id="ctx-work", user_id="user123",
                created_at=datetime.now(timezone.utc),
                updated_at=datetime.now(timezone.utc)
            )
        ]
        
        result = await transition_service.check_incomplete_flows(
            context_id="ctx-work",
            user_id="user123"
        )
        
        assert result.incomplete_count == 2
        assert result.overdue_count == 2
        assert len(result.overdue_flows) == 2
        assert result.overdue_flows[0].id == "f1"
    ```
  - [ ] Test: `test_check_incomplete_flows_mixed_states()`:
    ```python
    @pytest.mark.asyncio
    async def test_check_incomplete_flows_mixed_states(
        transition_service,
        mock_flow_repo
    ):
        """Test warnings with mix of incomplete, completed, and overdue."""
        overdue_date = (datetime.now(timezone.utc) - timedelta(days=1)).isoformat()
        future_date = (datetime.now(timezone.utc) + timedelta(days=7)).isoformat()
        
        mock_flow_repo.get_flows_by_context.return_value = [
            # Completed (should be ignored)
            FlowResponse(
                id="f1", title="Completed Task", priority="high",
                is_completed=True, due_date=None,
                context_id="ctx-work", user_id="user123",
                created_at=datetime.now(timezone.utc),
                updated_at=datetime.now(timezone.utc)
            ),
            # Overdue (should count as both incomplete and overdue)
            FlowResponse(
                id="f2", title="Overdue Task", priority="high",
                is_completed=False, due_date=overdue_date,
                context_id="ctx-work", user_id="user123",
                created_at=datetime.now(timezone.utc),
                updated_at=datetime.now(timezone.utc)
            ),
            # Incomplete but not overdue
            FlowResponse(
                id="f3", title="Future Task", priority="medium",
                is_completed=False, due_date=future_date,
                context_id="ctx-work", user_id="user123",
                created_at=datetime.now(timezone.utc),
                updated_at=datetime.now(timezone.utc)
            ),
            # Incomplete with no due date
            FlowResponse(
                id="f4", title="No Due Date Task", priority="low",
                is_completed=False, due_date=None,
                context_id="ctx-work", user_id="user123",
                created_at=datetime.now(timezone.utc),
                updated_at=datetime.now(timezone.utc)
            )
        ]
        
        result = await transition_service.check_incomplete_flows(
            context_id="ctx-work",
            user_id="user123"
        )
        
        assert result.incomplete_count == 3  # f2, f3, f4 (not f1)
        assert result.overdue_count == 1     # f2 only
        assert len(result.overdue_flows) == 1
        assert result.overdue_flows[0].id == "f2"
    ```
  - [ ] Run tests: `cd my_flow_api && pytest tests/unit/services/test_transition_service.py::test_check_incomplete_flows -v`

- [ ] **Task 7: Write integration tests for warnings endpoint** (AC: 3, 4)
  - [ ] Create `my_flow_api/tests/integration/test_transitions_warnings.py`
  - [ ] Import test dependencies:
    ```python
    import pytest
    from httpx import AsyncClient
    from datetime import datetime, timedelta, timezone
    from src.main import app
    from src.database import get_database
    ```
  - [ ] Test: `test_get_warnings_endpoint()`:
    ```python
    @pytest.mark.asyncio
    async def test_get_warnings_endpoint(
        async_client: AsyncClient,
        test_db,
        mock_auth_user
    ):
        """Test GET /api/v1/transitions/warnings/{context_id} endpoint."""
        # Setup: Create context and flows in test DB
        # ... (create test data)
        
        response = await async_client.get(
            "/api/v1/transitions/warnings/ctx-work"
        )
        
        assert response.status_code == 200
        data = response.json()
        assert "context_id" in data
        assert "incomplete_count" in data
        assert "overdue_count" in data
        assert "overdue_flows" in data
        assert isinstance(data["overdue_flows"], list)
    ```
  - [ ] Test: `test_warnings_unauthorized_access()`:
    ```python
    @pytest.mark.asyncio
    async def test_warnings_unauthorized_access(async_client: AsyncClient):
        """Test endpoint requires authentication."""
        response = await async_client.get(
            "/api/v1/transitions/warnings/ctx-work"
        )
        
        assert response.status_code == 401
    ```
  - [ ] Test: `test_warnings_with_overdue_flows()`:
    ```python
    @pytest.mark.asyncio
    async def test_warnings_with_overdue_flows(
        async_client: AsyncClient,
        test_db,
        mock_auth_user
    ):
        """Test warnings include overdue flow details."""
        # Setup: Create overdue flow in test DB
        # ... (create test data)
        
        response = await async_client.get(
            "/api/v1/transitions/warnings/ctx-work"
        )
        
        assert response.status_code == 200
        data = response.json()
        assert data["overdue_count"] > 0
        assert len(data["overdue_flows"]) == data["overdue_count"]
        
        # Verify overdue flow structure
        overdue_flow = data["overdue_flows"][0]
        assert "id" in overdue_flow
        assert "title" in overdue_flow
        assert "due_date" in overdue_flow
    ```
  - [ ] Run tests: `cd my_flow_api && pytest tests/integration/test_transitions_warnings.py -v`

- [ ] **Task 8: Run all tests and verify coverage** (AC: 4)
  - [ ] Run full test suite:
    ```bash
    cd my_flow_api
    pytest tests/unit/services/test_transition_service.py -v
    pytest tests/integration/test_transitions_warnings.py -v
    ```
  - [ ] Run coverage report:
    ```bash
    pytest tests/unit/services/test_transition_service.py \
        --cov=src/services/transition_service \
        --cov-report=term-missing
    ```
  - [ ] Verify coverage ≥ 80%
  - [ ] Fix any failing tests
  - [ ] Document any edge cases discovered

- [ ] **Task 9: Manual testing with API client** (AC: 3)
  - [ ] Start backend server: `cd my_flow_api && python -m src.main`
  - [ ] Open API docs: `http://localhost:8000/docs`
  - [ ] Authenticate with test user (JWT token)
  - [ ] Create test context via `/api/v1/contexts`
  - [ ] Create test flows with various states:
    - Flow 1: Incomplete, no due date
    - Flow 2: Incomplete, overdue (2 days ago)
    - Flow 3: Incomplete, due in future
    - Flow 4: Completed (should be ignored)
  - [ ] Call warnings endpoint:
    ```bash
    curl -X GET "http://localhost:8000/api/v1/transitions/warnings/ctx-work" \
      -H "Authorization: Bearer <token>"
    ```
  - [ ] Verify response includes:
    - Correct incomplete_count (3 in this example)
    - Correct overdue_count (1 in this example)
    - Overdue flows array with Flow 2 details
  - [ ] Test edge cases:
    - No incomplete flows
    - All flows overdue
    - Mix of states
  - [ ] Document manual test results

- [ ] **Task 10: Code quality and compliance** (AC: All)
  - [ ] Run linter: `cd my_flow_api && ruff check src/`
  - [ ] Fix any linting errors
  - [ ] Run type checker: `mypy src/`
  - [ ] Fix any type errors
  - [ ] Ensure all functions have docstrings
  - [ ] Verify error handling is comprehensive
  - [ ] Check for proper async/await usage
  - [ ] Ensure user isolation (user_id filtering)
  - [ ] Verify timezone handling in datetime comparisons

## Dev Notes

### Previous Story Integration

**From Story 4.2 (Transition Suggestions Service):**
- `TransitionService` exists in `my_flow_api/src/services/transition_service.py`
- `TransitionSuggestions` model exists in `my_flow_api/src/models/transition.py`
- Transitions router exists in `my_flow_api/src/routers/transitions.py`
- Helper method `_identify_urgent_flows()` for urgency detection
- Pattern for analyzing incomplete flows established

**Integration Point:**
This story EXTENDS the TransitionService from Story 4.2 by adding the `check_incomplete_flows()` method for warnings specifically about the SOURCE context (before switching away).

[Source: docs/stories/4.2.story.md]

---

### Backend Architecture Patterns

**Service Layer Pattern:**
- Services contain business logic
- Services depend on repositories (data access)
- Services are injected via FastAPI Depends()
- Services are async for MongoDB operations

**Repository Layer Pattern:**
- Repositories handle MongoDB CRUD operations
- Repositories enforce user isolation (user_id filtering)
- Repositories use Motor (async MongoDB driver)

**Router Layer Pattern:**
- Routers define API endpoints
- Routers use dependency injection for services
- Routers validate request/response with Pydantic models
- Routers handle authentication via middleware

[Source: docs/architecture/backend-architecture.md]

---

### Incomplete Flow Warning Logic

**Warning Generation:**
1. Fetch all flows for context
2. Filter for incomplete flows (`is_completed == False`)
3. Identify overdue flows (due_date < now)
4. Return counts and overdue flow details

**Overdue Detection:**
- Flow is overdue if: `due_date < current_time_utc`
- Flows without due_date are NOT considered overdue
- Compare datetimes in UTC timezone
- Sort overdue flows by due date (oldest first)

**Edge Cases:**
- No flows → incomplete_count: 0, overdue_count: 0
- All flows completed → incomplete_count: 0, overdue_count: 0
- Incomplete but none overdue → incomplete_count > 0, overdue_count: 0
- Mix of states → Count only incomplete, identify overdue within incomplete

[Source: Epic 4.3 AC]

---

### API Endpoint Design

**Endpoint:** `GET /api/v1/transitions/warnings/{context_id}`

**Path Parameters:**
- `context_id` - Context ID to check for incomplete flows (required)

**Authentication:**
- Requires JWT token in `Authorization: Bearer <token>` header
- User ID extracted from JWT token
- User isolation enforced (only user's flows analyzed)

**Response Model:**
```json
{
  "context_id": "ctx-work-123",
  "incomplete_count": 5,
  "overdue_count": 2,
  "overdue_flows": [
    {
      "id": "flow-1",
      "title": "Submit expense report",
      "priority": "high",
      "due_date": "2025-01-10T17:00:00Z",
      "is_completed": false
    }
  ]
}
```

**Error Handling:**
- 401: Unauthorized (missing/invalid JWT)
- 500: Internal Server Error (database/service error)

[Source: Epic 4.3 AC 3]

---

### Testing Strategy

**Unit Tests (80% coverage target):**

Test scenarios:
1. No flows in context
2. All flows completed
3. Incomplete flows without due dates
4. Incomplete flows with overdue flows
5. Mix of completed, incomplete, and overdue
6. Edge case: flows without due_date (should not be overdue)
7. Timezone handling verification

**Integration Tests:**

Test scenarios:
1. End-to-end API endpoint with authentication
2. Unauthorized access
3. Warnings with overdue flow details in response

**Manual Testing:**
- Test with real MongoDB data
- Verify warnings accuracy
- Test various time zones
- Validate user isolation
- Test edge cases (no flows, all overdue, etc.)

[Source: docs/architecture/13-testing-strategy.md]

---

### File Structure & Dependencies

**Existing Files to Modify:**
- `my_flow_api/src/models/transition.py` - Add IncompleteFlowWarning model
- `my_flow_api/src/services/transition_service.py` - Add check_incomplete_flows() method
- `my_flow_api/src/routers/transitions.py` - Add warnings endpoint

**New Files to Create:**
- `my_flow_api/tests/integration/test_transitions_warnings.py` - Integration tests

**Files to Update Tests:**
- `my_flow_api/tests/unit/services/test_transition_service.py` - Add new unit tests

**Dependencies:**
- `FlowRepository` (existing) - Fetch flows by context
- `FlowResponse` model (existing) - Flow response schema
- Authentication middleware (existing) - JWT validation
- `TransitionService` (existing from 4.2) - Base service class

[Source: docs/architecture/backend-architecture.md - Service Organization]

---

### Python Code Standards

**Async/Await:**
- All repository methods are async (MongoDB operations)
- All service methods are async (call repositories)
- Use `await` for all async calls

**Type Hints:**
- All function parameters have type hints
- All return types specified
- Use `List[T]`, `Optional[T]` from `typing`

**Error Handling:**
- Use try/except for database operations
- Raise HTTPException with appropriate status codes
- Log errors for debugging

**Docstrings:**
- All classes have docstrings
- All public methods have docstrings
- Use Google-style docstrings with Args/Returns sections

[Source: docs/architecture/coding-standards.md]

---

### DateTime Handling

**Critical Rules:**
1. **Always use timezone-aware datetimes** (`timezone.utc`)
2. **Parse ISO 8601 strings** with `.replace('Z', '+00:00')`
3. **Compare datetimes** in UTC timezone
4. **Store datetimes** as ISO 8601 strings in MongoDB

**Example:**
```python
from datetime import datetime, timezone

# Current time (UTC)
now = datetime.now(timezone.utc)

# Parse ISO 8601 string
due_dt = datetime.fromisoformat(
    flow.due_date.replace('Z', '+00:00')
)

# Compare
is_overdue = due_dt < now
```

[Source: docs/architecture/backend-architecture.md]

---

### Integration with Story 4.2

**Complementary Functionality:**

**Story 4.2 (Transition Suggestions):**
- Analyzes BOTH source and target contexts
- Provides suggestions for target context
- Warns about source context incomplete flows

**Story 4.3 (Incomplete Flow Warnings):**
- Focuses ONLY on source context
- Provides detailed warning with overdue flow list
- Used independently before context switch

**Shared Logic:**
- Both use `FlowRepository.get_flows_by_context()`
- Both identify incomplete flows
- Both detect overdue flows

**Frontend Integration (Story 4.4 will use both):**
- Call warnings endpoint when user initiates context switch
- Display dialog if warnings exist
- Allow user to proceed or cancel switch

[Source: Epic 4 AC 3, Story 4.2]

---

## Testing

### Test File Organization

**Unit Tests:**
```
my_flow_api/tests/unit/services/
└── test_transition_service.py  (EXISTING - add tests to this file)
```

**Integration Tests:**
```
my_flow_api/tests/integration/
└── test_transitions_warnings.py  (NEW - create in this story)
```

[Source: docs/architecture/13-testing-strategy.md]

---

### Running Tests

```bash
# Run unit tests
cd my_flow_api
pytest tests/unit/services/test_transition_service.py -v

# Run with coverage
pytest tests/unit/services/test_transition_service.py \
    --cov=src/services/transition_service \
    --cov-report=term-missing

# Run integration tests
pytest tests/integration/test_transitions_warnings.py -v

# Run all tests
pytest tests/ -v
```

[Source: docs/architecture/13-testing-strategy.md]

---

### Manual Testing Workflow

**Setup:**
1. Start backend: `cd my_flow_api && python -m src.main`
2. Open API docs: `http://localhost:8000/docs`
3. Authenticate with test JWT token

**Test Scenario 1: Incomplete Flows with Overdue**
1. Create "Work" context
2. Add 3 incomplete flows:
   - Flow 1: No due date
   - Flow 2: Overdue (2 days ago)
   - Flow 3: Due in 7 days
3. Call `/api/v1/transitions/warnings/ctx-work`
4. ✓ Verify incomplete_count = 3
5. ✓ Verify overdue_count = 1
6. ✓ Verify overdue_flows array contains Flow 2

**Test Scenario 2: All Flows Completed**
1. Complete all flows in "Work" context
2. Call `/api/v1/transitions/warnings/ctx-work`
3. ✓ Verify incomplete_count = 0
4. ✓ Verify overdue_count = 0
5. ✓ Verify overdue_flows array is empty

**Test Scenario 3: No Flows**
1. Create empty context
2. Call `/api/v1/transitions/warnings/ctx-new`
3. ✓ Verify incomplete_count = 0
4. ✓ Verify overdue_count = 0
5. ✓ Verify overdue_flows array is empty

**Test Scenario 4: Edge Cases**
1. Test with non-existent context ID
2. Test with invalid JWT token
3. Verify appropriate error responses

[Source: Epic 4.3 AC 3]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-12 | 1.0 | Story created for Epic 4.3 - Incomplete Flow Warnings | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
(To be populated by Dev Agent)

### Debug Log References
(To be populated by Dev Agent)

### Completion Notes List
(To be populated by Dev Agent)

### File List
(To be populated by Dev Agent)

## QA Results

### Review Date
(To be populated by QA Agent)

### Reviewed By
(To be populated by QA Agent)

### Executive Summary
(To be populated by QA Agent)

