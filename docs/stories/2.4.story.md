# Story 2.4: Context & Flow REST API Endpoints (BE)

## Status
draft

## Story

**As a** backend developer,
**I want** FastAPI REST endpoints for context and flow management,
**so that** the frontend can perform all CRUD operations via HTTP.

## Acceptance Criteria

1. **Context API routes created in `my_flow_api/src/routers/contexts.py`:**
   - `GET /api/v1/contexts` → List user's contexts (requires auth)
   - `POST /api/v1/contexts` → Create context (requires auth, validates body)
   - `GET /api/v1/contexts/{id}` → Get single context (requires auth + ownership)
   - `PUT /api/v1/contexts/{id}` → Update context (requires auth + ownership)
   - `DELETE /api/v1/contexts/{id}` → Delete context (requires auth + ownership, cascades to flows)
   - All routes use dependency injection for `ContextRepository`

2. **Flow API routes created in `my_flow_api/src/routers/flows.py`:**
   - `GET /api/v1/contexts/{context_id}/flows` → List flows for context (requires auth + ownership)
   - `POST /api/v1/flows` → Create flow (requires auth, validates context ownership)
   - `GET /api/v1/flows/{id}` → Get single flow (requires auth)
   - `PUT /api/v1/flows/{id}` → Update flow (requires auth)
   - `DELETE /api/v1/flows/{id}` → Delete flow (requires auth)
   - `PATCH /api/v1/flows/{id}/complete` → Mark complete (requires auth)
   - All routes use dependency injection for `FlowRepository`

3. **Authentication middleware enforced:**
   - All routes require valid Logto JWT token
   - `user_id` extracted from token and passed to repository methods
   - Returns 401 for missing/invalid tokens
   - Returns 403 for unauthorized access (e.g., accessing another user's context)

4. **API response models use Pydantic:**
   - All endpoints return `ContextResponse` or `FlowResponse` (or lists)
   - Error responses use FastAPI HTTPException with proper status codes
   - OpenAPI docs auto-generated with full schema documentation

5. **Integration tests created in `my_flow_api/tests/integration/routers/test_contexts.py` and `test_flows.py`:**
   - Uses `TestClient` with mock authentication
   - Tests all endpoints (success cases + error cases)
   - Tests authorization (401, 403 responses)
   - Tests cascade delete (deleting context deletes flows)
   - At least 80% coverage for API routes

6. **Manual testing verified with 1Password secrets:**
   - Can run `op run -- uvicorn main:app --reload` and test all endpoints locally
   - Postman/Thunder Client collection documented in `my_flow_api/docs/api-testing.md`

## Tasks / Subtasks

- [ ] **Task 1: Create auth middleware dependency** (AC: 3)
  - [ ] Create `my_flow_api/src/middleware/auth.py`
  - [ ] Implement async `get_current_user()` dependency that validates Logto JWT
  - [ ] Extract `user_id` from token `sub` claim
  - [ ] Return 401 HTTPException for invalid/expired tokens
  - [ ] Use `python-jose` library for JWT decoding
  - [ ] Fetch Logto JWKS (public keys) from `{LOGTO_ENDPOINT}/oidc/jwks`
  - [ ] **SECURITY: Implement async TTL-based JWKS caching (1-hour TTL)**
    - Make `get_logto_jwks()` async function
    - Use `httpx.AsyncClient()` for async HTTP requests
    - Use module-level dict cache with `expires_at` timestamp
    - Refetch JWKS after TTL expires (allows JWKS rotation)
    - Add 5-second timeout to JWKS fetch
    - Fallback to stale cache if fetch fails (prevents auth outage)
    - Return 503 error if no cache available and fetch fails
    - Log warnings when using stale cache
  - [ ] In `get_current_user()`, await the async `get_logto_jwks()` call
  - [ ] Verify token signature, audience (`LOGTO_APP_ID`), issuer
  - [ ] **DRY: Add authorization helper functions** (optional but recommended)
    - Create `verify_context_ownership(context_id, user_id, context_repo)` helper
    - Create `verify_flow_ownership(flow_id, user_id, flow_repo)` helper
    - Reduces repetitive ownership checks across route handlers
    - Returns entity if owned, raises 404/403 HTTPException if not
    - Can be added to `src/middleware/auth.py` or `src/utils/auth_helpers.py`
  - [ ] Add unit tests for `get_current_user()` with mocked JWT tokens
  - [ ] Add unit tests for JWKS caching (TTL expiry, stale cache fallback, fetch failures)
  - [ ] Add unit tests for ownership helpers (if implemented)

- [ ] **Task 2: Create Context API router** (AC: 1, 3, 4)
  - [ ] Create `my_flow_api/src/routers/contexts.py`
  - [ ] Create `get_context_repository()` dependency for DI
  - [ ] Implement `GET /api/v1/contexts` - List contexts for user with pagination
    - Use `Depends(get_current_user)` to get `user_id`
    - Add pagination query params: `limit: int = Query(default=50, le=100)`, `offset: int = Query(default=0, ge=0)`
    - Call `context_repo.get_all_by_user(user_id, limit=limit, offset=offset)`
    - Return `list[ContextInDB]` (response_model)
    - Note: Pagination improves performance even with MAX_CONTEXTS_PER_USER=100 limit
  - [ ] Implement `POST /api/v1/contexts` - Create context
    - Accept `ContextCreate` request body
    - Use `Depends(get_current_user)` to get `user_id`
    - Call `context_repo.create(user_id, context_data)`
    - Return `ContextInDB` with `status_code=201`
  - [ ] Implement `GET /api/v1/contexts/{context_id}` - Get single context
    - Use `Depends(get_current_user)` to get `user_id`
    - Call `context_repo.get_by_id(context_id, user_id)`
    - Return 404 if context not found or unauthorized
    - Return `ContextInDB`
  - [ ] Implement `PUT /api/v1/contexts/{context_id}` - Update context
    - Accept `ContextUpdate` request body
    - Use `Depends(get_current_user)` to get `user_id`
    - Call `context_repo.update(context_id, user_id, updates)`
    - Return 404 if context not found or unauthorized
    - Return `ContextInDB`
  - [ ] Implement `DELETE /api/v1/contexts/{context_id}` - Delete context
    - Use `Depends(get_current_user)` to get `user_id`
    - Verify context ownership with `context_repo.get_by_id(context_id, user_id)`
    - **First delete all flows in bulk** using `flow_repo.delete_by_context_id(context_id, user_id)`
    - Then delete context using `context_repo.delete(context_id, user_id)`
    - Return 404 if context not found or unauthorized
    - Return `status_code=204` (no content)
  - [ ] **Add `delete_by_context_id()` method to FlowRepository** (Story 2.3 extension)
    - This method is needed for cascade delete but wasn't in Story 2.3
    - Signature: `async def delete_by_context_id(context_id: str, user_id: str) -> int`
    - Use `delete_many({"context_id": context_id})` for bulk delete (avoids N+1)
    - Verify user owns context before deleting flows (security)
    - Return count of deleted flows
    - Add to `my_flow_api/src/repositories/flow_repository.py`
  - [ ] Export router via `my_flow_api/src/routers/__init__.py`

- [ ] **Task 3: Create Flow API router** (AC: 2, 3, 4)
  - [ ] Create `my_flow_api/src/routers/flows.py`
  - [ ] Create `get_flow_repository()` and `get_context_repository()` dependencies for DI
  - [ ] Implement `GET /api/v1/contexts/{context_id}/flows` - List flows for context with pagination
    - Use `Depends(get_current_user)` to get `user_id`
    - Verify context ownership using `context_repo.get_by_id(context_id, user_id)`
    - Return 403 if user doesn't own context
    - Add pagination query params: `limit: int = Query(default=50, le=100)`, `offset: int = Query(default=0, ge=0)`
    - Support optional query param `include_completed: bool = Query(default=False)`
    - Call `flow_repo.get_all_by_context(context_id, include_completed=include_completed, limit=limit, offset=offset)`
    - Return `list[FlowInDB]`
    - Note: Pagination critical for contexts with many flows
  - [ ] Implement `POST /api/v1/flows` - Create flow
    - Accept `FlowCreate` request body
    - Use `Depends(get_current_user)` to get `user_id`
    - Verify context ownership using `context_repo.get_by_id(context_id, user_id)`
    - Return 403 if user doesn't own context
    - Call `flow_repo.create(context_id, flow_data)`
    - Return `FlowInDB` with `status_code=201`
  - [ ] Implement `GET /api/v1/flows/{flow_id}` - Get single flow
    - Use `Depends(get_current_user)` to get `user_id`
    - Call `flow_repo.get_by_id(flow_id)`
    - Verify `flow.user_id == user_id` (ownership check)
    - Return 403 if unauthorized, 404 if not found
    - Return `FlowInDB`
  - [ ] Implement `PUT /api/v1/flows/{flow_id}` - Update flow
    - Accept `FlowUpdate` request body
    - Use `Depends(get_current_user)` to get `user_id`
    - Get flow using `flow_repo.get_by_id(flow_id)`
    - Verify ownership (`flow.user_id == user_id`)
    - Call `flow_repo.update(flow_id, updates)`
    - Return 403 if unauthorized, 404 if not found
    - Return `FlowInDB`
  - [ ] Implement `DELETE /api/v1/flows/{flow_id}` - Delete flow
    - Use `Depends(get_current_user)` to get `user_id`
    - Get flow using `flow_repo.get_by_id(flow_id)`
    - Verify ownership (`flow.user_id == user_id`)
    - Call `flow_repo.delete(flow_id)`
    - Return 403 if unauthorized, 404 if not found
    - Return `status_code=204`
  - [ ] Implement `PATCH /api/v1/flows/{flow_id}/complete` - Mark complete
    - Use `Depends(get_current_user)` to get `user_id`
    - Get flow using `flow_repo.get_by_id(flow_id)`
    - Verify ownership (`flow.user_id == user_id`)
    - Call `flow_repo.mark_complete(flow_id)`
    - Return 403 if unauthorized, 404 if not found or already complete
    - Return `FlowInDB`
  - [ ] Export router via `my_flow_api/src/routers/__init__.py`

- [ ] **Task 4: Register routers and configure rate limiting** (AC: 1, 2)
  - [ ] Update `my_flow_api/src/main.py`
  - [ ] Import `contexts` and `flows` routers
  - [ ] Register routers with prefix `/api/v1`
  - [ ] Add tags for OpenAPI organization (`tags=["Contexts"]`, `tags=["Flows"]`)
  - [ ] **Configure rate limiting with slowapi:**
    - Install slowapi: `slowapi = "^0.1.9"` in pyproject.toml
    - Initialize Limiter in main.py: `limiter = Limiter(key_func=get_remote_address)`
    - Add rate limit exception handler for 429 responses
    - Set `app.state.limiter = limiter`
  - [ ] **Add rate limits to router endpoints:**
    - POST /api/v1/contexts: `@limiter.limit("10/minute")`
    - POST /api/v1/flows: `@limiter.limit("30/minute")`
    - GET endpoints: `@limiter.limit("60/minute")`
    - PUT/DELETE endpoints: `@limiter.limit("30/minute")`
    - Add `request: Request` parameter to all rate-limited endpoints
  - [ ] Verify FastAPI auto-generates OpenAPI docs at `/docs` (Swagger UI)
  - [ ] Verify all endpoints show correct request/response schemas

- [ ] **Task 5: Verify database indexes for query performance** (AC: 1, 2)
  - [ ] Create or update `my_flow_api/src/database.py` with index verification
  - [ ] Add `ensure_indexes()` async function
  - [ ] Create indexes for Context queries:
    - `db.contexts.create_index([("user_id", 1)])`
    - `db.contexts.create_index([("user_id", 1), ("created_at", -1)])`
  - [ ] Create indexes for Flow queries:
    - `db.flows.create_index([("context_id", 1)])`
    - `db.flows.create_index([("user_id", 1)])`
    - `db.flows.create_index([("context_id", 1), ("is_completed", 1)])`
  - [ ] Call `ensure_indexes()` during app startup (in lifespan or startup event)
  - [ ] Indexes should be idempotent (safe to run multiple times)
  - [ ] Log index creation for debugging
  - [ ] Verify indexes exist with `db.contexts.index_information()` in tests

- [ ] **Task 6: Write integration tests for Context API** (AC: 5)
  - [ ] Create `my_flow_api/tests/integration/routers/test_contexts.py`
  - [ ] Create fixture for `TestClient` with mock auth dependency override
  - [ ] Create fixture for test database with cleanup
  - [ ] Test `GET /api/v1/contexts` - Returns user's contexts
  - [ ] Test `GET /api/v1/contexts` - Returns 401 without auth token
  - [ ] Test `POST /api/v1/contexts` - Creates context successfully
  - [ ] Test `POST /api/v1/contexts` - Returns 400 for invalid color format
  - [ ] Test `POST /api/v1/contexts` - Returns 401 without auth token
  - [ ] Test `GET /api/v1/contexts/{id}` - Returns context if owned
  - [ ] Test `GET /api/v1/contexts/{id}` - Returns 403 if not owned
  - [ ] Test `GET /api/v1/contexts/{id}` - Returns 404 if context doesn't exist
  - [ ] Test `PUT /api/v1/contexts/{id}` - Updates context if owned
  - [ ] Test `PUT /api/v1/contexts/{id}` - Returns 403 if not owned
  - [ ] Test `DELETE /api/v1/contexts/{id}` - Deletes context and cascades to flows in bulk
    - Create context with 10 flows
    - Delete context
    - Verify all 10 flows deleted (single delete_many query)
    - Verify context deleted
  - [ ] Test `DELETE /api/v1/contexts/{id}` - Returns 403 if not owned
  - [ ] Test `delete_by_context_id()` bulk delete method efficiency
    - Create context with 100 flows
    - Time the delete operation
    - Verify only 2 DB queries (1 for verification, 1 for delete_many)
  - [ ] Ensure 80%+ coverage for contexts.py router

- [ ] **Task 7: Write integration tests for Flow API** (AC: 5)
  - [ ] Create `my_flow_api/tests/integration/routers/test_flows.py`
  - [ ] Reuse fixtures from `test_contexts.py` (TestClient, test DB)
  - [ ] Create fixture for test context and flows
  - [ ] Test `GET /api/v1/contexts/{context_id}/flows` - Lists flows for context
  - [ ] Test `GET /api/v1/contexts/{context_id}/flows` - Returns 403 if context not owned
  - [ ] Test `GET /api/v1/contexts/{context_id}/flows` - Filters by `include_completed` param
  - [ ] Test `POST /api/v1/flows` - Creates flow successfully
  - [ ] Test `POST /api/v1/flows` - Returns 403 if context not owned
  - [ ] Test `POST /api/v1/flows` - Returns 400 for invalid priority
  - [ ] Test `GET /api/v1/flows/{id}` - Returns flow if owned
  - [ ] Test `GET /api/v1/flows/{id}` - Returns 403 if not owned
  - [ ] Test `PUT /api/v1/flows/{id}` - Updates flow if owned
  - [ ] Test `PUT /api/v1/flows/{id}` - Returns 403 if not owned
  - [ ] Test `DELETE /api/v1/flows/{id}` - Deletes flow if owned
  - [ ] Test `DELETE /api/v1/flows/{id}` - Returns 403 if not owned
  - [ ] Test `PATCH /api/v1/flows/{id}/complete` - Marks flow complete
  - [ ] Test `PATCH /api/v1/flows/{id}/complete` - Returns 404 if already complete
  - [ ] Test `PATCH /api/v1/flows/{id}/complete` - Returns 403 if not owned
  - [ ] Ensure 80%+ coverage for flows.py router

- [ ] **Task 8: Create API testing documentation** (AC: 6)
  - [ ] Create `my_flow_api/docs/api-testing.md`
  - [ ] Document how to run API locally with 1Password: `op run -- uvicorn src.main:app --reload`
  - [ ] Include example Postman/Thunder Client collection JSON
  - [ ] Document example cURL commands for each endpoint with sample auth tokens
  - [ ] Document how to get Logto JWT token for local testing
  - [ ] Include example request/response payloads for all endpoints

- [ ] **Task 9: Run tests and verify coverage** (AC: 5)
  - [ ] Run pytest: `pytest tests/integration/routers/ -v --cov=src/routers`
  - [ ] Verify 80%+ coverage threshold met for routers
  - [ ] Fix any failing tests or edge cases discovered
  - [ ] Verify all routes work with FastAPI TestClient
  - [ ] Verify OpenAPI docs at `/docs` show all endpoints correctly

## Dev Notes

### Previous Story Insights (Story 2.2 & 2.3)

**Key Learnings from Context Repository (Story 2.2):**
- Repository layer intentionally returns None/False for not-found/unauthorized cases (service layer handles HTTP responses)
- All 104 tests passing with 91.58% coverage after QA fixes
- Made `get_all_by_user()` limit configurable via settings.MAX_CONTEXTS_PER_USER (default: 100)

**Key Learnings from Flow Repository (Story 2.3):**
- FlowRepository injects ContextRepository dependency to validate context exists before flow creation
- Type safety: Added `# type: ignore[override]` for method signature differences (intentional design)
- Query Type Fix: Used `dict[str, object]` annotation to satisfy mypy for MongoDB query dicts
- Test Coverage: 93% coverage for flow_repository.py (exceeds 85% requirement)
- All tests pass with ruff and mypy checks

[Source: docs/stories/2.2.story.md#dev-agent-record, docs/stories/2.3.story.md#dev-agent-record]

### FastAPI Router Layer Architecture

**Router responsibilities:**
- HTTP request/response handling
- Route parameter and query parameter validation
- Request body validation (via Pydantic models)
- Authentication via dependency injection
- Authorization checks (user ownership verification)
- Status code mapping (200, 201, 204, 400, 401, 403, 404)
- Dependency injection for repository/service instances

**Service layer NOT required for this story:**
- Story 2.4 focuses on direct repository → router integration
- Service layer (FlowService with status computation) will be introduced in future stories
- For now, routers call repositories directly

[Source: docs/architecture/backend-architecture.md#router-layer-api-endpoints]

### Authentication Middleware Pattern

**Logto JWT Validation with TTL-based JWKS Caching:**
```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import jwt, JWTError
from datetime import datetime, timedelta
import httpx
from src.config import settings

security = HTTPBearer()

# JWKS cache with TTL and error handling
_jwks_cache = {"keys": None, "expires_at": None}

async def get_logto_jwks() -> dict:
    """
    Fetch and cache Logto JWKS (public keys) with 1-hour TTL.

    Security considerations:
    - TTL of 1 hour allows for JWKS rotation without app restart
    - Falls back to stale cache if fetch fails (avoids auth outage)
    - Network errors are handled gracefully

    Returns:
        dict: JWKS containing public keys

    Raises:
        HTTPException: 503 if fetch fails and no cached keys available
    """
    now = datetime.utcnow()

    # Return cached JWKS if still valid
    if _jwks_cache["keys"] and _jwks_cache["expires_at"] and now < _jwks_cache["expires_at"]:
        return _jwks_cache["keys"]

    # Fetch fresh JWKS asynchronously
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get(
                f"{settings.LOGTO_ENDPOINT}/oidc/jwks",
                timeout=5.0  # 5 second timeout
            )
            response.raise_for_status()
            jwks = response.json()

            # Update cache with 1-hour TTL
            _jwks_cache["keys"] = jwks
            _jwks_cache["expires_at"] = now + timedelta(hours=1)

            return jwks

        except (httpx.HTTPError, httpx.TimeoutException) as e:
            # If fetch fails but we have stale cache, use it
            if _jwks_cache["keys"]:
                # Log warning about stale cache usage (would use logger in production)
                print(f"WARNING: Using stale JWKS cache due to fetch error: {e}")
                return _jwks_cache["keys"]

            # No cache available - this is a critical error
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Unable to fetch authentication keys"
            )

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> str:
    """
    Validate Logto JWT token and extract user_id.

    Returns:
        str: User ID from token sub claim

    Raises:
        HTTPException: 401 if token is invalid or expired
        HTTPException: 503 if JWKS fetch fails and no cache available
    """
    token = credentials.credentials

    try:
        # Fetch JWKS asynchronously (will use cache if valid)
        jwks = await get_logto_jwks()

        # Decode and verify JWT (synchronous operation)
        payload = jwt.decode(
            token,
            key=jwks,
            algorithms=["RS256"],
            audience=settings.LOGTO_APP_ID,
            issuer=f"{settings.LOGTO_ENDPOINT}/oidc"
        )

        user_id: str = payload.get("sub")
        if not user_id:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token: missing user ID"
            )

        return user_id

    except JWTError as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"Invalid or expired token: {str(e)}"
        )
```

[Source: docs/architecture/backend-architecture.md#authentication-middleware]

### Authorization Helper Pattern (DRY)

**Reusable ownership verification helpers to avoid code duplication:**
```python
# In src/middleware/auth.py or src/utils/auth_helpers.py

async def verify_context_ownership(
    context_id: str,
    user_id: str,
    context_repo: ContextRepository
) -> ContextInDB:
    """
    Verify user owns the context and return it.

    Args:
        context_id: Context ID to verify
        user_id: Current user ID from JWT
        context_repo: ContextRepository instance

    Returns:
        ContextInDB: The context if owned by user

    Raises:
        HTTPException: 404 if context not found or not owned by user
    """
    context = await context_repo.get_by_id(context_id, user_id)
    if not context:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Context not found"
        )
    return context


async def verify_flow_ownership(
    flow_id: str,
    user_id: str,
    flow_repo: FlowRepository
) -> FlowInDB:
    """
    Verify user owns the flow and return it.

    Args:
        flow_id: Flow ID to verify
        user_id: Current user ID from JWT
        flow_repo: FlowRepository instance

    Returns:
        FlowInDB: The flow if owned by user

    Raises:
        HTTPException: 404 if flow not found, 403 if not owned by user
    """
    flow = await flow_repo.get_by_id(flow_id)
    if not flow:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Flow not found"
        )

    if flow.user_id != user_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access forbidden"
        )

    return flow
```

**Usage in routes (reduces duplication):**
```python
# Before (repetitive):
@router.put("/api/v1/flows/{flow_id}")
async def update_flow(
    flow_id: str,
    updates: FlowUpdate,
    user_id: str = Depends(get_current_user),
    flow_repo: FlowRepository = Depends(get_flow_repository)
):
    flow = await flow_repo.get_by_id(flow_id)
    if not flow:
        raise HTTPException(status_code=404, detail="Flow not found")
    if flow.user_id != user_id:
        raise HTTPException(status_code=403, detail="Access forbidden")

    return await flow_repo.update(flow_id, updates)

# After (DRY with helper):
@router.put("/api/v1/flows/{flow_id}")
async def update_flow(
    flow_id: str,
    updates: FlowUpdate,
    user_id: str = Depends(get_current_user),
    flow_repo: FlowRepository = Depends(get_flow_repository)
):
    # Single line ownership verification
    await verify_flow_ownership(flow_id, user_id, flow_repo)
    return await flow_repo.update(flow_id, updates)
```

**Benefits:**
- DRY: Ownership checks in one place
- Consistent error responses (404 vs 403)
- Easier to add logging/metrics to all auth checks
- Simpler route handlers focus on business logic

[Source: docs/architecture/backend-architecture.md#authentication-middleware]

### Dependency Injection Pattern

**Repository DI example:**
```python
from fastapi import Depends
from motor.motor_asyncio import AsyncIOMotorDatabase
from src.database import get_database
from src.repositories.context_repository import ContextRepository

async def get_context_repository(
    db: AsyncIOMotorDatabase = Depends(get_database)
) -> ContextRepository:
    """Dependency injection for ContextRepository."""
    return ContextRepository(db)
```

**Using in routes:**
```python
@router.get("/api/v1/contexts", response_model=list[ContextInDB])
async def list_contexts(
    user_id: str = Depends(get_current_user),
    context_repo: ContextRepository = Depends(get_context_repository)
):
    """List all contexts for the authenticated user."""
    return await context_repo.get_all_by_user(user_id)
```

[Source: docs/architecture/backend-architecture.md#router-layer-api-endpoints]

### Cascade Delete Pattern

**When deleting context, must delete all flows first using bulk delete:**
```python
@router.delete("/api/v1/contexts/{context_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_context(
    context_id: str,
    user_id: str = Depends(get_current_user),
    context_repo: ContextRepository = Depends(get_context_repository),
    flow_repo: FlowRepository = Depends(get_flow_repository)
):
    """Delete context and all associated flows."""
    # Verify context ownership
    context = await context_repo.get_by_id(context_id, user_id)
    if not context:
        raise HTTPException(status_code=404, detail="Context not found")

    # Delete all flows for context in bulk (single DB query)
    # Uses delete_many() to avoid N+1 query problem
    await flow_repo.delete_by_context_id(context_id, user_id)

    # Delete context
    deleted = await context_repo.delete(context_id, user_id)
    if not deleted:
        raise HTTPException(status_code=404, detail="Context not found")
```

**FlowRepository bulk delete method (required for cascade delete):**
```python
# In flow_repository.py
async def delete_by_context_id(self, context_id: str, user_id: str) -> int:
    """
    Delete all flows for a context in bulk (cascade delete support).

    Args:
        context_id: Context ID whose flows to delete
        user_id: User ID for ownership verification

    Returns:
        int: Number of flows deleted

    Note: This method performs a single delete_many() query instead of
    fetching flows and deleting one-by-one (avoids N+1 problem).
    """
    # Verify user owns the context (security check)
    context = await self.context_repo.get_by_id(context_id, user_id)
    if not context:
        return 0  # Context not found or user doesn't own it

    # Bulk delete all flows for this context
    result = await self.collection.delete_many({"context_id": context_id})
    return result.deleted_count
```

[Source: docs/prd/epic-2-context-flow-data-layer-with-ui-foundation.md#story-24-context-flow-rest-api-endpoints]

### Pagination Pattern for List Endpoints

**Why pagination is needed:**
- Improves frontend loading performance
- Reduces API response times
- Lowers memory usage on client and server
- Allows incremental loading with "Load More" UI pattern

**Pagination for contexts list:**
```python
from fastapi import Query

@router.get("/api/v1/contexts", response_model=list[ContextInDB])
async def list_contexts(
    user_id: str = Depends(get_current_user),
    context_repo: ContextRepository = Depends(get_context_repository),
    limit: int = Query(default=50, le=100, description="Max items per page"),
    offset: int = Query(default=0, ge=0, description="Number of items to skip")
):
    """List contexts with pagination support."""
    contexts = await context_repo.get_all_by_user(user_id, limit=limit, offset=offset)
    return contexts
```

**Pagination for flows list:**
```python
@router.get("/api/v1/contexts/{context_id}/flows", response_model=list[FlowInDB])
async def list_flows(
    context_id: str,
    user_id: str = Depends(get_current_user),
    context_repo: ContextRepository = Depends(get_context_repository),
    flow_repo: FlowRepository = Depends(get_flow_repository),
    include_completed: bool = Query(default=False),
    limit: int = Query(default=50, le=100),
    offset: int = Query(default=0, ge=0)
):
    """List flows for context with pagination."""
    # Verify ownership
    await verify_context_ownership(context_id, user_id, context_repo)

    # Fetch flows with pagination
    flows = await flow_repo.get_all_by_context(
        context_id,
        include_completed=include_completed,
        limit=limit,
        offset=offset
    )
    return flows
```

**Repository changes needed:**
- Update `get_all_by_user(user_id, limit=50, offset=0)` signature
- Update `get_all_by_context(context_id, include_completed, limit=50, offset=0)` signature
- Use MongoDB `.skip(offset).limit(limit)` for pagination

**Benefits:**
- Default 50 items protects against accidental large queries
- Max 100 items prevents memory exhaustion
- Frontend can implement infinite scroll or "Load More" button

[Source: docs/architecture/api-specification.md#query-parameters-for-filtering]

### Database Index Verification

**Why index verification is critical:**
- Ensures optimal query performance from day one
- Prevents slow queries as data grows
- Indexes support pagination, filtering, and sorting

**Index creation during app startup:**
```python
# In src/database.py

async def ensure_indexes():
    """
    Ensure database indexes exist for optimal query performance.

    This function is idempotent - safe to run multiple times.
    MongoDB will skip index creation if it already exists.
    """
    db = db_instance.db

    # Context collection indexes
    # Supports: get_all_by_user() queries
    await db.contexts.create_index([("user_id", 1)])

    # Supports: get_all_by_user() with sorting by created_at desc
    await db.contexts.create_index([("user_id", 1), ("created_at", -1)])

    # Flow collection indexes
    # Supports: get_all_by_context() queries
    await db.flows.create_index([("context_id", 1)])

    # Supports: user-level flow queries
    await db.flows.create_index([("user_id", 1)])

    # Supports: get_all_by_context() with is_completed filter
    await db.flows.create_index([("context_id", 1), ("is_completed", 1)])

    print("✅ Database indexes verified")

# In src/main.py lifespan
@asynccontextmanager
async def lifespan(app: FastAPI):
    """Startup and shutdown events."""
    # Startup
    await connect_to_mongo()
    await ensure_indexes()  # Verify indexes on startup
    print("✅ Connected to MongoDB with indexes")

    yield

    # Shutdown
    await close_mongo_connection()
    print("✅ Closed MongoDB connection")
```

**Index verification in tests:**
```python
# In tests/integration/test_database.py
async def test_indexes_exist():
    """Verify all required indexes exist."""
    db = await get_database()

    # Check context indexes
    context_indexes = await db.contexts.index_information()
    assert "user_id_1" in context_indexes
    assert "user_id_1_created_at_-1" in context_indexes

    # Check flow indexes
    flow_indexes = await db.flows.index_information()
    assert "context_id_1" in flow_indexes
    assert "user_id_1" in flow_indexes
    assert "context_id_1_is_completed_1" in flow_indexes
```

**Performance impact:**
- Without indexes: O(n) table scans
- With indexes: O(log n) lookups
- Critical for pagination queries with skip/limit

[Source: docs/architecture/data-models.md#database-indexes-mongodb]

### Rate Limiting for Abuse Prevention

**Why rate limiting is critical:**
- Prevents API abuse and spam
- Protects against brute force attacks
- Ensures fair resource usage
- Prevents accidental infinite loops in clients

**Rate limiting implementation using slowapi:**
```python
from slowapi import Limiter
from slowapi.util import get_remote_address
from fastapi import Request

# Initialize limiter
limiter = Limiter(key_func=get_remote_address)

# In main.py
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# In routers/contexts.py
@router.post("/api/v1/contexts", response_model=ContextInDB, status_code=201)
@limiter.limit("10/minute")  # Max 10 context creations per minute
async def create_context(
    request: Request,  # Required for slowapi
    context_data: ContextCreate,
    user_id: str = Depends(get_current_user),
    context_repo: ContextRepository = Depends(get_context_repository)
):
    """Create a new context (rate limited)."""
    return await context_repo.create(user_id, context_data)

# In routers/flows.py
@router.post("/api/v1/flows", response_model=FlowInDB, status_code=201)
@limiter.limit("30/minute")  # Max 30 flow creations per minute
async def create_flow(
    request: Request,
    flow_data: FlowCreate,
    user_id: str = Depends(get_current_user),
    flow_repo: FlowRepository = Depends(get_flow_repository),
    context_repo: ContextRepository = Depends(get_context_repository)
):
    """Create a new flow (rate limited)."""
    await verify_context_ownership(flow_data.context_id, user_id, context_repo)
    return await flow_repo.create(flow_data.context_id, flow_data)
```

**Rate limit configuration:**
```python
# Recommended limits
- Context creation: 10/minute (contexts created infrequently)
- Flow creation: 30/minute (flows created more frequently)
- List endpoints: 60/minute (read operations more frequent)
- Update/Delete: 30/minute (moderate usage)
```

**Rate limit exceeded response:**
```python
from slowapi.errors import RateLimitExceeded

async def _rate_limit_exceeded_handler(request: Request, exc: RateLimitExceeded):
    """Handle rate limit exceeded errors."""
    return JSONResponse(
        status_code=status.HTTP_429_TOO_MANY_REQUESTS,
        content={
            "detail": "Rate limit exceeded. Please try again later.",
            "retry_after": exc.retry_after
        }
    )
```

**Dependencies required:**
```toml
# Add to pyproject.toml
slowapi = "^0.1.9"
```

**Benefits:**
- Prevents context/flow creation spam
- Protects database from excessive writes
- Returns 429 status code with retry-after header
- Can be configured per-endpoint based on criticality

[Source: FastAPI rate limiting best practices]

### Pydantic Validation with Max Lengths

**Why max length validation is important:**
- Prevents database storage abuse
- Protects against excessively long payloads
- Ensures consistent UI rendering
- Database schema enforcement

**Validation in Pydantic models (from Story 2.1):**
```python
# In models/context.py
from pydantic import BaseModel, Field

class ContextCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=50, description="Context name")
    color: str = Field(..., pattern=r'^#[0-9A-Fa-f]{6}$', description="Hex color")
    icon: str = Field(..., min_length=1, max_length=10, description="Emoji icon")

# In models/flow.py
class FlowCreate(BaseModel):
    context_id: str = Field(..., description="Parent context ID")
    title: str = Field(..., min_length=1, max_length=200, description="Flow title")
    description: str | None = Field(None, max_length=2000, description="Optional description")
    priority: Literal["low", "medium", "high"] = Field(default="medium")
    due_date: datetime | None = None
    reminder_enabled: bool = Field(default=True)
```

**Validation rules enforced:**
- **Context name**: 1-50 characters (UI friendly)
- **Context icon**: 1-10 characters (emoji only)
- **Flow title**: 1-200 characters (prevents excessively long titles)
- **Flow description**: Max 2000 characters (prevents abuse)
- **Color format**: Hex regex validation (`#3B82F6`)

**Validation error response:**
```json
{
  "detail": [
    {
      "loc": ["body", "title"],
      "msg": "ensure this value has at most 200 characters",
      "type": "value_error.any_str.max_length",
      "ctx": {"limit_value": 200}
    }
  ]
}
```

**Story 2.1 reference:**
Story 2.1 already defines these validation rules. Story 2.4 routers inherit this validation automatically via FastAPI's request body parsing.

**Additional validation to consider:**
- Email format validation (if adding user emails)
- URL validation (if adding external links)
- Timezone validation (for due_date fields)

[Source: docs/architecture/data-models.md, Story 2.1 Pydantic models]

### API Response Models

**Use Pydantic models from Story 2.1:**
- `ContextCreate`, `ContextUpdate`, `ContextInDB` from `src/models/context.py`
- `FlowCreate`, `FlowUpdate`, `FlowInDB` from `src/models/flow.py`

**FastAPI automatically:**
- Validates request bodies against `*Create` and `*Update` schemas
- Serializes response models (`*InDB`) to JSON
- Generates OpenAPI spec with schema documentation
- Shows examples in Swagger UI (`/docs`)

[Source: docs/architecture/backend-architecture.md#pydantic-models-requestresponse-schemas]

### Error Handling Standards

**HTTP Status Codes:**
- `200 OK` - Successful GET, PUT, PATCH
- `201 Created` - Successful POST
- `204 No Content` - Successful DELETE
- `400 Bad Request` - Validation error (Pydantic)
- `401 Unauthorized` - Missing or invalid JWT token
- `403 Forbidden` - User doesn't own resource
- `404 Not Found` - Resource doesn't exist
- `429 Too Many Requests` - Rate limit exceeded (slowapi)

**HTTPException examples:**
```python
# 401 Unauthorized (handled by auth middleware)
raise HTTPException(status_code=401, detail="Invalid or expired token")

# 403 Forbidden (ownership check)
if flow.user_id != user_id:
    raise HTTPException(status_code=403, detail="Access forbidden")

# 404 Not Found (resource doesn't exist)
if not context:
    raise HTTPException(status_code=404, detail="Context not found")

# 429 Too Many Requests (rate limit exceeded, handled by slowapi)
# Automatically raised by @limiter.limit() decorator
# Returns: {"detail": "Rate limit exceeded. Please try again later.", "retry_after": 60}
```

[Source: docs/architecture/15-error-handling-strategy.md#error-categories-and-status-codes]

### Project Structure Alignment

**Router files location:**
```
my_flow_api/src/routers/
├── __init__.py          # Export all routers
├── contexts.py          # Context CRUD routes (THIS STORY)
└── flows.py             # Flow CRUD routes (THIS STORY)
```

**Auth middleware location:**
```
my_flow_api/src/middleware/
├── __init__.py
└── auth.py              # get_current_user dependency (THIS STORY)
```

**Test files location:**
```
my_flow_api/tests/integration/routers/
├── __init__.py
├── test_contexts.py     # Context API tests (THIS STORY)
└── test_flows.py        # Flow API tests (THIS STORY)
```

[Source: docs/architecture/9-unified-project-structure.md#backend-structure]

### Testing Standards

**Integration Test Setup:**
```python
# tests/integration/routers/test_contexts.py
import pytest
from fastapi.testclient import TestClient
from src.main import app
from src.middleware.auth import get_current_user

# Mock auth dependency
async def override_get_current_user():
    return "test_user_id"

app.dependency_overrides[get_current_user] = override_get_current_user

@pytest.fixture
def client():
    """Provides TestClient for integration tests."""
    return TestClient(app)

@pytest.mark.asyncio
async def test_list_contexts(client):
    """Test GET /api/v1/contexts returns user's contexts."""
    response = client.get("/api/v1/contexts")
    assert response.status_code == 200
    assert isinstance(response.json(), list)
```

**Test Organization:**
- Integration tests: `tests/integration/routers/test_contexts.py`, `test_flows.py`
- Use `TestClient` from FastAPI (wraps HTTPX async client)
- Override auth dependency to inject test user_id
- Test both success and error cases (401, 403, 404)
- Use real MongoDB connection with test database cleanup

**Coverage Requirements:**
- 80% minimum coverage for router files
- Test all endpoints (GET, POST, PUT, DELETE, PATCH)
- Test authentication (401 responses)
- Test authorization (403 responses)
- Test validation errors (400 responses)

[Source: docs/architecture/13-testing-strategy.md#backend-api-integration-test]

### Python Dependencies

**Required dependencies (already in pyproject.toml from Stories 2.1-2.3):**
- `fastapi ^0.115.0` - Web framework
- `uvicorn[standard] ^0.30.0` - ASGI server
- `motor ^3.5.0` - Async MongoDB driver
- `pydantic ^2.8.0` - Data validation
- `python-jose[cryptography] ^3.3.0` - JWT validation
- `httpx ^0.27.0` - HTTP client for JWKS fetch

**Dev dependencies:**
- `pytest ^8.3.0` - Test framework
- `pytest-asyncio ^0.24.0` - Async test support
- `pytest-cov` - Coverage reporting
- `httpx` - TestClient support

[Source: docs/architecture/tech-stack.md]

### OpenAPI Documentation

**FastAPI auto-generates OpenAPI spec:**
- Swagger UI available at `/docs`
- ReDoc available at `/redoc`
- OpenAPI JSON schema at `/openapi.json`

**Ensure schemas are documented:**
- Use `response_model` parameter in route decorators
- Use `status_code` parameter for non-200 success codes
- Use `tags` parameter for grouping endpoints in docs
- Pydantic models automatically show in schema

**Example:**
```python
@router.post(
    "/api/v1/contexts",
    response_model=ContextInDB,
    status_code=status.HTTP_201_CREATED,
    tags=["Contexts"],
    summary="Create a new context",
    description="Create a new context for the authenticated user"
)
async def create_context(
    context_data: ContextCreate,
    user_id: str = Depends(get_current_user),
    context_repo: ContextRepository = Depends(get_context_repository)
):
    """Create a new context."""
    return await context_repo.create(user_id, context_data)
```

[Source: docs/architecture/api-specification.md#openapi-31-specification]

### API Specification Reference

**Context Endpoints:**
- `GET /api/v1/contexts` → List all contexts
- `POST /api/v1/contexts` → Create context
- `GET /api/v1/contexts/{context_id}` → Get single context
- `PUT /api/v1/contexts/{context_id}` → Update context
- `DELETE /api/v1/contexts/{context_id}` → Delete context

**Flow Endpoints:**
- `GET /api/v1/contexts/{context_id}/flows` → List flows for context
- `POST /api/v1/flows` → Create flow
- `GET /api/v1/flows/{flow_id}` → Get single flow
- `PUT /api/v1/flows/{flow_id}` → Update flow
- `DELETE /api/v1/flows/{flow_id}` → Delete flow
- `PATCH /api/v1/flows/{flow_id}/complete` → Mark complete

**All endpoints require `Authorization: Bearer <jwt_token>` header**

[Source: docs/architecture/api-specification.md#api-endpoints-overview]

### Type Hints and Async Patterns

**All route handlers MUST be async:**
```python
async def list_contexts(
    user_id: str = Depends(get_current_user),
    context_repo: ContextRepository = Depends(get_context_repository)
) -> list[ContextInDB]:
    ...
```

**Use FastAPI dependencies:**
- `Depends(get_current_user)` for authentication
- `Depends(get_context_repository)` for repository DI
- `Depends(get_database)` for database connection

**Type hints for responses:**
- Use `response_model` in route decorator
- Return Pydantic models directly (FastAPI auto-serializes)
- Use `list[ModelType]` for list responses

[Source: docs/architecture/coding-standards.md#naming-conventions]

### Configuration Management

**Settings required for auth:**
```python
# src/config.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # ... existing settings ...

    # Logto Authentication
    LOGTO_ENDPOINT: str  # e.g., "https://your-logto-instance.logto.app"
    LOGTO_APP_ID: str
    LOGTO_APP_SECRET: str  # Not used in JWT validation (public key from JWKS)
```

**Environment variables (.env):**
```bash
LOGTO_ENDPOINT=https://your-logto-instance.logto.app
LOGTO_APP_ID=your-app-id
LOGTO_APP_SECRET=your-app-secret
```

[Source: docs/architecture/backend-architecture.md#configuration-management]

## Testing

### Test File Locations

**Integration tests for routers:**
- `my_flow_api/tests/integration/routers/test_contexts.py` - Context API integration tests
- `my_flow_api/tests/integration/routers/test_flows.py` - Flow API integration tests

**Unit tests for middleware:**
- `my_flow_api/tests/unit/middleware/test_auth.py` - Auth middleware unit tests

### Testing Frameworks and Patterns

**Frameworks:**
- `pytest` - Test framework with async support via `pytest-asyncio`
- `fastapi.testclient.TestClient` - HTTP client for testing FastAPI routes
- `pytest-cov` - Coverage reporting
- `httpx` - Async HTTP client (used by TestClient)

**Patterns:**
- Use `TestClient(app)` to make requests to FastAPI routes
- Override auth dependency with `app.dependency_overrides[get_current_user] = mock_user`
- Use real MongoDB connection with test database (not mocks)
- Clean up test data after each test using fixtures
- Test both success cases and error cases (401, 403, 404, 400)
- Use `@pytest.mark.asyncio` for async tests

**Example test structure:**
```python
import pytest
from fastapi.testclient import TestClient
from src.main import app
from src.middleware.auth import get_current_user

# Mock auth dependency
async def override_get_current_user():
    return "test_user_id"

app.dependency_overrides[get_current_user] = override_get_current_user

@pytest.fixture
def client():
    return TestClient(app)

@pytest.mark.asyncio
async def test_create_context_success(client):
    """Test POST /api/v1/contexts creates context successfully."""
    response = client.post(
        "/api/v1/contexts",
        json={"name": "Work", "color": "#3B82F6", "icon": "💼"}
    )
    assert response.status_code == 201
    data = response.json()
    assert data["name"] == "Work"
    assert "id" in data

@pytest.mark.asyncio
async def test_create_context_invalid_color(client):
    """Test POST /api/v1/contexts returns 400 for invalid color."""
    response = client.post(
        "/api/v1/contexts",
        json={"name": "Work", "color": "invalid", "icon": "💼"}
    )
    assert response.status_code == 422  # Pydantic validation error
```

### Test Coverage Requirements

**Coverage targets:**
- 80% minimum coverage for router files (`src/routers/contexts.py`, `src/routers/flows.py`)
- 80% minimum coverage for auth middleware (`src/middleware/auth.py`)

**Coverage command:**
```bash
pytest tests/integration/routers/ -v --cov=src/routers --cov=src/middleware
```

[Source: docs/architecture/13-testing-strategy.md#test-organization]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-07 | 1.0 | Story created for Epic 2.4 | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

### Debug Log References

### Completion Notes List

### File List

## QA Results
