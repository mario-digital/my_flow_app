# Story 2.4: Context & Flow REST API Endpoints (BE)

## Status
draft

## Story

**As a** backend developer,
**I want** FastAPI REST endpoints for context and flow management,
**so that** the frontend can perform all CRUD operations via HTTP.

## Acceptance Criteria

1. **Context API routes created in `my_flow_api/src/routers/contexts.py`:**
   - `GET /api/v1/contexts` → List user's contexts (requires auth)
   - `POST /api/v1/contexts` → Create context (requires auth, validates body)
   - `GET /api/v1/contexts/{id}` → Get single context (requires auth + ownership)
   - `PUT /api/v1/contexts/{id}` → Update context (requires auth + ownership)
   - `DELETE /api/v1/contexts/{id}` → Delete context (requires auth + ownership, cascades to flows)
   - All routes use dependency injection for `ContextRepository`

2. **Flow API routes created in `my_flow_api/src/routers/flows.py`:**
   - `GET /api/v1/contexts/{context_id}/flows` → List flows for context (requires auth + ownership)
   - `POST /api/v1/flows` → Create flow (requires auth, validates context ownership)
   - `GET /api/v1/flows/{id}` → Get single flow (requires auth)
   - `PUT /api/v1/flows/{id}` → Update flow (requires auth)
   - `DELETE /api/v1/flows/{id}` → Delete flow (requires auth)
   - `PATCH /api/v1/flows/{id}/complete` → Mark complete (requires auth)
   - All routes use dependency injection for `FlowRepository`

3. **Authentication middleware enforced:**
   - All routes require valid Logto JWT token
   - `user_id` extracted from token and passed to repository methods
   - Returns 401 for missing/invalid tokens
   - Returns 403 for unauthorized access (e.g., accessing another user's context)

4. **API response models use Pydantic:**
   - All endpoints return `ContextResponse` or `FlowResponse` (or lists)
   - Error responses use FastAPI HTTPException with proper status codes
   - OpenAPI docs auto-generated with full schema documentation

5. **Integration tests created in `my_flow_api/tests/integration/routers/test_contexts.py` and `test_flows.py`:**
   - Uses `TestClient` with mock authentication
   - Tests all endpoints (success cases + error cases)
   - Tests authorization (401, 403 responses)
   - Tests cascade delete (deleting context deletes flows)
   - At least 80% coverage for API routes

6. **Manual testing verified with 1Password secrets:**
   - Can run `op run -- uvicorn main:app --reload` and test all endpoints locally
   - Postman/Thunder Client collection documented in `my_flow_api/docs/api-testing.md`

## Tasks / Subtasks

- [ ] **Task 1: Create auth middleware dependency** (AC: 3)
  - [ ] Create `my_flow_api/src/middleware/auth.py`
  - [ ] Implement async `get_current_user()` dependency that validates Logto JWT
  - [ ] Extract `user_id` from token `sub` claim
  - [ ] Return 401 HTTPException for invalid/expired tokens
  - [ ] Use `python-jose` library for JWT decoding
  - [ ] Fetch Logto JWKS (public keys) from `{LOGTO_ENDPOINT}/oidc/jwks`
  - [ ] **SECURITY: Implement async TTL-based JWKS caching (1-hour TTL)**
    - Make `get_logto_jwks()` async function
    - Use `httpx.AsyncClient()` for async HTTP requests
    - Use module-level dict cache with `expires_at` timestamp
    - Refetch JWKS after TTL expires (allows JWKS rotation)
    - Add 5-second timeout to JWKS fetch
    - Fallback to stale cache if fetch fails (prevents auth outage)
    - Return 503 error if no cache available and fetch fails
    - Log warnings when using stale cache
  - [ ] In `get_current_user()`, await the async `get_logto_jwks()` call
  - [ ] Verify token signature, audience (`LOGTO_APP_ID`), issuer
  - [ ] Add unit tests for `get_current_user()` with mocked JWT tokens
  - [ ] Add unit tests for JWKS caching (TTL expiry, stale cache fallback, fetch failures)

- [ ] **Task 2: Create Context API router** (AC: 1, 3, 4)
  - [ ] Create `my_flow_api/src/routers/contexts.py`
  - [ ] Create `get_context_repository()` dependency for DI
  - [ ] Implement `GET /api/v1/contexts` - List contexts for user
    - Use `Depends(get_current_user)` to get `user_id`
    - Call `context_repo.get_all_by_user(user_id)`
    - Return `list[ContextInDB]` (response_model)
  - [ ] Implement `POST /api/v1/contexts` - Create context
    - Accept `ContextCreate` request body
    - Use `Depends(get_current_user)` to get `user_id`
    - Call `context_repo.create(user_id, context_data)`
    - Return `ContextInDB` with `status_code=201`
  - [ ] Implement `GET /api/v1/contexts/{context_id}` - Get single context
    - Use `Depends(get_current_user)` to get `user_id`
    - Call `context_repo.get_by_id(context_id, user_id)`
    - Return 404 if context not found or unauthorized
    - Return `ContextInDB`
  - [ ] Implement `PUT /api/v1/contexts/{context_id}` - Update context
    - Accept `ContextUpdate` request body
    - Use `Depends(get_current_user)` to get `user_id`
    - Call `context_repo.update(context_id, user_id, updates)`
    - Return 404 if context not found or unauthorized
    - Return `ContextInDB`
  - [ ] Implement `DELETE /api/v1/contexts/{context_id}` - Delete context
    - Use `Depends(get_current_user)` to get `user_id`
    - Verify context ownership with `context_repo.get_by_id(context_id, user_id)`
    - **First delete all flows in bulk** using `flow_repo.delete_by_context_id(context_id, user_id)`
    - Then delete context using `context_repo.delete(context_id, user_id)`
    - Return 404 if context not found or unauthorized
    - Return `status_code=204` (no content)
  - [ ] **Add `delete_by_context_id()` method to FlowRepository** (Story 2.3 extension)
    - This method is needed for cascade delete but wasn't in Story 2.3
    - Signature: `async def delete_by_context_id(context_id: str, user_id: str) -> int`
    - Use `delete_many({"context_id": context_id})` for bulk delete (avoids N+1)
    - Verify user owns context before deleting flows (security)
    - Return count of deleted flows
    - Add to `my_flow_api/src/repositories/flow_repository.py`
  - [ ] Export router via `my_flow_api/src/routers/__init__.py`

- [ ] **Task 3: Create Flow API router** (AC: 2, 3, 4)
  - [ ] Create `my_flow_api/src/routers/flows.py`
  - [ ] Create `get_flow_repository()` and `get_context_repository()` dependencies for DI
  - [ ] Implement `GET /api/v1/contexts/{context_id}/flows` - List flows for context
    - Use `Depends(get_current_user)` to get `user_id`
    - Verify context ownership using `context_repo.get_by_id(context_id, user_id)`
    - Return 403 if user doesn't own context
    - Call `flow_repo.get_all_by_context(context_id, include_completed=False)` (default)
    - Support optional query param `include_completed: bool`
    - Return `list[FlowInDB]`
  - [ ] Implement `POST /api/v1/flows` - Create flow
    - Accept `FlowCreate` request body
    - Use `Depends(get_current_user)` to get `user_id`
    - Verify context ownership using `context_repo.get_by_id(context_id, user_id)`
    - Return 403 if user doesn't own context
    - Call `flow_repo.create(context_id, flow_data)`
    - Return `FlowInDB` with `status_code=201`
  - [ ] Implement `GET /api/v1/flows/{flow_id}` - Get single flow
    - Use `Depends(get_current_user)` to get `user_id`
    - Call `flow_repo.get_by_id(flow_id)`
    - Verify `flow.user_id == user_id` (ownership check)
    - Return 403 if unauthorized, 404 if not found
    - Return `FlowInDB`
  - [ ] Implement `PUT /api/v1/flows/{flow_id}` - Update flow
    - Accept `FlowUpdate` request body
    - Use `Depends(get_current_user)` to get `user_id`
    - Get flow using `flow_repo.get_by_id(flow_id)`
    - Verify ownership (`flow.user_id == user_id`)
    - Call `flow_repo.update(flow_id, updates)`
    - Return 403 if unauthorized, 404 if not found
    - Return `FlowInDB`
  - [ ] Implement `DELETE /api/v1/flows/{flow_id}` - Delete flow
    - Use `Depends(get_current_user)` to get `user_id`
    - Get flow using `flow_repo.get_by_id(flow_id)`
    - Verify ownership (`flow.user_id == user_id`)
    - Call `flow_repo.delete(flow_id)`
    - Return 403 if unauthorized, 404 if not found
    - Return `status_code=204`
  - [ ] Implement `PATCH /api/v1/flows/{flow_id}/complete` - Mark complete
    - Use `Depends(get_current_user)` to get `user_id`
    - Get flow using `flow_repo.get_by_id(flow_id)`
    - Verify ownership (`flow.user_id == user_id`)
    - Call `flow_repo.mark_complete(flow_id)`
    - Return 403 if unauthorized, 404 if not found or already complete
    - Return `FlowInDB`
  - [ ] Export router via `my_flow_api/src/routers/__init__.py`

- [ ] **Task 4: Register routers in main.py** (AC: 1, 2)
  - [ ] Update `my_flow_api/src/main.py`
  - [ ] Import `contexts` and `flows` routers
  - [ ] Register routers with prefix `/api/v1`
  - [ ] Add tags for OpenAPI organization (`tags=["Contexts"]`, `tags=["Flows"]`)
  - [ ] Verify FastAPI auto-generates OpenAPI docs at `/docs` (Swagger UI)
  - [ ] Verify all endpoints show correct request/response schemas

- [ ] **Task 5: Write integration tests for Context API** (AC: 5)
  - [ ] Create `my_flow_api/tests/integration/routers/test_contexts.py`
  - [ ] Create fixture for `TestClient` with mock auth dependency override
  - [ ] Create fixture for test database with cleanup
  - [ ] Test `GET /api/v1/contexts` - Returns user's contexts
  - [ ] Test `GET /api/v1/contexts` - Returns 401 without auth token
  - [ ] Test `POST /api/v1/contexts` - Creates context successfully
  - [ ] Test `POST /api/v1/contexts` - Returns 400 for invalid color format
  - [ ] Test `POST /api/v1/contexts` - Returns 401 without auth token
  - [ ] Test `GET /api/v1/contexts/{id}` - Returns context if owned
  - [ ] Test `GET /api/v1/contexts/{id}` - Returns 403 if not owned
  - [ ] Test `GET /api/v1/contexts/{id}` - Returns 404 if context doesn't exist
  - [ ] Test `PUT /api/v1/contexts/{id}` - Updates context if owned
  - [ ] Test `PUT /api/v1/contexts/{id}` - Returns 403 if not owned
  - [ ] Test `DELETE /api/v1/contexts/{id}` - Deletes context and cascades to flows in bulk
    - Create context with 10 flows
    - Delete context
    - Verify all 10 flows deleted (single delete_many query)
    - Verify context deleted
  - [ ] Test `DELETE /api/v1/contexts/{id}` - Returns 403 if not owned
  - [ ] Test `delete_by_context_id()` bulk delete method efficiency
    - Create context with 100 flows
    - Time the delete operation
    - Verify only 2 DB queries (1 for verification, 1 for delete_many)
  - [ ] Ensure 80%+ coverage for contexts.py router

- [ ] **Task 6: Write integration tests for Flow API** (AC: 5)
  - [ ] Create `my_flow_api/tests/integration/routers/test_flows.py`
  - [ ] Reuse fixtures from `test_contexts.py` (TestClient, test DB)
  - [ ] Create fixture for test context and flows
  - [ ] Test `GET /api/v1/contexts/{context_id}/flows` - Lists flows for context
  - [ ] Test `GET /api/v1/contexts/{context_id}/flows` - Returns 403 if context not owned
  - [ ] Test `GET /api/v1/contexts/{context_id}/flows` - Filters by `include_completed` param
  - [ ] Test `POST /api/v1/flows` - Creates flow successfully
  - [ ] Test `POST /api/v1/flows` - Returns 403 if context not owned
  - [ ] Test `POST /api/v1/flows` - Returns 400 for invalid priority
  - [ ] Test `GET /api/v1/flows/{id}` - Returns flow if owned
  - [ ] Test `GET /api/v1/flows/{id}` - Returns 403 if not owned
  - [ ] Test `PUT /api/v1/flows/{id}` - Updates flow if owned
  - [ ] Test `PUT /api/v1/flows/{id}` - Returns 403 if not owned
  - [ ] Test `DELETE /api/v1/flows/{id}` - Deletes flow if owned
  - [ ] Test `DELETE /api/v1/flows/{id}` - Returns 403 if not owned
  - [ ] Test `PATCH /api/v1/flows/{id}/complete` - Marks flow complete
  - [ ] Test `PATCH /api/v1/flows/{id}/complete` - Returns 404 if already complete
  - [ ] Test `PATCH /api/v1/flows/{id}/complete` - Returns 403 if not owned
  - [ ] Ensure 80%+ coverage for flows.py router

- [ ] **Task 7: Create API testing documentation** (AC: 6)
  - [ ] Create `my_flow_api/docs/api-testing.md`
  - [ ] Document how to run API locally with 1Password: `op run -- uvicorn src.main:app --reload`
  - [ ] Include example Postman/Thunder Client collection JSON
  - [ ] Document example cURL commands for each endpoint with sample auth tokens
  - [ ] Document how to get Logto JWT token for local testing
  - [ ] Include example request/response payloads for all endpoints

- [ ] **Task 8: Run tests and verify coverage** (AC: 5)
  - [ ] Run pytest: `pytest tests/integration/routers/ -v --cov=src/routers`
  - [ ] Verify 80%+ coverage threshold met for routers
  - [ ] Fix any failing tests or edge cases discovered
  - [ ] Verify all routes work with FastAPI TestClient
  - [ ] Verify OpenAPI docs at `/docs` show all endpoints correctly

## Dev Notes

### Previous Story Insights (Story 2.2 & 2.3)

**Key Learnings from Context Repository (Story 2.2):**
- Repository layer intentionally returns None/False for not-found/unauthorized cases (service layer handles HTTP responses)
- All 104 tests passing with 91.58% coverage after QA fixes
- Made `get_all_by_user()` limit configurable via settings.MAX_CONTEXTS_PER_USER (default: 100)

**Key Learnings from Flow Repository (Story 2.3):**
- FlowRepository injects ContextRepository dependency to validate context exists before flow creation
- Type safety: Added `# type: ignore[override]` for method signature differences (intentional design)
- Query Type Fix: Used `dict[str, object]` annotation to satisfy mypy for MongoDB query dicts
- Test Coverage: 93% coverage for flow_repository.py (exceeds 85% requirement)
- All tests pass with ruff and mypy checks

[Source: docs/stories/2.2.story.md#dev-agent-record, docs/stories/2.3.story.md#dev-agent-record]

### FastAPI Router Layer Architecture

**Router responsibilities:**
- HTTP request/response handling
- Route parameter and query parameter validation
- Request body validation (via Pydantic models)
- Authentication via dependency injection
- Authorization checks (user ownership verification)
- Status code mapping (200, 201, 204, 400, 401, 403, 404)
- Dependency injection for repository/service instances

**Service layer NOT required for this story:**
- Story 2.4 focuses on direct repository → router integration
- Service layer (FlowService with status computation) will be introduced in future stories
- For now, routers call repositories directly

[Source: docs/architecture/backend-architecture.md#router-layer-api-endpoints]

### Authentication Middleware Pattern

**Logto JWT Validation with TTL-based JWKS Caching:**
```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import jwt, JWTError
from datetime import datetime, timedelta
import httpx
from src.config import settings

security = HTTPBearer()

# JWKS cache with TTL and error handling
_jwks_cache = {"keys": None, "expires_at": None}

async def get_logto_jwks() -> dict:
    """
    Fetch and cache Logto JWKS (public keys) with 1-hour TTL.

    Security considerations:
    - TTL of 1 hour allows for JWKS rotation without app restart
    - Falls back to stale cache if fetch fails (avoids auth outage)
    - Network errors are handled gracefully

    Returns:
        dict: JWKS containing public keys

    Raises:
        HTTPException: 503 if fetch fails and no cached keys available
    """
    now = datetime.utcnow()

    # Return cached JWKS if still valid
    if _jwks_cache["keys"] and _jwks_cache["expires_at"] and now < _jwks_cache["expires_at"]:
        return _jwks_cache["keys"]

    # Fetch fresh JWKS asynchronously
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get(
                f"{settings.LOGTO_ENDPOINT}/oidc/jwks",
                timeout=5.0  # 5 second timeout
            )
            response.raise_for_status()
            jwks = response.json()

            # Update cache with 1-hour TTL
            _jwks_cache["keys"] = jwks
            _jwks_cache["expires_at"] = now + timedelta(hours=1)

            return jwks

        except (httpx.HTTPError, httpx.TimeoutException) as e:
            # If fetch fails but we have stale cache, use it
            if _jwks_cache["keys"]:
                # Log warning about stale cache usage (would use logger in production)
                print(f"WARNING: Using stale JWKS cache due to fetch error: {e}")
                return _jwks_cache["keys"]

            # No cache available - this is a critical error
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Unable to fetch authentication keys"
            )

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> str:
    """
    Validate Logto JWT token and extract user_id.

    Returns:
        str: User ID from token sub claim

    Raises:
        HTTPException: 401 if token is invalid or expired
        HTTPException: 503 if JWKS fetch fails and no cache available
    """
    token = credentials.credentials

    try:
        # Fetch JWKS asynchronously (will use cache if valid)
        jwks = await get_logto_jwks()

        # Decode and verify JWT (synchronous operation)
        payload = jwt.decode(
            token,
            key=jwks,
            algorithms=["RS256"],
            audience=settings.LOGTO_APP_ID,
            issuer=f"{settings.LOGTO_ENDPOINT}/oidc"
        )

        user_id: str = payload.get("sub")
        if not user_id:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token: missing user ID"
            )

        return user_id

    except JWTError as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"Invalid or expired token: {str(e)}"
        )
```

[Source: docs/architecture/backend-architecture.md#authentication-middleware]

### Dependency Injection Pattern

**Repository DI example:**
```python
from fastapi import Depends
from motor.motor_asyncio import AsyncIOMotorDatabase
from src.database import get_database
from src.repositories.context_repository import ContextRepository

async def get_context_repository(
    db: AsyncIOMotorDatabase = Depends(get_database)
) -> ContextRepository:
    """Dependency injection for ContextRepository."""
    return ContextRepository(db)
```

**Using in routes:**
```python
@router.get("/api/v1/contexts", response_model=list[ContextInDB])
async def list_contexts(
    user_id: str = Depends(get_current_user),
    context_repo: ContextRepository = Depends(get_context_repository)
):
    """List all contexts for the authenticated user."""
    return await context_repo.get_all_by_user(user_id)
```

[Source: docs/architecture/backend-architecture.md#router-layer-api-endpoints]

### Cascade Delete Pattern

**When deleting context, must delete all flows first using bulk delete:**
```python
@router.delete("/api/v1/contexts/{context_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_context(
    context_id: str,
    user_id: str = Depends(get_current_user),
    context_repo: ContextRepository = Depends(get_context_repository),
    flow_repo: FlowRepository = Depends(get_flow_repository)
):
    """Delete context and all associated flows."""
    # Verify context ownership
    context = await context_repo.get_by_id(context_id, user_id)
    if not context:
        raise HTTPException(status_code=404, detail="Context not found")

    # Delete all flows for context in bulk (single DB query)
    # Uses delete_many() to avoid N+1 query problem
    await flow_repo.delete_by_context_id(context_id, user_id)

    # Delete context
    deleted = await context_repo.delete(context_id, user_id)
    if not deleted:
        raise HTTPException(status_code=404, detail="Context not found")
```

**FlowRepository bulk delete method (required for cascade delete):**
```python
# In flow_repository.py
async def delete_by_context_id(self, context_id: str, user_id: str) -> int:
    """
    Delete all flows for a context in bulk (cascade delete support).

    Args:
        context_id: Context ID whose flows to delete
        user_id: User ID for ownership verification

    Returns:
        int: Number of flows deleted

    Note: This method performs a single delete_many() query instead of
    fetching flows and deleting one-by-one (avoids N+1 problem).
    """
    # Verify user owns the context (security check)
    context = await self.context_repo.get_by_id(context_id, user_id)
    if not context:
        return 0  # Context not found or user doesn't own it

    # Bulk delete all flows for this context
    result = await self.collection.delete_many({"context_id": context_id})
    return result.deleted_count
```

[Source: docs/prd/epic-2-context-flow-data-layer-with-ui-foundation.md#story-24-context-flow-rest-api-endpoints]

### API Response Models

**Use Pydantic models from Story 2.1:**
- `ContextCreate`, `ContextUpdate`, `ContextInDB` from `src/models/context.py`
- `FlowCreate`, `FlowUpdate`, `FlowInDB` from `src/models/flow.py`

**FastAPI automatically:**
- Validates request bodies against `*Create` and `*Update` schemas
- Serializes response models (`*InDB`) to JSON
- Generates OpenAPI spec with schema documentation
- Shows examples in Swagger UI (`/docs`)

[Source: docs/architecture/backend-architecture.md#pydantic-models-requestresponse-schemas]

### Error Handling Standards

**HTTP Status Codes:**
- `200 OK` - Successful GET, PUT, PATCH
- `201 Created` - Successful POST
- `204 No Content` - Successful DELETE
- `400 Bad Request` - Validation error (Pydantic)
- `401 Unauthorized` - Missing or invalid JWT token
- `403 Forbidden` - User doesn't own resource
- `404 Not Found` - Resource doesn't exist

**HTTPException examples:**
```python
# 401 Unauthorized (handled by auth middleware)
raise HTTPException(status_code=401, detail="Invalid or expired token")

# 403 Forbidden (ownership check)
if flow.user_id != user_id:
    raise HTTPException(status_code=403, detail="Access forbidden")

# 404 Not Found (resource doesn't exist)
if not context:
    raise HTTPException(status_code=404, detail="Context not found")
```

[Source: docs/architecture/15-error-handling-strategy.md#error-categories-and-status-codes]

### Project Structure Alignment

**Router files location:**
```
my_flow_api/src/routers/
├── __init__.py          # Export all routers
├── contexts.py          # Context CRUD routes (THIS STORY)
└── flows.py             # Flow CRUD routes (THIS STORY)
```

**Auth middleware location:**
```
my_flow_api/src/middleware/
├── __init__.py
└── auth.py              # get_current_user dependency (THIS STORY)
```

**Test files location:**
```
my_flow_api/tests/integration/routers/
├── __init__.py
├── test_contexts.py     # Context API tests (THIS STORY)
└── test_flows.py        # Flow API tests (THIS STORY)
```

[Source: docs/architecture/9-unified-project-structure.md#backend-structure]

### Testing Standards

**Integration Test Setup:**
```python
# tests/integration/routers/test_contexts.py
import pytest
from fastapi.testclient import TestClient
from src.main import app
from src.middleware.auth import get_current_user

# Mock auth dependency
async def override_get_current_user():
    return "test_user_id"

app.dependency_overrides[get_current_user] = override_get_current_user

@pytest.fixture
def client():
    """Provides TestClient for integration tests."""
    return TestClient(app)

@pytest.mark.asyncio
async def test_list_contexts(client):
    """Test GET /api/v1/contexts returns user's contexts."""
    response = client.get("/api/v1/contexts")
    assert response.status_code == 200
    assert isinstance(response.json(), list)
```

**Test Organization:**
- Integration tests: `tests/integration/routers/test_contexts.py`, `test_flows.py`
- Use `TestClient` from FastAPI (wraps HTTPX async client)
- Override auth dependency to inject test user_id
- Test both success and error cases (401, 403, 404)
- Use real MongoDB connection with test database cleanup

**Coverage Requirements:**
- 80% minimum coverage for router files
- Test all endpoints (GET, POST, PUT, DELETE, PATCH)
- Test authentication (401 responses)
- Test authorization (403 responses)
- Test validation errors (400 responses)

[Source: docs/architecture/13-testing-strategy.md#backend-api-integration-test]

### Python Dependencies

**Required dependencies (already in pyproject.toml from Stories 2.1-2.3):**
- `fastapi ^0.115.0` - Web framework
- `uvicorn[standard] ^0.30.0` - ASGI server
- `motor ^3.5.0` - Async MongoDB driver
- `pydantic ^2.8.0` - Data validation
- `python-jose[cryptography] ^3.3.0` - JWT validation
- `httpx ^0.27.0` - HTTP client for JWKS fetch

**Dev dependencies:**
- `pytest ^8.3.0` - Test framework
- `pytest-asyncio ^0.24.0` - Async test support
- `pytest-cov` - Coverage reporting
- `httpx` - TestClient support

[Source: docs/architecture/tech-stack.md]

### OpenAPI Documentation

**FastAPI auto-generates OpenAPI spec:**
- Swagger UI available at `/docs`
- ReDoc available at `/redoc`
- OpenAPI JSON schema at `/openapi.json`

**Ensure schemas are documented:**
- Use `response_model` parameter in route decorators
- Use `status_code` parameter for non-200 success codes
- Use `tags` parameter for grouping endpoints in docs
- Pydantic models automatically show in schema

**Example:**
```python
@router.post(
    "/api/v1/contexts",
    response_model=ContextInDB,
    status_code=status.HTTP_201_CREATED,
    tags=["Contexts"],
    summary="Create a new context",
    description="Create a new context for the authenticated user"
)
async def create_context(
    context_data: ContextCreate,
    user_id: str = Depends(get_current_user),
    context_repo: ContextRepository = Depends(get_context_repository)
):
    """Create a new context."""
    return await context_repo.create(user_id, context_data)
```

[Source: docs/architecture/api-specification.md#openapi-31-specification]

### API Specification Reference

**Context Endpoints:**
- `GET /api/v1/contexts` → List all contexts
- `POST /api/v1/contexts` → Create context
- `GET /api/v1/contexts/{context_id}` → Get single context
- `PUT /api/v1/contexts/{context_id}` → Update context
- `DELETE /api/v1/contexts/{context_id}` → Delete context

**Flow Endpoints:**
- `GET /api/v1/contexts/{context_id}/flows` → List flows for context
- `POST /api/v1/flows` → Create flow
- `GET /api/v1/flows/{flow_id}` → Get single flow
- `PUT /api/v1/flows/{flow_id}` → Update flow
- `DELETE /api/v1/flows/{flow_id}` → Delete flow
- `PATCH /api/v1/flows/{flow_id}/complete` → Mark complete

**All endpoints require `Authorization: Bearer <jwt_token>` header**

[Source: docs/architecture/api-specification.md#api-endpoints-overview]

### Type Hints and Async Patterns

**All route handlers MUST be async:**
```python
async def list_contexts(
    user_id: str = Depends(get_current_user),
    context_repo: ContextRepository = Depends(get_context_repository)
) -> list[ContextInDB]:
    ...
```

**Use FastAPI dependencies:**
- `Depends(get_current_user)` for authentication
- `Depends(get_context_repository)` for repository DI
- `Depends(get_database)` for database connection

**Type hints for responses:**
- Use `response_model` in route decorator
- Return Pydantic models directly (FastAPI auto-serializes)
- Use `list[ModelType]` for list responses

[Source: docs/architecture/coding-standards.md#naming-conventions]

### Configuration Management

**Settings required for auth:**
```python
# src/config.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # ... existing settings ...

    # Logto Authentication
    LOGTO_ENDPOINT: str  # e.g., "https://your-logto-instance.logto.app"
    LOGTO_APP_ID: str
    LOGTO_APP_SECRET: str  # Not used in JWT validation (public key from JWKS)
```

**Environment variables (.env):**
```bash
LOGTO_ENDPOINT=https://your-logto-instance.logto.app
LOGTO_APP_ID=your-app-id
LOGTO_APP_SECRET=your-app-secret
```

[Source: docs/architecture/backend-architecture.md#configuration-management]

## Testing

### Test File Locations

**Integration tests for routers:**
- `my_flow_api/tests/integration/routers/test_contexts.py` - Context API integration tests
- `my_flow_api/tests/integration/routers/test_flows.py` - Flow API integration tests

**Unit tests for middleware:**
- `my_flow_api/tests/unit/middleware/test_auth.py` - Auth middleware unit tests

### Testing Frameworks and Patterns

**Frameworks:**
- `pytest` - Test framework with async support via `pytest-asyncio`
- `fastapi.testclient.TestClient` - HTTP client for testing FastAPI routes
- `pytest-cov` - Coverage reporting
- `httpx` - Async HTTP client (used by TestClient)

**Patterns:**
- Use `TestClient(app)` to make requests to FastAPI routes
- Override auth dependency with `app.dependency_overrides[get_current_user] = mock_user`
- Use real MongoDB connection with test database (not mocks)
- Clean up test data after each test using fixtures
- Test both success cases and error cases (401, 403, 404, 400)
- Use `@pytest.mark.asyncio` for async tests

**Example test structure:**
```python
import pytest
from fastapi.testclient import TestClient
from src.main import app
from src.middleware.auth import get_current_user

# Mock auth dependency
async def override_get_current_user():
    return "test_user_id"

app.dependency_overrides[get_current_user] = override_get_current_user

@pytest.fixture
def client():
    return TestClient(app)

@pytest.mark.asyncio
async def test_create_context_success(client):
    """Test POST /api/v1/contexts creates context successfully."""
    response = client.post(
        "/api/v1/contexts",
        json={"name": "Work", "color": "#3B82F6", "icon": "💼"}
    )
    assert response.status_code == 201
    data = response.json()
    assert data["name"] == "Work"
    assert "id" in data

@pytest.mark.asyncio
async def test_create_context_invalid_color(client):
    """Test POST /api/v1/contexts returns 400 for invalid color."""
    response = client.post(
        "/api/v1/contexts",
        json={"name": "Work", "color": "invalid", "icon": "💼"}
    )
    assert response.status_code == 422  # Pydantic validation error
```

### Test Coverage Requirements

**Coverage targets:**
- 80% minimum coverage for router files (`src/routers/contexts.py`, `src/routers/flows.py`)
- 80% minimum coverage for auth middleware (`src/middleware/auth.py`)

**Coverage command:**
```bash
pytest tests/integration/routers/ -v --cov=src/routers --cov=src/middleware
```

[Source: docs/architecture/13-testing-strategy.md#test-organization]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-07 | 1.0 | Story created for Epic 2.4 | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

### Debug Log References

### Completion Notes List

### File List

## QA Results
