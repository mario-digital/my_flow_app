# Story 2.4: Context & Flow REST API Endpoints (BE)

## Status
draft

## Story

**As a** backend developer,
**I want** FastAPI REST endpoints for context and flow management,
**so that** the frontend can perform all CRUD operations via HTTP.

## Acceptance Criteria

1. **Context API routes created in `my_flow_api/src/routers/contexts.py`:**
   - `GET /api/v1/contexts` → List user's contexts (requires auth)
   - `POST /api/v1/contexts` → Create context (requires auth, validates body)
   - `GET /api/v1/contexts/{id}` → Get single context (requires auth + ownership)
   - `PUT /api/v1/contexts/{id}` → Update context (requires auth + ownership)
   - `DELETE /api/v1/contexts/{id}` → Delete context (requires auth + ownership, cascades to flows)
   - All routes use dependency injection for `ContextRepository`

2. **Flow API routes created in `my_flow_api/src/routers/flows.py`:**
   - `GET /api/v1/contexts/{context_id}/flows` → List flows for context (requires auth + ownership)
   - `POST /api/v1/flows` → Create flow (requires auth, validates context ownership)
   - `GET /api/v1/flows/{id}` → Get single flow (requires auth)
   - `PUT /api/v1/flows/{id}` → Update flow (requires auth)
   - `DELETE /api/v1/flows/{id}` → Delete flow (requires auth)
   - `PATCH /api/v1/flows/{id}/complete` → Mark complete (requires auth)
   - All routes use dependency injection for `FlowRepository`

3. **Authentication middleware enforced:**
   - All routes require valid Logto JWT token
   - `user_id` extracted from token and passed to repository methods
   - Returns 401 for missing/invalid tokens
   - Returns 403 for unauthorized access (e.g., accessing another user's context)
   - Returns 429 for rate limit exceeded (with Retry-After header)

4. **API response models use Pydantic:**
   - All endpoints return `ContextResponse` or `FlowResponse` (or lists)
   - Error responses use FastAPI HTTPException with proper status codes
   - OpenAPI docs auto-generated with full schema documentation

5. **Integration tests created in `my_flow_api/tests/integration/routers/test_contexts.py` and `test_flows.py`:**
   - Uses `TestClient` with mock authentication
   - Tests all endpoints (success cases + error cases)
   - Tests authorization (401, 403 responses)
   - Tests cascade delete (deleting context deletes flows)
   - At least 80% coverage for API routes

6. **Manual testing verified with 1Password secrets:**
   - Can run `op run -- uvicorn main:app --reload` and test all endpoints locally
   - Postman/Thunder Client collection documented in `my_flow_api/docs/api-testing.md`

## Tasks / Subtasks

- [ ] **Task 1: Create auth middleware dependency** (AC: 3)
  - [ ] Create `my_flow_api/src/middleware/auth.py`
  - [ ] Implement async `get_current_user()` dependency that validates Logto JWT
  - [ ] Extract `user_id` from token `sub` claim
  - [ ] Return 401 HTTPException for invalid/expired tokens
  - [ ] Use `python-jose` library for JWT decoding
  - [ ] Fetch Logto JWKS (public keys) from `{LOGTO_ENDPOINT}/oidc/jwks`
  - [ ] **CRITICAL: Implement async TTL-based JWKS caching with thread safety (1-hour TTL)**
    - Make `get_logto_jwks()` async function
    - Use `httpx.AsyncClient()` for async HTTP requests
    - **SECURITY FIX: Add asyncio.Lock for thread-safe cache operations**
      - Import `asyncio` and use lazy initialization for lock (avoids RuntimeError: no running event loop)
      - Create module-level `_cache_lock: asyncio.Lock | None = None`
      - Initialize lock on first use: `if _cache_lock is None: _cache_lock = asyncio.Lock()`
      - Implement double-check locking pattern: check cache → acquire lock → check again → fetch/update
      - Fast path: Return cached JWKS without lock if still valid (performance optimization)
      - Slow path: Acquire lock, double-check cache (another request may have updated), then fetch
      - Prevents race conditions where multiple requests fetch JWKS simultaneously
      - Prevents cache corruption from concurrent writes
    - Use module-level dict cache with `expires_at` timestamp
    - Refetch JWKS after TTL expires (allows JWKS rotation)
    - Add 5-second timeout to JWKS fetch
    - **SECURITY: Validate JWKS response structure before caching**
      - Check `isinstance(jwks, dict)` and `"keys" in jwks` and `jwks["keys"]` is not empty
      - Raise `ValueError("Invalid JWKS response: missing 'keys' array")` if validation fails
      - Prevents caching malformed/empty JWKS responses
    - **SECURITY: Stale cache with max age limit**
      - Fallback to stale cache if fetch fails (prevents auth outage)
      - Add `LOGTO_JWKS_MAX_STALE_SECONDS` config (default: 7200 = 2 hours)
      - Check stale cache age: `(now - _jwks_cache["cached_at"]).total_seconds() < settings.LOGTO_JWKS_MAX_STALE_SECONDS`
      - Reject stale cache if older than max age (prevents using rotated-out keys indefinitely)
      - Return 503 if stale cache too old and fetch fails
    - Return 503 error if no cache available and fetch fails
    - **CODE QUALITY: Use proper logging instead of print statements**
      - Import `logging` and create logger: `logger = logging.getLogger(__name__)`
      - Replace `print(f"WARNING: ...")` with `logger.warning("Using stale JWKS cache due to fetch error: %s", str(e))`
      - Ensures proper log levels, formatting, and integration with application logging
    - **PYTHON 3.12+: Use timezone-aware datetime instead of deprecated utcnow()**
      - Import: `from datetime import datetime, timezone, timedelta`
      - Replace `datetime.utcnow()` with `datetime.now(timezone.utc)`
      - Avoids deprecation warnings in Python 3.12+
  - [ ] In `get_current_user()`, await the async `get_logto_jwks()` call
  - [ ] Verify token signature, audience (`LOGTO_APP_ID`), issuer
  - [ ] **SECURITY: Add rate limiting to auth middleware**
    - Apply `@limiter.limit("100/minute")` decorator to `get_current_user()` function
    - Prevents brute force token attacks (100 auth attempts per minute per IP)
    - Requires adding `request: Request` parameter to `get_current_user()` signature
    - Note: Limiter will be initialized in Task 5, but add decorator in Task 1
  - [ ] **DRY: Add authorization helper functions** (REQUIRED for code quality)
    - Create `verify_context_ownership(context_id, user_id, context_repo)` helper
      - Returns `ContextInDB` if owned, raises 404 HTTPException if not found
      - Signature: `async def verify_context_ownership(context_id: str, user_id: str, context_repo: ContextRepository) -> ContextInDB`
    - Create `verify_flow_ownership(flow_id, user_id, flow_repo)` helper
      - Returns `FlowInDB` if owned, raises 404 if not found, 403 if owned by different user
      - Signature: `async def verify_flow_ownership(flow_id: str, user_id: str, flow_repo: FlowRepository) -> FlowInDB`
    - Reduces repetitive ownership checks across route handlers (DRY principle)
    - Centralizes error handling logic (404 vs 403 distinction)
    - Add to `src/middleware/auth.py` (recommended) or `src/utils/auth_helpers.py`
    - **USE THESE HELPERS** in all route handlers that need ownership verification (Tasks 3 & 4)
  - [ ] Add unit tests for `get_current_user()` with mocked JWT tokens
  - [ ] Add unit tests for JWKS caching (TTL expiry, stale cache fallback, fetch failures)
  - [ ] **CRITICAL: Add unit tests for JWKS thread safety**
    - Test concurrent cache checks/updates (simulate race conditions)
    - Verify only one JWKS fetch occurs when multiple requests hit expired cache
    - Verify cache consistency under concurrent load
    - **Implementation guide:**
      - Use `asyncio.gather()` to spawn 10 concurrent requests to expired cache
      - Mock `httpx.AsyncClient.get()` with call counter
      - Assert exactly 1 JWKS fetch call (not 10)
      - Assert all 10 requests receive same JWKS data
      - Test lazy lock initialization (first request creates lock, others wait)
  - [ ] Add unit tests for ownership helpers (if implemented)

- [ ] **Task 2: Extend repositories with count and bulk delete methods** (Prerequisites)
  - [ ] **CRITICAL DEPENDENCY: Retrofitting Stories 2.2 & 2.3 repositories**
    - Stories 2.2 (ContextRepository) and 2.3 (FlowRepository) are already implemented and tested
    - This task extends those EXISTING repositories with new methods required for Story 2.4
    - Alternative approach: Create mini-stories 2.2.1 and 2.3.1 for these extensions
    - Current approach: Modify existing repository files and add tests to existing test suites
    - **MUST verify Stories 2.2 & 2.3 are completed before starting this task**
  - [ ] **Add `count_by_user()` to ContextRepository** (for pagination metadata)
    - Method signature: `async def count_by_user(user_id: str) -> int`
    - Use `collection.count_documents({"user_id": user_id})`
    - Return total count of contexts for user
    - Add to `my_flow_api/src/repositories/context_repository.py`
  - [ ] **Update `get_all_by_user()` signature in ContextRepository** (add pagination)
    - Current signature from Story 2.2: `async def get_all_by_user(user_id: str) -> list[ContextInDB]`
    - **NEW signature:** `async def get_all_by_user(user_id: str, limit: int = 50, offset: int = 0) -> list[ContextInDB]`
    - Add `.skip(offset).limit(limit)` to MongoDB query
    - Default limit=50 protects against large queries
  - [ ] **Add `count_by_context()` to FlowRepository** (for pagination metadata)
    - Method signature: `async def count_by_context(context_id: str, include_completed: bool = False) -> int`
    - Build query: `{"context_id": context_id}` with optional `"is_completed": False` filter
    - Use `collection.count_documents(query)`
    - Return total count of flows for context
    - Add to `my_flow_api/src/repositories/flow_repository.py`
  - [ ] **Update `get_all_by_context()` signature in FlowRepository** (add pagination)
    - Current signature from Story 2.3: `async def get_all_by_context(context_id: str, include_completed: bool = False) -> list[FlowInDB]`
    - **NEW signature:** `async def get_all_by_context(context_id: str, include_completed: bool = False, limit: int = 50, offset: int = 0) -> list[FlowInDB]`
    - Add `.skip(offset).limit(limit)` to MongoDB query
    - Default limit=50 protects against large queries
  - [ ] **Add `delete_by_context_id()` to FlowRepository** (for cascade delete)
    - Method signature: `async def delete_by_context_id(context_id: str, user_id: str) -> int`
    - Verify user owns the context using `context_repo.get_by_id(context_id, user_id)`
    - Return 0 if context not found or user doesn't own it (security check)
    - Use `delete_many({"context_id": context_id})` for bulk delete (single query)
    - Return count of deleted flows (`result.deleted_count`)
  - [ ] **Why these are needed:**
    - Count methods: Enable pagination metadata (total, has_more) for UI
    - Bulk delete: Avoids N+1 query problem (100 flows = 101 queries → 2 queries)
  - [ ] Add unit tests for all three methods:
    - Test `count_by_user()` with 0, 1, 100 contexts
    - Test `count_by_context()` with include_completed filter
    - Test `delete_by_context_id()` bulk delete and ownership verification
  - [ ] Update Story 2.2/2.3 implementations if needed (or document as Story 2.4 extensions)

- [ ] **Task 3: Create Context API router** (AC: 1, 3, 4)
  - [ ] Create `my_flow_api/src/routers/contexts.py`
  - [ ] Create `my_flow_api/src/models/pagination.py` with `PaginatedResponse` model
  - [ ] Create `get_context_repository()` dependency for DI
  - [ ] Implement `GET /api/v1/contexts` - List contexts with pagination metadata
    - Use `Depends(get_current_user)` to get `user_id`
    - Add pagination query params: `limit: int = Query(default=50, ge=1, le=100)`, `offset: int = Query(default=0, ge=0, le=10000)`
    - **VALIDATION:** `ge=1` prevents limit=0 (empty results), `le=10000` prevents excessive offset (performance protection)
    - Call `context_repo.count_by_user(user_id)` for total count (from Task 2)
    - Call `context_repo.get_all_by_user(user_id, limit=limit, offset=offset)` for items
    - Return `PaginatedResponse[ContextInDB]` with `items`, `total`, `limit`, `offset`, `has_more`
    - Note: Pagination metadata enables "Page X of Y" UI components
  - [ ] Implement `POST /api/v1/contexts` - Create context
    - Accept `ContextCreate` request body
    - Use `Depends(get_current_user)` to get `user_id`
    - Call `context_repo.create(user_id, context_data)`
    - Return `ContextInDB` with `status_code=201`
  - [ ] Implement `GET /api/v1/contexts/{context_id}` - Get single context
    - Use `Depends(get_current_user)` to get `user_id`
    - Call `context_repo.get_by_id(context_id, user_id)`
    - Return 404 if context not found or unauthorized
    - Return `ContextInDB`
  - [ ] Implement `PUT /api/v1/contexts/{context_id}` - Update context
    - Accept `ContextUpdate` request body
    - Use `Depends(get_current_user)` to get `user_id`
    - Call `context_repo.update(context_id, user_id, updates)`
    - Return 404 if context not found or unauthorized
    - Return `ContextInDB`
  - [ ] Implement `DELETE /api/v1/contexts/{context_id}` - Delete context with cascade
    - Use `Depends(get_current_user)` to get `user_id`
    - Verify context ownership with `context_repo.get_by_id(context_id, user_id)`
    - **First delete all flows in bulk** using `flow_repo.delete_by_context_id(context_id, user_id)` (from Task 2)
    - Then delete context using `context_repo.delete(context_id, user_id)`
    - Return 404 if context not found or unauthorized
    - Return `status_code=204` (no content)
    - **Note:** Requires `delete_by_context_id()` from Task 2 to be implemented first
  - [ ] Export router via `my_flow_api/src/routers/__init__.py`

- [ ] **Task 4: Create Flow API router** (AC: 2, 3, 4)
  - [ ] Create `my_flow_api/src/routers/flows.py`
  - [ ] Create `get_flow_repository()` and `get_context_repository()` dependencies for DI
  - [ ] Implement `GET /api/v1/contexts/{context_id}/flows` - List flows with pagination metadata
    - Use `Depends(get_current_user)` to get `user_id`
    - Verify context ownership using `context_repo.get_by_id(context_id, user_id)`
    - Return 403 if user doesn't own context
    - Add pagination query params: `limit: int = Query(default=50, ge=1, le=100)`, `offset: int = Query(default=0, ge=0, le=10000)`
    - **VALIDATION:** `ge=1` prevents limit=0 (empty results), `le=10000` prevents excessive offset (performance protection)
    - Support optional query param `include_completed: bool = Query(default=False)`
    - Call `flow_repo.count_by_context(context_id, include_completed)` for total count (from Task 2)
    - Call `flow_repo.get_all_by_context(context_id, include_completed, limit, offset)` for items
    - Return `PaginatedResponse[FlowInDB]` with `items`, `total`, `limit`, `offset`, `has_more`
    - Note: Metadata enables progress indicators like "Showing 1-50 of 150 flows"
  - [ ] Implement `POST /api/v1/flows` - Create flow
    - Accept `FlowCreate` request body
    - Use `Depends(get_current_user)` to get `user_id`
    - Verify context ownership using `context_repo.get_by_id(context_id, user_id)`
    - Return 403 if user doesn't own context
    - Call `flow_repo.create(context_id, flow_data)`
    - Return `FlowInDB` with `status_code=201`
  - [ ] Implement `GET /api/v1/flows/{flow_id}` - Get single flow
    - Use `Depends(get_current_user)` to get `user_id`
    - **USE HELPER:** `flow = await verify_flow_ownership(flow_id, user_id, flow_repo)` (from Task 1)
    - Return `FlowInDB`
  - [ ] Implement `PUT /api/v1/flows/{flow_id}` - Update flow
    - Accept `FlowUpdate` request body
    - Use `Depends(get_current_user)` to get `user_id`
    - **USE HELPER:** `await verify_flow_ownership(flow_id, user_id, flow_repo)` (from Task 1)
    - Call `flow_repo.update(flow_id, updates)`
    - Return `FlowInDB`
  - [ ] Implement `DELETE /api/v1/flows/{flow_id}` - Delete flow
    - Use `Depends(get_current_user)` to get `user_id`
    - **USE HELPER:** `await verify_flow_ownership(flow_id, user_id, flow_repo)` (from Task 1)
    - Call `flow_repo.delete(flow_id)`
    - Return `status_code=204`
  - [ ] Implement `PATCH /api/v1/flows/{flow_id}/complete` - Mark complete
    - Use `Depends(get_current_user)` to get `user_id`
    - **USE HELPER:** `await verify_flow_ownership(flow_id, user_id, flow_repo)` (from Task 1)
    - Call `flow_repo.mark_complete(flow_id)`
    - Return `FlowInDB`
  - [ ] Export router via `my_flow_api/src/routers/__init__.py`

- [ ] **Task 5: Register routers and configure security middleware** (AC: 1, 2)
  - [ ] Update `my_flow_api/src/main.py`
  - [ ] Import `contexts` and `flows` routers
  - [ ] Register routers with prefix `/api/v1`
  - [ ] Add tags for OpenAPI organization (`tags=["Contexts"]`, `tags=["Flows"]`)
  - [ ] **SECURITY: Configure HTTPS enforcement middleware (production only)**
    - Add `HTTPSRedirectMiddleware` when `settings.ENVIRONMENT == "production"`
    - Redirects all HTTP requests to HTTPS (prevents man-in-the-middle attacks)
    - Skip in development/testing environments
  - [ ] **SECURITY: Configure CORS with strict validation**
    - Add `CORSMiddleware` with explicit `allow_origins` list from `settings.CORS_ORIGINS`
    - **NEVER use `allow_origins=["*"]` in production** (security vulnerability)
    - Use environment-specific origins: dev=["http://localhost:3000"], prod=["https://app.example.com"]
    - Set `allow_credentials=True` (required for JWT cookies/headers)
    - Set `allow_methods=["GET", "POST", "PUT", "DELETE", "PATCH"]`
    - Set `allow_headers=["Authorization", "Content-Type"]`
  - [ ] **Configure rate limiting with slowapi:**
    - Install slowapi: `slowapi = "^0.1.9"` in pyproject.toml
    - Initialize Limiter in main.py: `limiter = Limiter(key_func=get_remote_address)`
    - Add rate limit exception handler for 429 responses with proper format
    - Handler must return: `{"detail": "Rate limit exceeded", "retry_after": 60}`
    - Include `Retry-After` header in response (seconds until limit resets)
    - Set `app.state.limiter = limiter`
    - Register exception handler: `app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)`
  - [ ] **Add rate limits to router endpoints:**
    - POST /api/v1/contexts: `@limiter.limit("10/minute")`
    - POST /api/v1/flows: `@limiter.limit("30/minute")`
    - GET endpoints: `@limiter.limit("60/minute")`
    - PUT/DELETE endpoints: `@limiter.limit("30/minute")`
    - Add `request: Request` parameter to all rate-limited endpoints
  - [ ] **Document 429 error response in OpenAPI schema:**
    - Add `responses={429: {"model": RateLimitError}}` to route decorators
    - Create Pydantic model for 429 response format
    - Ensure Swagger UI shows 429 response with example
  - [ ] Verify FastAPI auto-generates OpenAPI docs at `/docs` (Swagger UI)
  - [ ] Verify all endpoints show correct request/response schemas including 429

- [ ] **Task 6: Verify database indexes for query performance** (AC: 1, 2)
  - [ ] Create or update `my_flow_api/src/database.py` with index verification
  - [ ] Add `ensure_indexes()` async function
  - [ ] Create indexes for Context queries:
    - `db.contexts.create_index([("user_id", 1)])` - Basic user lookup
    - `db.contexts.create_index([("user_id", 1), ("created_at", -1)])` - Ordered pagination
  - [ ] Create indexes for Flow queries:
    - `db.flows.create_index([("context_id", 1)])` - Basic context lookup
    - `db.flows.create_index([("user_id", 1)])` - User-level flow queries
    - `db.flows.create_index([("context_id", 1), ("is_completed", 1)])` - Filtering by completion
    - `db.flows.create_index([("context_id", 1), ("created_at", -1)])` - **Ordered pagination (CRITICAL)**
    - `db.flows.create_index([("context_id", 1), ("is_completed", 1), ("priority", 1)])` - **Multi-field sorting**
    - **CRITICAL:** `db.flows.create_index([("context_id", 1), ("user_id", 1), ("is_completed", 1), ("created_at", -1)])` - **Compound index for paginated ownership queries**
      - Supports queries filtering by context_id + user_id + is_completed + ordering by created_at
      - Without this index, paginated flow queries will do full collection scans
      - Covers the most common query pattern in GET /api/v1/contexts/{context_id}/flows
  - [ ] Call `ensure_indexes()` during app startup (in lifespan or startup event)
  - [ ] Indexes should be idempotent (safe to run multiple times)
  - [ ] Log index creation for debugging
  - [ ] Verify indexes exist with `db.contexts.index_information()` in tests

- [ ] **Task 7: Write integration tests for Context API** (AC: 5)
  - [ ] Create `my_flow_api/tests/integration/routers/test_contexts.py`
  - [ ] Create fixture for `TestClient` with mock auth dependency override
  - [ ] Create fixture for test database with cleanup
  - [ ] Test `GET /api/v1/contexts` - Returns user's contexts
  - [ ] Test `GET /api/v1/contexts` - Returns 401 without auth token
  - [ ] **Test `GET /api/v1/contexts` - Pagination edge cases**
    - Test limit=0 returns 422 (validation error, ge=1 violated)
    - Test limit=101 returns 422 (validation error, le=100 violated)
    - Test offset=-1 returns 422 (validation error, ge=0 violated)
    - Test offset=10001 returns 422 (validation error, le=10000 violated)
    - Test limit=1 returns exactly 1 item (boundary test)
    - Test offset beyond total (returns empty list, no error)
  - [ ] Test `POST /api/v1/contexts` - Creates context successfully
  - [ ] Test `POST /api/v1/contexts` - Returns 400 for invalid color format
  - [ ] Test `POST /api/v1/contexts` - Returns 401 without auth token
  - [ ] Test `GET /api/v1/contexts/{id}` - Returns context if owned
  - [ ] Test `GET /api/v1/contexts/{id}` - Returns 403 if not owned
  - [ ] Test `GET /api/v1/contexts/{id}` - Returns 404 if context doesn't exist
  - [ ] Test `PUT /api/v1/contexts/{id}` - Updates context if owned
  - [ ] Test `PUT /api/v1/contexts/{id}` - Returns 403 if not owned
  - [ ] Test `DELETE /api/v1/contexts/{id}` - Deletes context and cascades to flows in bulk
    - Create context with 10 flows
    - Delete context
    - Verify all 10 flows deleted (single delete_many query)
    - Verify context deleted
  - [ ] Test `DELETE /api/v1/contexts/{id}` - Returns 403 if not owned
  - [ ] Test `delete_by_context_id()` bulk delete method efficiency
    - Create context with 100 flows
    - Time the delete operation
    - Verify only 2 DB queries (1 for verification, 1 for delete_many)
  - [ ] Ensure 80%+ coverage for contexts.py router

- [ ] **Task 8: Write integration tests for Flow API** (AC: 5)
  - [ ] Create `my_flow_api/tests/integration/routers/test_flows.py`
  - [ ] Reuse fixtures from `test_contexts.py` (TestClient, test DB)
  - [ ] Create fixture for test context and flows
  - [ ] Test `GET /api/v1/contexts/{context_id}/flows` - Lists flows for context
  - [ ] Test `GET /api/v1/contexts/{context_id}/flows` - Returns 403 if context not owned
  - [ ] **Test `GET /api/v1/contexts/{context_id}/flows` - Pagination edge cases**
    - Test limit=0 returns 422 (validation error, ge=1 violated)
    - Test limit=101 returns 422 (validation error, le=100 violated)
    - Test offset=-1 returns 422 (validation error, ge=0 violated)
    - Test offset=10001 returns 422 (validation error, le=10000 violated)
  - [ ] Test `GET /api/v1/contexts/{context_id}/flows` - Filters by `include_completed` param
  - [ ] Test `POST /api/v1/flows` - Creates flow successfully
  - [ ] Test `POST /api/v1/flows` - Returns 403 if context not owned
  - [ ] Test `POST /api/v1/flows` - Returns 400 for invalid priority
  - [ ] Test `GET /api/v1/flows/{id}` - Returns flow if owned
  - [ ] Test `GET /api/v1/flows/{id}` - Returns 403 if not owned
  - [ ] Test `PUT /api/v1/flows/{id}` - Updates flow if owned
  - [ ] Test `PUT /api/v1/flows/{id}` - Returns 403 if not owned
  - [ ] Test `DELETE /api/v1/flows/{id}` - Deletes flow if owned
  - [ ] Test `DELETE /api/v1/flows/{id}` - Returns 403 if not owned
  - [ ] Test `PATCH /api/v1/flows/{id}/complete` - Marks flow complete
  - [ ] Test `PATCH /api/v1/flows/{id}/complete` - Returns 404 if already complete
  - [ ] Test `PATCH /api/v1/flows/{id}/complete` - Returns 403 if not owned
  - [ ] Ensure 80%+ coverage for flows.py router

- [ ] **Task 9: Create API testing documentation** (AC: 6)
  - [ ] Create `my_flow_api/docs/api-testing.md`
  - [ ] Document how to run API locally with 1Password: `op run -- uvicorn src.main:app --reload`
  - [ ] Include example Postman/Thunder Client collection JSON
  - [ ] Document example cURL commands for each endpoint with sample auth tokens
  - [ ] Document how to get Logto JWT token for local testing
  - [ ] Include example request/response payloads for all endpoints

- [ ] **Task 10: Run tests and verify coverage** (AC: 5)
  - [ ] Run pytest: `pytest tests/integration/routers/ -v --cov=src/routers`
  - [ ] Verify 80%+ coverage threshold met for routers
  - [ ] Fix any failing tests or edge cases discovered
  - [ ] Verify all routes work with FastAPI TestClient
  - [ ] Verify OpenAPI docs at `/docs` show all endpoints correctly

## Dev Notes

### Previous Story Insights (Story 2.2 & 2.3)

**Key Learnings from Context Repository (Story 2.2):**
- Repository layer intentionally returns None/False for not-found/unauthorized cases (service layer handles HTTP responses)
- All 104 tests passing with 91.58% coverage after QA fixes
- Made `get_all_by_user()` limit configurable via settings.MAX_CONTEXTS_PER_USER (default: 100)

**Key Learnings from Flow Repository (Story 2.3):**
- FlowRepository injects ContextRepository dependency to validate context exists before flow creation
- Type safety: Added `# type: ignore[override]` for method signature differences (intentional design)
- Query Type Fix: Used `dict[str, object]` annotation to satisfy mypy for MongoDB query dicts
- Test Coverage: 93% coverage for flow_repository.py (exceeds 85% requirement)
- All tests pass with ruff and mypy checks

[Source: docs/stories/2.2.story.md#dev-agent-record, docs/stories/2.3.story.md#dev-agent-record]

### FastAPI Router Layer Architecture

**Router responsibilities:**
- HTTP request/response handling
- Route parameter and query parameter validation
- Request body validation (via Pydantic models)
- Authentication via dependency injection
- Authorization checks (user ownership verification)
- Status code mapping (200, 201, 204, 400, 401, 403, 404)
- Dependency injection for repository/service instances

**Service layer NOT required for this story:**
- Story 2.4 focuses on direct repository → router integration
- Service layer (FlowService with status computation) will be introduced in future stories
- For now, routers call repositories directly

[Source: docs/architecture/backend-architecture.md#router-layer-api-endpoints]

### Authentication Middleware Pattern

**Logto JWT Validation with TTL-based JWKS Caching (THREAD-SAFE VERSION):**
```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import jwt, JWTError
from datetime import datetime, timezone, timedelta
import asyncio
import logging
import httpx
from src.config import settings

security = HTTPBearer()
logger = logging.getLogger(__name__)

# JWKS cache with TTL, error handling, thread safety, and max stale age
_jwks_cache = {"keys": None, "expires_at": None, "cached_at": None}
_cache_lock: asyncio.Lock | None = None

async def get_logto_jwks() -> dict:
    """
    Fetch and cache Logto JWKS (public keys) with 1-hour TTL.

    Security considerations:
    - Thread-safe with asyncio.Lock to prevent race conditions
    - Lazy lock initialization to avoid RuntimeError at module load
    - TTL of 1 hour allows for JWKS rotation without app restart
    - Falls back to stale cache if fetch fails (avoids auth outage)
    - Max stale age of 2 hours prevents using rotated-out keys indefinitely
    - Validates JWKS structure before caching
    - Network errors are handled gracefully

    Returns:
        dict: JWKS containing public keys

    Raises:
        HTTPException: 503 if fetch fails and no cached keys available or stale cache too old
    """
    global _cache_lock

    # Lazy initialization of lock (avoids RuntimeError: no running event loop)
    if _cache_lock is None:
        _cache_lock = asyncio.Lock()

    now = datetime.now(timezone.utc)

    # Fast path: Return cached JWKS if still valid (no lock needed)
    if _jwks_cache["keys"] and _jwks_cache["expires_at"] and now < _jwks_cache["expires_at"]:
        return _jwks_cache["keys"]

    # Slow path: Acquire lock for cache update
    async with _cache_lock:
        # Double-check after acquiring lock (another request may have updated)
        if _jwks_cache["keys"] and _jwks_cache["expires_at"] and now < _jwks_cache["expires_at"]:
            return _jwks_cache["keys"]

        # Fetch fresh JWKS asynchronously
        async with httpx.AsyncClient() as client:
            try:
                response = await client.get(
                    f"{settings.LOGTO_ENDPOINT}/oidc/jwks",
                    timeout=5.0  # 5 second timeout
                )
                response.raise_for_status()
                jwks = response.json()

                # Validate JWKS structure before caching
                if not isinstance(jwks, dict) or "keys" not in jwks or not jwks["keys"]:
                    raise ValueError("Invalid JWKS response: missing 'keys' array")

                # Update cache with 1-hour TTL
                _jwks_cache["keys"] = jwks
                _jwks_cache["expires_at"] = now + timedelta(hours=1)
                _jwks_cache["cached_at"] = now

                return jwks

            except (httpx.HTTPError, httpx.TimeoutException) as e:
                # If fetch fails but we have stale cache, check if it's not too old
                if _jwks_cache["keys"] and _jwks_cache["cached_at"]:
                    stale_age = (now - _jwks_cache["cached_at"]).total_seconds()
                    max_stale = settings.LOGTO_JWKS_MAX_STALE_SECONDS  # Default: 7200 (2 hours)

                    if stale_age < max_stale:
                        logger.warning(
                            "Using stale JWKS cache (age: %.0f seconds) due to fetch error: %s",
                            stale_age, str(e)
                        )
                        return _jwks_cache["keys"]
                    else:
                        logger.error(
                            "Stale JWKS cache too old (age: %.0f seconds, max: %d seconds). Rejecting.",
                            stale_age, max_stale
                        )

                # No cache available or stale cache too old - this is a critical error
                raise HTTPException(
                    status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                    detail="Unable to fetch authentication keys"
                )

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> str:
    """
    Validate Logto JWT token and extract user_id.

    Returns:
        str: User ID from token sub claim

    Raises:
        HTTPException: 401 if token is invalid or expired
        HTTPException: 503 if JWKS fetch fails and no cache available
    """
    token = credentials.credentials

    try:
        # Fetch JWKS asynchronously (will use cache if valid)
        jwks = await get_logto_jwks()

        # Decode and verify JWT (synchronous operation)
        payload = jwt.decode(
            token,
            key=jwks,
            algorithms=["RS256"],
            audience=settings.LOGTO_APP_ID,
            issuer=f"{settings.LOGTO_ENDPOINT}/oidc",
            options={
                "verify_signature": True,
                "verify_aud": True,
                "verify_iat": True,
                "verify_exp": True,
                "verify_nbf": True,
                "verify_iss": True,
                "require_aud": True,
                "require_iat": True,
                "require_exp": True,
                "require_nbf": False,  # nbf is optional in Logto tokens
            }
        )

        user_id: str = payload.get("sub")
        if not user_id:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token: missing user ID"
            )

        return user_id

    except JWTError as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"Invalid or expired token: {str(e)}"
        )
```

[Source: docs/architecture/backend-architecture.md#authentication-middleware]

### Authorization Helper Pattern (DRY)

**Reusable ownership verification helpers to avoid code duplication:**
```python
# In src/middleware/auth.py or src/utils/auth_helpers.py

async def verify_context_ownership(
    context_id: str,
    user_id: str,
    context_repo: ContextRepository
) -> ContextInDB:
    """
    Verify user owns the context and return it.

    Args:
        context_id: Context ID to verify
        user_id: Current user ID from JWT
        context_repo: ContextRepository instance

    Returns:
        ContextInDB: The context if owned by user

    Raises:
        HTTPException: 404 if context not found or not owned by user
    """
    context = await context_repo.get_by_id(context_id, user_id)
    if not context:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Context not found"
        )
    return context


async def verify_flow_ownership(
    flow_id: str,
    user_id: str,
    flow_repo: FlowRepository
) -> FlowInDB:
    """
    Verify user owns the flow and return it.

    Args:
        flow_id: Flow ID to verify
        user_id: Current user ID from JWT
        flow_repo: FlowRepository instance

    Returns:
        FlowInDB: The flow if owned by user

    Raises:
        HTTPException: 404 if flow not found, 403 if not owned by user
    """
    flow = await flow_repo.get_by_id(flow_id)
    if not flow:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Flow not found"
        )

    if flow.user_id != user_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access forbidden"
        )

    return flow
```

**Usage in routes (reduces duplication):**
```python
# Before (repetitive):
@router.put("/api/v1/flows/{flow_id}")
async def update_flow(
    flow_id: str,
    updates: FlowUpdate,
    user_id: str = Depends(get_current_user),
    flow_repo: FlowRepository = Depends(get_flow_repository)
):
    flow = await flow_repo.get_by_id(flow_id)
    if not flow:
        raise HTTPException(status_code=404, detail="Flow not found")
    if flow.user_id != user_id:
        raise HTTPException(status_code=403, detail="Access forbidden")

    return await flow_repo.update(flow_id, updates)

# After (DRY with helper):
@router.put("/api/v1/flows/{flow_id}")
async def update_flow(
    flow_id: str,
    updates: FlowUpdate,
    user_id: str = Depends(get_current_user),
    flow_repo: FlowRepository = Depends(get_flow_repository)
):
    # Single line ownership verification
    await verify_flow_ownership(flow_id, user_id, flow_repo)
    return await flow_repo.update(flow_id, updates)
```

**Benefits:**
- DRY: Ownership checks in one place
- Consistent error responses (404 vs 403)
- Easier to add logging/metrics to all auth checks
- Simpler route handlers focus on business logic

[Source: docs/architecture/backend-architecture.md#authentication-middleware]

### Dependency Injection Pattern

**Repository DI example:**
```python
from fastapi import Depends
from motor.motor_asyncio import AsyncIOMotorDatabase
from src.database import get_database
from src.repositories.context_repository import ContextRepository

async def get_context_repository(
    db: AsyncIOMotorDatabase = Depends(get_database)
) -> ContextRepository:
    """Dependency injection for ContextRepository."""
    return ContextRepository(db)
```

**Using in routes:**
```python
@router.get("/api/v1/contexts", response_model=list[ContextInDB])
async def list_contexts(
    user_id: str = Depends(get_current_user),
    context_repo: ContextRepository = Depends(get_context_repository)
):
    """List all contexts for the authenticated user."""
    return await context_repo.get_all_by_user(user_id)
```

[Source: docs/architecture/backend-architecture.md#router-layer-api-endpoints]

### Cascade Delete Pattern

**When deleting context, must delete all flows first using bulk delete:**
```python
@router.delete("/api/v1/contexts/{context_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_context(
    context_id: str,
    user_id: str = Depends(get_current_user),
    context_repo: ContextRepository = Depends(get_context_repository),
    flow_repo: FlowRepository = Depends(get_flow_repository)
):
    """Delete context and all associated flows."""
    # Verify context ownership
    context = await context_repo.get_by_id(context_id, user_id)
    if not context:
        raise HTTPException(status_code=404, detail="Context not found")

    # Delete all flows for context in bulk (single DB query)
    # Uses delete_many() to avoid N+1 query problem
    await flow_repo.delete_by_context_id(context_id, user_id)

    # Delete context
    deleted = await context_repo.delete(context_id, user_id)
    if not deleted:
        raise HTTPException(status_code=404, detail="Context not found")
```

**FlowRepository bulk delete method (required for cascade delete):**
```python
# In flow_repository.py
async def delete_by_context_id(self, context_id: str, user_id: str) -> int:
    """
    Delete all flows for a context in bulk (cascade delete support).

    Args:
        context_id: Context ID whose flows to delete
        user_id: User ID for ownership verification

    Returns:
        int: Number of flows deleted

    Note: This method performs a single delete_many() query instead of
    fetching flows and deleting one-by-one (avoids N+1 problem).
    """
    # Verify user owns the context (security check)
    context = await self.context_repo.get_by_id(context_id, user_id)
    if not context:
        return 0  # Context not found or user doesn't own it

    # Bulk delete all flows for this context
    result = await self.collection.delete_many({"context_id": context_id})
    return result.deleted_count
```

[Source: docs/prd/epic-2-context-flow-data-layer-with-ui-foundation.md#story-24-context-flow-rest-api-endpoints]

### Pagination Pattern for List Endpoints

**Why pagination is needed:**
- Improves frontend loading performance
- Reduces API response times
- Lowers memory usage on client and server
- Allows incremental loading with "Load More" UI pattern

**Pagination Response Model with Metadata:**
```python
# In models/pagination.py
from pydantic import BaseModel, Field
from typing import TypeVar, Generic

T = TypeVar('T')

class PaginatedResponse(BaseModel, Generic[T]):
    """Paginated response with metadata for UI components."""
    items: list[T] = Field(..., description="List of items for current page")
    total: int = Field(..., description="Total count of all items")
    limit: int = Field(..., description="Max items per page")
    offset: int = Field(..., description="Number of items skipped")
    has_more: bool = Field(..., description="True if more items available")

    class Config:
        json_schema_extra = {
            "example": {
                "items": [],
                "total": 150,
                "limit": 50,
                "offset": 0,
                "has_more": True
            }
        }
```

**Pagination for contexts list:**
```python
from fastapi import Query
from models.pagination import PaginatedResponse

@router.get("/api/v1/contexts", response_model=PaginatedResponse[ContextInDB])
async def list_contexts(
    user_id: str = Depends(get_current_user),
    context_repo: ContextRepository = Depends(get_context_repository),
    limit: int = Query(default=50, le=100, description="Max items per page"),
    offset: int = Query(default=0, ge=0, description="Number of items to skip")
):
    """List contexts with pagination metadata."""
    # Get total count for metadata
    total = await context_repo.count_by_user(user_id)

    # Get paginated items
    contexts = await context_repo.get_all_by_user(user_id, limit=limit, offset=offset)

    return PaginatedResponse(
        items=contexts,
        total=total,
        limit=limit,
        offset=offset,
        has_more=(offset + len(contexts)) < total
    )
```

**Pagination for flows list:**
```python
@router.get("/api/v1/contexts/{context_id}/flows", response_model=PaginatedResponse[FlowInDB])
async def list_flows(
    context_id: str,
    user_id: str = Depends(get_current_user),
    context_repo: ContextRepository = Depends(get_context_repository),
    flow_repo: FlowRepository = Depends(get_flow_repository),
    include_completed: bool = Query(default=False),
    limit: int = Query(default=50, le=100),
    offset: int = Query(default=0, ge=0)
):
    """List flows for context with pagination metadata."""
    # Verify ownership
    await verify_context_ownership(context_id, user_id, context_repo)

    # Get total count for metadata
    total = await flow_repo.count_by_context(context_id, include_completed=include_completed)

    # Fetch flows with pagination
    flows = await flow_repo.get_all_by_context(
        context_id,
        include_completed=include_completed,
        limit=limit,
        offset=offset
    )

    return PaginatedResponse(
        items=flows,
        total=total,
        limit=limit,
        offset=offset,
        has_more=(offset + len(flows)) < total
    )
```

**Example Paginated Response:**
```json
{
  "items": [
    {
      "id": "507f1f77bcf86cd799439012",
      "title": "Review Q4 budget",
      "priority": "high",
      ...
    }
  ],
  "total": 150,
  "limit": 50,
  "offset": 0,
  "has_more": true
}
```

**Repository changes needed:**
- Update `get_all_by_user(user_id, limit=50, offset=0)` signature
- Update `get_all_by_context(context_id, include_completed, limit=50, offset=0)` signature
- **Add `count_by_user(user_id)` method to ContextRepository**
- **Add `count_by_context(context_id, include_completed)` method to FlowRepository**
- Use MongoDB `.skip(offset).limit(limit)` for pagination
- Use MongoDB `.count_documents(query)` for total counts

**Benefits:**
- Default 50 items protects against accidental large queries
- Max 100 items prevents memory exhaustion
- Frontend can implement infinite scroll or "Load More" button
- **UI can show "Page X of Y" indicators**
- **UI can show progress bars (e.g., "Showing 1-50 of 150")**
- **has_more flag enables "Load More" button visibility**
- **total count enables pagination component rendering**

[Source: docs/architecture/api-specification.md#query-parameters-for-filtering]

### Database Index Verification

**Why index verification is critical:**
- Ensures optimal query performance from day one
- Prevents slow queries as data grows
- Indexes support pagination, filtering, and sorting

**Index creation during app startup:**
```python
# In src/database.py

async def ensure_indexes():
    """
    Ensure database indexes exist for optimal query performance.

    This function is idempotent - safe to run multiple times.
    MongoDB will skip index creation if it already exists.

    Index design principles:
    - Leftmost prefix rule: query fields must match index prefix
    - Composite indexes support multiple query patterns
    - Descending (-1) for reverse chronological ordering
    """
    db = db_instance.db

    # Context collection indexes
    # Supports: get_all_by_user() basic queries
    await db.contexts.create_index([("user_id", 1)])

    # Supports: get_all_by_user() with ORDER BY created_at DESC (pagination)
    # Critical for paginated queries with skip/limit
    await db.contexts.create_index([("user_id", 1), ("created_at", -1)])

    # Flow collection indexes
    # Supports: get_all_by_context() basic queries
    await db.flows.create_index([("context_id", 1)])

    # Supports: user-level flow queries
    await db.flows.create_index([("user_id", 1)])

    # Supports: get_all_by_context() with is_completed filter
    await db.flows.create_index([("context_id", 1), ("is_completed", 1)])

    # CRITICAL: Supports paginated queries with ORDER BY created_at DESC
    # Without this, pagination with .skip() causes full collection scans
    await db.flows.create_index([("context_id", 1), ("created_at", -1)])

    # Supports: multi-field sorting (filter by completion, sort by priority)
    # Example: get incomplete flows ordered by priority
    await db.flows.create_index([("context_id", 1), ("is_completed", 1), ("priority", 1)])

    print("✅ Database indexes verified (7 indexes created)")

# In src/main.py lifespan
@asynccontextmanager
async def lifespan(app: FastAPI):
    """Startup and shutdown events."""
    # Startup
    await connect_to_mongo()
    await ensure_indexes()  # Verify indexes on startup
    print("✅ Connected to MongoDB with indexes")

    yield

    # Shutdown
    await close_mongo_connection()
    print("✅ Closed MongoDB connection")
```

**Index verification in tests:**
```python
# In tests/integration/test_database.py
async def test_indexes_exist():
    """Verify all required indexes exist."""
    db = await get_database()

    # Check context indexes (2 total)
    context_indexes = await db.contexts.index_information()
    assert "user_id_1" in context_indexes  # Basic lookup
    assert "user_id_1_created_at_-1" in context_indexes  # Ordered pagination

    # Check flow indexes (5 total)
    flow_indexes = await db.flows.index_information()
    assert "context_id_1" in flow_indexes  # Basic lookup
    assert "user_id_1" in flow_indexes  # User-level queries
    assert "context_id_1_is_completed_1" in flow_indexes  # Completion filter
    assert "context_id_1_created_at_-1" in flow_indexes  # CRITICAL: Ordered pagination
    assert "context_id_1_is_completed_1_priority_1" in flow_indexes  # Multi-field sort

async def test_pagination_uses_index():
    """Verify paginated queries use indexes (no full scans)."""
    db = await get_database()

    # Enable profiling to check query plans
    await db.command("profile", 2)

    # Run paginated query
    flows = await db.flows.find({"context_id": "test_id"}) \
        .sort("created_at", -1) \
        .skip(50) \
        .limit(50) \
        .to_list(length=None)

    # Check query used index (not COLLSCAN)
    profile = await db.system.profile.find_one(
        {"ns": "myflow_db.flows", "command.find": "flows"}
    )
    assert profile["planSummary"].startswith("IXSCAN"), \
        "Pagination query should use index, not COLLSCAN"
```

**Performance impact:**
- **Without indexes:** O(n) table scans - every pagination query scans entire collection
- **With indexes:** O(log n) lookups - uses B-tree index for instant access
- **Critical for pagination:** `.skip(offset)` without index scans offset rows linearly
- **Example:** skip(10000) without index = scans 10,000 documents; with index = O(log n)

**Index size impact:**
- 7 indexes total (2 for contexts, 5 for flows)
- Composite indexes are more efficient than multiple single-field indexes
- MongoDB index size typically 5-10% of collection size

[Source: docs/architecture/data-models.md#database-indexes-mongodb]

### Rate Limiting for Abuse Prevention

**Why rate limiting is critical:**
- Prevents API abuse and spam
- Protects against brute force attacks
- Ensures fair resource usage
- Prevents accidental infinite loops in clients

**Rate limiting implementation using slowapi:**
```python
from slowapi import Limiter
from slowapi.util import get_remote_address
from fastapi import Request

# Initialize limiter
limiter = Limiter(key_func=get_remote_address)

# In main.py
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# In routers/contexts.py
@router.post("/api/v1/contexts", response_model=ContextInDB, status_code=201)
@limiter.limit("10/minute")  # Max 10 context creations per minute
async def create_context(
    request: Request,  # Required for slowapi
    context_data: ContextCreate,
    user_id: str = Depends(get_current_user),
    context_repo: ContextRepository = Depends(get_context_repository)
):
    """Create a new context (rate limited)."""
    return await context_repo.create(user_id, context_data)

# In routers/flows.py
@router.post("/api/v1/flows", response_model=FlowInDB, status_code=201)
@limiter.limit("30/minute")  # Max 30 flow creations per minute
async def create_flow(
    request: Request,
    flow_data: FlowCreate,
    user_id: str = Depends(get_current_user),
    flow_repo: FlowRepository = Depends(get_flow_repository),
    context_repo: ContextRepository = Depends(get_context_repository)
):
    """Create a new flow (rate limited)."""
    await verify_context_ownership(flow_data.context_id, user_id, context_repo)
    return await flow_repo.create(flow_data.context_id, flow_data)
```

**Rate limit configuration:**
```python
# Recommended limits
- Context creation: 10/minute (contexts created infrequently)
- Flow creation: 30/minute (flows created more frequently)
- List endpoints: 60/minute (read operations more frequent)
- Update/Delete: 30/minute (moderate usage)
```

**Rate limit exceeded error handler:**
```python
from slowapi.errors import RateLimitExceeded
from fastapi.responses import JSONResponse

async def _rate_limit_exceeded_handler(request: Request, exc: RateLimitExceeded):
    """
    Handle rate limit exceeded errors with proper format.

    Returns:
        JSONResponse with 429 status code, error details, and Retry-After header
    """
    return JSONResponse(
        status_code=status.HTTP_429_TOO_MANY_REQUESTS,
        content={
            "detail": "Rate limit exceeded. Please try again later.",
            "retry_after": exc.retry_after  # Seconds until limit resets
        },
        headers={
            "Retry-After": str(exc.retry_after)  # HTTP standard header
        }
    )

# Register in main.py
from slowapi.errors import RateLimitExceeded
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)
```

**429 Error Response Pydantic Model (for OpenAPI docs):**
```python
# In models/errors.py
from pydantic import BaseModel, Field

class RateLimitError(BaseModel):
    """Rate limit exceeded error response."""
    detail: str = Field(..., example="Rate limit exceeded. Please try again later.")
    retry_after: int = Field(..., example=60, description="Seconds until rate limit resets")

    class Config:
        json_schema_extra = {
            "example": {
                "detail": "Rate limit exceeded. Please try again later.",
                "retry_after": 60
            }
        }

# Use in route decorators
@router.post(
    "/api/v1/contexts",
    response_model=ContextInDB,
    status_code=201,
    responses={
        429: {
            "model": RateLimitError,
            "description": "Rate limit exceeded",
            "headers": {
                "Retry-After": {
                    "description": "Seconds until rate limit resets",
                    "schema": {"type": "integer"}
                }
            }
        }
    }
)
@limiter.limit("10/minute")
async def create_context(request: Request, ...):
    ...
```

**Example 429 Response:**
```json
HTTP/1.1 429 Too Many Requests
Content-Type: application/json
Retry-After: 60

{
  "detail": "Rate limit exceeded. Please try again later.",
  "retry_after": 60
}
```

**Dependencies required:**
```toml
# Add to pyproject.toml
slowapi = "^0.1.9"
```

**Benefits:**
- Prevents context/flow creation spam
- Protects database from excessive writes
- Returns 429 status code with retry-after header (HTTP standard)
- Documented in OpenAPI/Swagger UI with example
- Can be configured per-endpoint based on criticality
- Clients can parse Retry-After header for smart retry logic

[Source: FastAPI rate limiting best practices, RFC 6585]

### Pydantic Validation with Max Lengths

**Why max length validation is important:**
- Prevents database storage abuse
- Protects against excessively long payloads
- Ensures consistent UI rendering
- Database schema enforcement

**Validation in Pydantic models (from Story 2.1):**
```python
# In models/context.py
from pydantic import BaseModel, Field

class ContextCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=50, description="Context name")
    color: str = Field(..., pattern=r'^#[0-9A-Fa-f]{6}$', description="Hex color")
    icon: str = Field(..., min_length=1, max_length=10, description="Emoji icon")

# In models/flow.py
class FlowCreate(BaseModel):
    context_id: str = Field(..., description="Parent context ID")
    title: str = Field(..., min_length=1, max_length=200, description="Flow title")
    description: str | None = Field(None, max_length=2000, description="Optional description")
    priority: Literal["low", "medium", "high"] = Field(default="medium")
    due_date: datetime | None = None
    reminder_enabled: bool = Field(default=True)
```

**Validation rules enforced:**
- **Context name**: 1-50 characters (UI friendly)
- **Context icon**: 1-10 characters (emoji only)
- **Flow title**: 1-200 characters (prevents excessively long titles)
- **Flow description**: Max 2000 characters (prevents abuse)
- **Color format**: Hex regex validation (`#3B82F6`)

**Validation error response:**
```json
{
  "detail": [
    {
      "loc": ["body", "title"],
      "msg": "ensure this value has at most 200 characters",
      "type": "value_error.any_str.max_length",
      "ctx": {"limit_value": 200}
    }
  ]
}
```

**Story 2.1 reference:**
Story 2.1 already defines these validation rules. Story 2.4 routers inherit this validation automatically via FastAPI's request body parsing.

**Additional validation to consider:**
- Email format validation (if adding user emails)
- URL validation (if adding external links)
- Timezone validation (for due_date fields)

[Source: docs/architecture/data-models.md, Story 2.1 Pydantic models]

### API Response Models

**Use Pydantic models from Story 2.1:**
- `ContextCreate`, `ContextUpdate`, `ContextInDB` from `src/models/context.py`
- `FlowCreate`, `FlowUpdate`, `FlowInDB` from `src/models/flow.py`

**FastAPI automatically:**
- Validates request bodies against `*Create` and `*Update` schemas
- Serializes response models (`*InDB`) to JSON
- Generates OpenAPI spec with schema documentation
- Shows examples in Swagger UI (`/docs`)

[Source: docs/architecture/backend-architecture.md#pydantic-models-requestresponse-schemas]

### Error Handling Standards

**HTTP Status Codes:**
- `200 OK` - Successful GET, PUT, PATCH
- `201 Created` - Successful POST
- `204 No Content` - Successful DELETE
- `400 Bad Request` - Validation error (Pydantic)
- `401 Unauthorized` - Missing or invalid JWT token
- `403 Forbidden` - User doesn't own resource
- `404 Not Found` - Resource doesn't exist
- `429 Too Many Requests` - Rate limit exceeded (slowapi)

**HTTPException examples:**
```python
# 401 Unauthorized (handled by auth middleware)
raise HTTPException(status_code=401, detail="Invalid or expired token")

# 403 Forbidden (ownership check)
if flow.user_id != user_id:
    raise HTTPException(status_code=403, detail="Access forbidden")

# 404 Not Found (resource doesn't exist)
if not context:
    raise HTTPException(status_code=404, detail="Context not found")

# 429 Too Many Requests (rate limit exceeded, handled by slowapi)
# Automatically raised by @limiter.limit() decorator
# Returns: {"detail": "Rate limit exceeded. Please try again later.", "retry_after": 60}
```

[Source: docs/architecture/15-error-handling-strategy.md#error-categories-and-status-codes]

### Project Structure Alignment

**Router files location:**
```
my_flow_api/src/routers/
├── __init__.py          # Export all routers
├── contexts.py          # Context CRUD routes (THIS STORY)
└── flows.py             # Flow CRUD routes (THIS STORY)
```

**Auth middleware location:**
```
my_flow_api/src/middleware/
├── __init__.py
└── auth.py              # get_current_user dependency (THIS STORY)
```

**Test files location:**
```
my_flow_api/tests/integration/routers/
├── __init__.py
├── test_contexts.py     # Context API tests (THIS STORY)
└── test_flows.py        # Flow API tests (THIS STORY)
```

[Source: docs/architecture/9-unified-project-structure.md#backend-structure]

### Testing Standards

**Integration Test Setup:**
```python
# tests/integration/routers/test_contexts.py
import pytest
from fastapi.testclient import TestClient
from src.main import app
from src.middleware.auth import get_current_user

# Mock auth dependency
async def override_get_current_user():
    return "test_user_id"

app.dependency_overrides[get_current_user] = override_get_current_user

@pytest.fixture
def client():
    """Provides TestClient for integration tests."""
    return TestClient(app)

@pytest.mark.asyncio
async def test_list_contexts(client):
    """Test GET /api/v1/contexts returns user's contexts."""
    response = client.get("/api/v1/contexts")
    assert response.status_code == 200
    assert isinstance(response.json(), list)
```

**Test Organization:**
- Integration tests: `tests/integration/routers/test_contexts.py`, `test_flows.py`
- Use `TestClient` from FastAPI (wraps HTTPX async client)
- Override auth dependency to inject test user_id
- Test both success and error cases (401, 403, 404)
- Use real MongoDB connection with test database cleanup

**Coverage Requirements:**
- 80% minimum coverage for router files
- Test all endpoints (GET, POST, PUT, DELETE, PATCH)
- Test authentication (401 responses)
- Test authorization (403 responses)
- Test validation errors (400 responses)

[Source: docs/architecture/13-testing-strategy.md#backend-api-integration-test]

### Python Dependencies

**Required dependencies (already in pyproject.toml from Stories 2.1-2.3):**
- `fastapi ^0.115.0` - Web framework
- `uvicorn[standard] ^0.30.0` - ASGI server
- `motor ^3.5.0` - Async MongoDB driver
- `pydantic ^2.8.0` - Data validation
- `python-jose[cryptography] ^3.3.0` - JWT validation
- `httpx ^0.27.0` - HTTP client for JWKS fetch

**Dev dependencies:**
- `pytest ^8.3.0` - Test framework
- `pytest-asyncio ^0.24.0` - Async test support
- `pytest-cov` - Coverage reporting
- `httpx` - TestClient support

[Source: docs/architecture/tech-stack.md]

### OpenAPI Documentation

**FastAPI auto-generates OpenAPI spec:**
- Swagger UI available at `/docs`
- ReDoc available at `/redoc`
- OpenAPI JSON schema at `/openapi.json`

**Ensure schemas are documented:**
- Use `response_model` parameter in route decorators
- Use `status_code` parameter for non-200 success codes
- Use `tags` parameter for grouping endpoints in docs
- Pydantic models automatically show in schema

**Example:**
```python
@router.post(
    "/api/v1/contexts",
    response_model=ContextInDB,
    status_code=status.HTTP_201_CREATED,
    tags=["Contexts"],
    summary="Create a new context",
    description="Create a new context for the authenticated user"
)
async def create_context(
    context_data: ContextCreate,
    user_id: str = Depends(get_current_user),
    context_repo: ContextRepository = Depends(get_context_repository)
):
    """Create a new context."""
    return await context_repo.create(user_id, context_data)
```

[Source: docs/architecture/api-specification.md#openapi-31-specification]

### API Specification Reference

**Context Endpoints:**
- `GET /api/v1/contexts` → List all contexts
- `POST /api/v1/contexts` → Create context
- `GET /api/v1/contexts/{context_id}` → Get single context
- `PUT /api/v1/contexts/{context_id}` → Update context
- `DELETE /api/v1/contexts/{context_id}` → Delete context

**Flow Endpoints:**
- `GET /api/v1/contexts/{context_id}/flows` → List flows for context
- `POST /api/v1/flows` → Create flow
- `GET /api/v1/flows/{flow_id}` → Get single flow
- `PUT /api/v1/flows/{flow_id}` → Update flow
- `DELETE /api/v1/flows/{flow_id}` → Delete flow
- `PATCH /api/v1/flows/{flow_id}/complete` → Mark complete

**All endpoints require `Authorization: Bearer <jwt_token>` header**

[Source: docs/architecture/api-specification.md#api-endpoints-overview]

### Type Hints and Async Patterns

**All route handlers MUST be async:**
```python
async def list_contexts(
    user_id: str = Depends(get_current_user),
    context_repo: ContextRepository = Depends(get_context_repository)
) -> list[ContextInDB]:
    ...
```

**Use FastAPI dependencies:**
- `Depends(get_current_user)` for authentication
- `Depends(get_context_repository)` for repository DI
- `Depends(get_database)` for database connection

**Type hints for responses:**
- Use `response_model` in route decorator
- Return Pydantic models directly (FastAPI auto-serializes)
- Use `list[ModelType]` for list responses

[Source: docs/architecture/coding-standards.md#naming-conventions]

### Configuration Management

**Settings required for auth:**
```python
# src/config.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # ... existing settings ...

    # Logto Authentication
    LOGTO_ENDPOINT: str  # e.g., "https://your-logto-instance.logto.app"
    LOGTO_APP_ID: str
    LOGTO_APP_SECRET: str  # Not used in JWT validation (public key from JWKS)
    LOGTO_JWKS_MAX_STALE_SECONDS: int = 7200  # Default: 2 hours (max age for stale cache)

    # Security
    ENVIRONMENT: str = "development"  # Options: development, staging, production
    CORS_ORIGINS: list[str] = ["http://localhost:3000"]  # Environment-specific allowed origins
```

**Environment variables (.env):**
```bash
LOGTO_ENDPOINT=https://your-logto-instance.logto.app
LOGTO_APP_ID=your-app-id
LOGTO_APP_SECRET=your-app-secret
LOGTO_JWKS_MAX_STALE_SECONDS=7200  # Optional: defaults to 2 hours
ENVIRONMENT=development  # Change to "production" in prod
CORS_ORIGINS=["http://localhost:3000"]  # Use ["https://app.example.com"] in prod
```

[Source: docs/architecture/backend-architecture.md#configuration-management]

### CRITICAL SECURITY & CODE QUALITY FIXES (Added 2025-10-07)

**Context:** Post-implementation review identified 8 critical issues that must be addressed in this story. These fixes have been integrated into Task 1 and testing requirements.

#### 1. JWKS Cache Thread Safety (CRITICAL)
**Issue:** Module-level `_jwks_cache` dictionary is not thread-safe in async contexts.
**Impact:** Race conditions can occur when multiple requests check/update cache simultaneously:
- Two requests check cache at same time (both see expired)
- Both initiate JWKS fetch (duplicate network calls)
- Both update cache (potential partial writes/corruption)

**Fix:** Add `asyncio.Lock` with lazy initialization and double-check locking pattern:
```python
import asyncio

_jwks_cache = {"keys": None, "expires_at": None}
_cache_lock: asyncio.Lock | None = None

async def get_logto_jwks() -> dict:
    global _cache_lock

    # Lazy initialization (avoids RuntimeError: no running event loop)
    if _cache_lock is None:
        _cache_lock = asyncio.Lock()

    # Fast path: check cache without lock
    if _jwks_cache["keys"] and _jwks_cache["expires_at"] and now < _jwks_cache["expires_at"]:
        return _jwks_cache["keys"]

    # Slow path: acquire lock, double-check, then fetch
    async with _cache_lock:
        # Double-check after acquiring lock
        if _jwks_cache["keys"] and _jwks_cache["expires_at"] and now < _jwks_cache["expires_at"]:
            return _jwks_cache["keys"]

        # Fetch and update cache (only one request does this)
        ...
```

**Why lazy initialization:**
- Creating `asyncio.Lock()` at module level raises `RuntimeError: no running event loop`
- Lock is created on first function call when event loop is guaranteed to be running
- Slightly slower first call, but prevents import-time errors

**Test Requirements:**
- Test concurrent cache checks/updates (simulate race conditions)
- Verify only one JWKS fetch occurs when multiple requests hit expired cache
- Verify cache consistency under concurrent load

#### 2. JWKS Validation Missing (SECURITY)
**Issue:** No validation that fetched JWKS contains valid keys.
**Impact:** Malformed/empty JWKS responses could be cached, breaking authentication.

**Fix:** Validate JWKS structure before caching:
```python
jwks = response.json()

# Validate JWKS structure
if not isinstance(jwks, dict) or "keys" not in jwks or not jwks["keys"]:
    raise ValueError("Invalid JWKS response: missing 'keys' array")

_jwks_cache["keys"] = jwks
```

#### 3. Hardcoded Print Statements (CODE SMELL)
**Issue:** Using `print()` for logging in production code.
**Impact:** No log levels, poor integration with application logging, harder to debug.

**Fix:** Use proper logging:
```python
import logging

logger = logging.getLogger(__name__)

# In get_logto_jwks():
logger.warning("Using stale JWKS cache due to fetch error: %s", str(e))
```

#### 4. UTC Timestamp Deprecation (PYTHON 3.12+)
**Issue:** `datetime.utcnow()` is deprecated in Python 3.12+.
**Impact:** Deprecation warnings in logs, future compatibility issues.

**Fix:** Use timezone-aware datetime:
```python
from datetime import datetime, timezone, timedelta

now = datetime.now(timezone.utc)
```

#### 5. Rate Limit Response Schema (MISSING)
**Issue:** Task 5 mentions `RateLimitError` model but doesn't provide implementation.

**Fix:** Add Pydantic model in Dev Notes (already documented):
```python
from pydantic import BaseModel

class RateLimitError(BaseModel):
    detail: str = "Rate limit exceeded"
    retry_after: int  # seconds

    class Config:
        json_schema_extra = {
            "example": {
                "detail": "Rate limit exceeded",
                "retry_after": 60
            }
        }
```

#### 6. Authorization Helper Return Types (FALSE ALARM)
**Issue:** Originally reported as missing return type annotations.
**Resolution:** Verified that `verify_context_ownership()` and `verify_flow_ownership()` have proper return type annotations (`-> ContextInDB`, `-> FlowInDB`). No fix needed.

#### 7. HTTP 429 Not in AC (INCONSISTENCY)
**Issue:** Acceptance Criteria don't mention 429 (rate limiting), but Task 5 adds it.

**Fix:** Updated AC #3 to include:
```
- Returns 429 for rate limit exceeded (with Retry-After header)
```

#### 8. JWKS Caching Tests Missing (TESTING GAP)
**Issue:** Task 1 mentions adding tests for JWKS caching, but Tasks 7-8 (integration tests) don't verify this.

**Fix:** Added to Task 1 testing requirements:
- Test `get_current_user()` with expired JWKS cache (verify refetch)
- Test `get_current_user()` with JWKS fetch failure (verify stale cache fallback)
- Test `get_current_user()` with no cache and fetch failure (verify 503)
- Test concurrent JWKS cache access (thread safety)

**Summary Impact:**
- **High-traffic safety:** Thread-safe JWKS caching prevents race conditions
- **Security:** JWKS validation prevents malformed responses
- **Code quality:** Proper logging integration
- **Future-proofing:** Python 3.12+ compatibility
- **API completeness:** 429 rate limiting documented and tested

#### 9. Repository Method Dependencies (ARCHITECTURAL)
**Issue:** Task 2 adds methods to repositories from Stories 2.2/2.3 (already Done), creating a cross-story dependency.
**Impact:** Modifying completed stories could invalidate existing tests and deployments.

**Resolution Options:**
1. **Current approach:** Retrofit existing repositories (modify Stories 2.2/2.3 code)
   - Pros: All repository code in one place
   - Cons: Changes code that passed QA, requires re-running Story 2.2/2.3 tests
2. **Alternative approach:** Create mini-stories 2.2.1 and 2.3.1
   - Pros: Clean separation, no retroactive changes
   - Cons: More story management overhead

**Chosen approach:** Current (retrofit) with safeguards:
- Task 2 explicitly calls out this is modifying existing repositories
- Developer MUST verify Stories 2.2 & 2.3 are completed first
- All new methods require comprehensive unit tests
- Must re-run existing repository test suites to verify no regressions

**Updated:** Task 2 now includes "CRITICAL DEPENDENCY" warning and verification requirements.

#### 10. asyncio.Lock Module-Level Initialization (RUNTIME ERROR)
**Issue:** Creating `asyncio.Lock()` at module level causes `RuntimeError: no running event loop`.
**Impact:** Application fails to import middleware module, auth completely broken.

**Root Cause:**
- Module-level code executes during import, before event loop exists
- `asyncio.Lock()` requires a running event loop to initialize
- FastAPI/uvicorn creates event loop after all modules are imported

**Fix:** Lazy initialization pattern:
```python
_cache_lock: asyncio.Lock | None = None

async def get_logto_jwks() -> dict:
    global _cache_lock

    # Lazy initialization (first call creates lock)
    if _cache_lock is None:
        _cache_lock = asyncio.Lock()

    # ... rest of function
```

**Tradeoffs:**
- **Pro:** No import-time errors, event loop guaranteed to exist
- **Pro:** Thread-safe initialization (first caller creates lock, others wait)
- **Con:** Slightly slower first call (negligible - ~microseconds)
- **Con:** Requires `global` keyword (acceptable for module-level state)

**Alternative approaches considered:**
1. **App startup hook:** Initialize lock in `lifespan()` - rejected (requires passing lock as dependency)
2. **functools.lru_cache:** Use cached sync function - rejected (can't cache async coroutines)
3. **Class-based approach:** Move to Singleton class - rejected (overengineered for this use case)

**Updated:** Task 1 and both code examples (story + architecture) now use lazy initialization.

#### 11. Authorization Helpers Optional → Mandatory (CODE QUALITY)
**Issue:** Task 1 listed authorization helpers as "optional but recommended", leading to potential code duplication.
**Impact:** Without helpers, each route handler repeats ownership logic, violating DRY principle.

**Fix:** Make helpers REQUIRED with explicit signatures:
- `verify_context_ownership()` → Returns `ContextInDB`, raises 404 if not found
- `verify_flow_ownership()` → Returns `FlowInDB`, raises 404 if not found, 403 if owned by different user
- Must be used in all route handlers (Tasks 3 & 4)

**Benefits:**
- **DRY:** Ownership logic in one place (maintainability)
- **Consistency:** All routes use same error codes (404 vs 403)
- **Testability:** Test ownership logic once, not per route
- **Readability:** Route handlers focus on business logic, not auth boilerplate

**Updated:** Task 1 now mandates helpers with full signatures and usage requirements.

#### 12. Missing Pagination Parameters in Repository Methods (BREAKING CHANGE)
**Issue:** Story expects `limit` and `offset` parameters in `get_all_by_user()` and `get_all_by_context()` that don't exist in Stories 2.2/2.3.
**Impact:** Story 2.4 router code will fail when calling these methods with pagination params.

**Fix:** Update Task 2 to add pagination parameters to existing methods:
- `get_all_by_user(user_id, limit=50, offset=0)` - Add default params
- `get_all_by_context(context_id, include_completed=False, limit=50, offset=0)` - Add default params

**Implementation:** Add `.skip(offset).limit(limit)` to MongoDB queries.

**Updated:** Task 2 now includes signature updates for both repository methods.

#### 13. Missing Critical Database Index (PERFORMANCE)
**Issue:** Missing compound index `(context_id, user_id, is_completed, created_at)` for flow pagination queries.
**Impact:** Paginated flow queries will perform full collection scans, causing severe performance degradation at scale.

**Fix:** Add compound index to Task 6:
```python
db.flows.create_index([
    ("context_id", 1),
    ("user_id", 1),
    ("is_completed", 1),
    ("created_at", -1)
])
```

**Why this index:** Covers most common query pattern in `GET /api/v1/contexts/{context_id}/flows` with filtering and ordering.

**Updated:** Task 6 now includes this critical compound index.

#### 14. Stale JWKS Cache Security Issue (SECURITY)
**Issue:** Stale cache fallback doesn't validate key age - could use rotated-out keys indefinitely.
**Impact:** Compromised/rotated JWKS keys could remain valid for authentication indefinitely during outages.

**Fix:** Add max stale age validation:
- New config: `LOGTO_JWKS_MAX_STALE_SECONDS = 7200` (2 hours)
- Check stale cache age before using: `(now - cached_at).total_seconds() < max_stale`
- Reject stale cache if older than 2 hours, return 503
- Add `cached_at` timestamp to cache dict

**Security Rationale:**
- TTL = 1 hour (normal cache expiry)
- Max stale = 2 hours (emergency fallback limit)
- After 2 hours of outage, fail closed (deny auth) rather than use potentially compromised keys

**Updated:** Task 1, code examples, and config section include max stale age validation.

#### 15. Missing JWT Claims Validation (SECURITY)
**Issue:** `jwt.decode()` doesn't explicitly verify `exp`, `nbf`, `iat` claims in options.
**Impact:** Expired or not-yet-valid tokens might be accepted (depends on python-jose defaults).

**Fix:** Add explicit verification options to `jwt.decode()`:
```python
options={
    "verify_signature": True,
    "verify_aud": True,
    "verify_iat": True,
    "verify_exp": True,
    "verify_nbf": True,
    "verify_iss": True,
    "require_aud": True,
    "require_iat": True,
    "require_exp": True,
    "require_nbf": False,  # nbf is optional in Logto tokens
}
```

**Claims validated:**
- `exp` (expiration): Token not expired
- `iat` (issued at): Token has valid issue time
- `nbf` (not before): Token is currently valid (verified but not required)
- `aud` (audience): Matches LOGTO_APP_ID
- `iss` (issuer): Matches LOGTO_ENDPOINT/oidc

**Updated:** Code examples in story and architecture docs include explicit verification options.

#### 16. Task 4 Not Using Authorization Helpers (CODE QUALITY)
**Issue:** Task 4 flow routes manually verify ownership instead of using `verify_flow_ownership()` helper.
**Impact:** Violates DRY principle, inconsistent error handling, harder to maintain.

**Fix:** Updated Task 4 to use helper:
- GET /flows/{id}: `flow = await verify_flow_ownership(flow_id, user_id, flow_repo)`
- PUT /flows/{id}: `await verify_flow_ownership(flow_id, user_id, flow_repo)`
- DELETE /flows/{id}: `await verify_flow_ownership(flow_id, user_id, flow_repo)`
- PATCH /flows/{id}/complete: `await verify_flow_ownership(flow_id, user_id, flow_repo)`

**Updated:** Task 4 now mandates using authorization helpers from Task 1.

#### 17. Pagination Validation Missing (SECURITY)
**Issue:** No validation constraints on `limit` and `offset` query parameters.
**Impact:**
- `limit=0` causes empty responses (poor UX)
- `limit=999999` could cause memory exhaustion (DoS vulnerability)
- `offset=-1` causes database errors
- `offset=999999` causes performance degradation (skip() is O(n) in MongoDB)

**Fix:** Add validation constraints to Query parameters:
```python
limit: int = Query(default=50, ge=1, le=100)
offset: int = Query(default=0, ge=0, le=10000)
```

**Constraints:**
- `ge=1` (greater or equal 1): Prevents empty limit
- `le=100` (less or equal 100): Prevents memory exhaustion
- `ge=0` (greater or equal 0): Prevents negative offset
- `le=10000` (less or equal 10000): Prevents excessive skip() performance hit

**Updated:** Tasks 3 & 4 pagination query params include validation constraints.

#### 18. Rate Limiting on Auth Endpoint (SECURITY)
**Issue:** `get_current_user()` auth dependency not rate limited.
**Impact:** Vulnerable to brute force token attacks (try millions of tokens to find valid one).

**Fix:** Add rate limiting to auth middleware:
```python
@limiter.limit("100/minute")
async def get_current_user(
    request: Request,  # Required for slowapi
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> str:
    ...
```

**Rationale:**
- 100 auth attempts/minute per IP is generous for legitimate users
- Blocks brute force attacks (would take years to try significant token space)
- Different from route-level rate limits (protects auth layer itself)

**Updated:** Task 1 includes rate limiting decorator on `get_current_user()`.

#### 19. HTTPS Enforcement Missing (SECURITY)
**Issue:** No HTTPS enforcement in production environments.
**Impact:** JWT tokens transmitted over HTTP vulnerable to man-in-the-middle attacks.

**Fix:** Add HTTPSRedirectMiddleware for production:
```python
if settings.ENVIRONMENT == "production":
    app.add_middleware(HTTPSRedirectMiddleware)
```

**Rationale:**
- JWTs are bearer tokens (possession = authentication)
- HTTP transmission exposes tokens to network sniffing
- HTTPS enforcement prevents this attack vector
- Skip in dev for localhost testing

**Updated:** Task 5 includes HTTPS enforcement middleware with environment check.

#### 20. CORS Wildcard in Production (SECURITY)
**Issue:** No explicit CORS configuration guidance, risk of `allow_origins=["*"]` in production.
**Impact:** Any website can make authenticated requests to API (CSRF attacks, data theft).

**Fix:** Configure CORS with explicit origins list:
```python
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,  # ["https://app.example.com"] in prod
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "PATCH"],
    allow_headers=["Authorization", "Content-Type"]
)
```

**Security Requirements:**
- **NEVER** use `allow_origins=["*"]` in production
- Use environment-specific origins (dev: localhost, prod: actual domain)
- Set `allow_credentials=True` (required for JWT auth)
- Explicitly list allowed methods and headers

**Updated:** Task 5 includes CORS configuration with security warnings.

#### 21. Test Coverage Gaps (QUALITY)
**Issue:** Missing tests for critical edge cases.
**Impact:** Pagination and concurrency bugs may reach production.

**Fix:** Add comprehensive test coverage:

**Pagination edge cases (Tasks 7 & 8):**
- `limit=0` → 422 (ge=1 validation)
- `limit=101` → 422 (le=100 validation)
- `offset=-1` → 422 (ge=0 validation)
- `offset=10001` → 422 (le=10000 validation)
- `limit=1` → exactly 1 item (boundary test)
- `offset > total` → empty list (no error)

**JWKS concurrency test (Task 1):**
- Spawn 10 concurrent requests to expired cache with `asyncio.gather()`
- Mock `httpx.AsyncClient.get()` with call counter
- Assert exactly 1 JWKS fetch (not 10)
- Assert all requests receive same data
- Verify lazy lock initialization thread safety

**Updated:** Tasks 1, 7, and 8 include detailed test implementation guides.

## Testing

### Test File Locations

**Integration tests for routers:**
- `my_flow_api/tests/integration/routers/test_contexts.py` - Context API integration tests
- `my_flow_api/tests/integration/routers/test_flows.py` - Flow API integration tests

**Unit tests for middleware:**
- `my_flow_api/tests/unit/middleware/test_auth.py` - Auth middleware unit tests

### Testing Frameworks and Patterns

**Frameworks:**
- `pytest` - Test framework with async support via `pytest-asyncio`
- `fastapi.testclient.TestClient` - HTTP client for testing FastAPI routes
- `pytest-cov` - Coverage reporting
- `httpx` - Async HTTP client (used by TestClient)

**Patterns:**
- Use `TestClient(app)` to make requests to FastAPI routes
- Override auth dependency with `app.dependency_overrides[get_current_user] = mock_user`
- Use real MongoDB connection with test database (not mocks)
- Clean up test data after each test using fixtures
- Test both success cases and error cases (401, 403, 404, 400)
- Use `@pytest.mark.asyncio` for async tests

**Example test structure:**
```python
import pytest
from fastapi.testclient import TestClient
from src.main import app
from src.middleware.auth import get_current_user

# Mock auth dependency
async def override_get_current_user():
    return "test_user_id"

app.dependency_overrides[get_current_user] = override_get_current_user

@pytest.fixture
def client():
    return TestClient(app)

@pytest.mark.asyncio
async def test_create_context_success(client):
    """Test POST /api/v1/contexts creates context successfully."""
    response = client.post(
        "/api/v1/contexts",
        json={"name": "Work", "color": "#3B82F6", "icon": "💼"}
    )
    assert response.status_code == 201
    data = response.json()
    assert data["name"] == "Work"
    assert "id" in data

@pytest.mark.asyncio
async def test_create_context_invalid_color(client):
    """Test POST /api/v1/contexts returns 400 for invalid color."""
    response = client.post(
        "/api/v1/contexts",
        json={"name": "Work", "color": "invalid", "icon": "💼"}
    )
    assert response.status_code == 422  # Pydantic validation error
```

### Test Coverage Requirements

**Coverage targets:**
- 80% minimum coverage for router files (`src/routers/contexts.py`, `src/routers/flows.py`)
- 80% minimum coverage for auth middleware (`src/middleware/auth.py`)

**Coverage command:**
```bash
pytest tests/integration/routers/ -v --cov=src/routers --cov=src/middleware
```

[Source: docs/architecture/13-testing-strategy.md#test-organization]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-07 | 1.0 | Story created for Epic 2.4 | Bob (Scrum Master) |
| 2025-10-07 | 1.1 | Added 8 critical security & code quality fixes to Task 1: (1) JWKS cache thread safety with asyncio.Lock, (2) JWKS validation before caching, (3) proper logging instead of print statements, (4) Python 3.12+ datetime.now(timezone.utc), (5) RateLimitError Pydantic model, (6) verified return type annotations, (7) updated AC #3 to include 429 status code, (8) added JWKS caching integration tests. Updated Dev Notes with corrected code examples and new "CRITICAL SECURITY & CODE QUALITY FIXES" section. | Bob (Scrum Master) |
| 2025-10-07 | 1.2 | Fixed backend-architecture.md JWKS implementation to match story (thread-safe with asyncio.Lock, proper logging, timezone-aware datetime). Added issue #9 to critical fixes: documented repository method dependencies (Task 2 retrofits Stories 2.2/2.3) with safeguards and verification requirements. Updated Task 2 with "CRITICAL DEPENDENCY" warning. | Bob (Scrum Master) |
| 2025-10-07 | 1.3 | CRITICAL FIX: Changed asyncio.Lock initialization from module-level to lazy (fixes RuntimeError: no running event loop). Updated story and architecture docs with lazy initialization pattern. Made authorization helpers (verify_context_ownership, verify_flow_ownership) REQUIRED (not optional) for DRY and centralized error handling. Added explicit signatures and usage instructions. | Bob (Scrum Master) |
| 2025-10-07 | 1.4 | Added 5 critical fixes (issues #12-16): (12) Added limit/offset params to repository methods (breaking change to Stories 2.2/2.3), (13) Added critical compound database index for flow pagination queries, (14) Added LOGTO_JWKS_MAX_STALE_SECONDS config and max stale age validation (2-hour security limit), (15) Added explicit JWT claims validation options (exp/iat/nbf/aud/iss), (16) Updated Task 4 to use authorization helpers. Updated both story and architecture docs with stale cache max age and JWT validation options. Total: 16 critical issues identified and resolved. | Bob (Scrum Master) |
| 2025-10-07 | 1.5 | Added final 5 critical fixes (issues #17-21): (17) Pagination validation with ge=1, le=100 for limit and ge=0, le=10000 for offset (prevents DoS), (18) Rate limiting on get_current_user() auth endpoint (100/minute, prevents brute force), (19) HTTPS enforcement middleware for production (prevents MITM attacks), (20) CORS configuration with explicit origins (prevents wildcard in prod, CSRF protection), (21) Comprehensive test coverage for pagination edge cases and JWKS concurrency. Added ENVIRONMENT and CORS_ORIGINS config settings. Updated Tasks 1, 3, 4, 5, 7, 8 with security hardening. **FINAL: 21 critical issues identified and resolved. Story production-ready.** | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

### Debug Log References

### Completion Notes List

### File List

## QA Results
