# Story 2.2: Context Repository with CRUD Operations (BE)

## Status
Draft

## Story

**As a** backend developer,
**I want** a repository pattern implementation for Context CRUD operations,
**so that** we have a clean separation between data access and business logic.

## Acceptance Criteria

1. **Repository class created in `my_flow_api/src/repositories/context_repository.py`:**
   - `ContextRepository(motor_client: AsyncIOMotorClient)`
   - Methods: `create()`, `get_by_id()`, `get_all_by_user()`, `update()`, `delete()`
   - All methods async with proper error handling
   - Uses Motor async MongoDB driver

2. **Repository methods return typed Pydantic models:**
   - `create(user_id: str, context_data: ContextCreate) -> ContextInDB`
   - `get_by_id(context_id: str, user_id: str) -> Optional[ContextInDB]`
   - `get_all_by_user(user_id: str) -> List[ContextInDB]`
   - `update(context_id: str, user_id: str, updates: ContextUpdate) -> Optional[ContextInDB]`
   - `delete(context_id: str, user_id: str) -> bool`

3. **Error handling includes:**
   - `DocumentNotFoundError` for missing documents
   - `UnauthorizedAccessError` for user_id mismatches
   - MongoDB connection errors properly propagated

4. **Integration tests created in `my_flow_api/tests/integration/repositories/test_context_repository.py`:**
   - Uses MongoDB test database (not production)
   - Tests all CRUD operations with real async MongoDB calls
   - Tests error conditions (not found, unauthorized)
   - Cleans up test data after each test
   - At least 85% coverage

## Tasks / Subtasks

- [ ] **Task 1: Set up base repository pattern** (AC: 1)
  - [ ] Create `my_flow_api/src/repositories/base.py` with BaseRepository generic class
  - [ ] Implement common CRUD methods: `find_by_id()`, `create()`, `update()`, `delete()`
  - [ ] Add utility methods for ObjectId conversion and datetime handling
  - [ ] Include type hints for all methods (Generic[ModelType])

- [ ] **Task 2: Implement ContextRepository class** (AC: 1, 2)
  - [ ] Create `my_flow_api/src/repositories/context_repository.py`
  - [ ] Inherit from `BaseRepository[ContextInDB]`
  - [ ] Implement `create(user_id: str, context_data: ContextCreate) -> ContextInDB`
    - Add `user_id` to context data
    - Set `created_at` and `updated_at` timestamps (UTC)
    - Insert into `contexts` collection
    - Return ContextInDB model with ObjectId serialized to string
  - [ ] Implement `get_by_id(context_id: str, user_id: str) -> Optional[ContextInDB]`
    - Query by `_id` and `user_id` (ownership check)
    - Return None if not found or unauthorized
    - Convert MongoDB document to ContextInDB model
  - [ ] Implement `get_all_by_user(user_id: str) -> List[ContextInDB]`
    - Query by `user_id`
    - Sort by `created_at` descending (most recent first)
    - Return list of ContextInDB models
  - [ ] Implement `update(context_id: str, user_id: str, updates: ContextUpdate) -> Optional[ContextInDB]`
    - Verify ownership with `user_id`
    - Use `find_one_and_update()` with `return_document=True` (Pydantic v2)
    - Update `updated_at` timestamp
    - Return updated ContextInDB or None if not found
  - [ ] Implement `delete(context_id: str, user_id: str) -> bool`
    - Verify ownership with `user_id`
    - Delete context document
    - Return True if deleted, False if not found or unauthorized

- [ ] **Task 3: Add custom exception classes** (AC: 3)
  - [ ] Create `my_flow_api/src/repositories/exceptions.py`
  - [ ] Define `DocumentNotFoundError(Exception)` with resource type and ID
  - [ ] Define `UnauthorizedAccessError(Exception)` with user_id and resource_id
  - [ ] Update repository methods to raise these exceptions appropriately
  - [ ] Add proper exception handling for MongoDB connection errors (pymongo.errors)

- [ ] **Task 4: Update database.py to create indexes** (AC: 1)
  - [ ] Update `my_flow_api/src/database.py` `create_indexes()` function
  - [ ] Add index on `contexts.user_id` (single field index)
  - [ ] Add compound index on `contexts.(user_id, created_at desc)` for sorted queries
  - [ ] Verify indexes are created during app startup in lifespan event

- [ ] **Task 5: Export repository from __init__.py** (AC: 1)
  - [ ] Update `my_flow_api/src/repositories/__init__.py`
  - [ ] Export `BaseRepository`, `ContextRepository`
  - [ ] Export custom exceptions
  - [ ] Verify clean imports: `from src.repositories import ContextRepository`

- [ ] **Task 6: Write integration tests** (AC: 4)
  - [ ] Create `my_flow_api/tests/integration/repositories/test_context_repository.py`
  - [ ] Set up pytest fixtures for test MongoDB connection
  - [ ] Create fixture for ContextRepository instance with test DB
  - [ ] Test `create()`: Creates context with user_id, returns ContextInDB with ID
  - [ ] Test `get_by_id()`: Retrieves context by ID and user_id (ownership check)
  - [ ] Test `get_by_id()`: Returns None for non-existent context
  - [ ] Test `get_by_id()`: Returns None when user_id doesn't match (unauthorized)
  - [ ] Test `get_all_by_user()`: Returns all user contexts sorted by created_at desc
  - [ ] Test `get_all_by_user()`: Returns empty list for user with no contexts
  - [ ] Test `update()`: Updates context fields and updated_at timestamp
  - [ ] Test `update()`: Returns None when context not found or user_id mismatch
  - [ ] Test `delete()`: Deletes context and returns True
  - [ ] Test `delete()`: Returns False when context not found or unauthorized
  - [ ] Add teardown fixture to clean up test data after each test
  - [ ] Ensure 85%+ coverage for context_repository.py

- [ ] **Task 7: Run tests and verify coverage** (AC: 4)
  - [ ] Run pytest: `pytest tests/integration/repositories/test_context_repository.py -v --cov=src/repositories`
  - [ ] Verify 85%+ coverage threshold met for repositories
  - [ ] Fix any failing tests or edge cases discovered
  - [ ] Verify all async operations work correctly with Motor driver

## Dev Notes

### Previous Story Insights (Story 2.1)

**Key Learnings:**
- Pydantic v2 patterns: Use `ConfigDict` instead of deprecated `Config` class
- Use `@field_serializer('id')` for ObjectId â†’ string conversion (replaces `json_encoders`)
- Use `@field_validator` for custom validation (timezone checks, format validation)
- Python Enum classes (inherit from `str, Enum`) for type-safe enums matching TypeScript
- 100% test coverage achieved with comprehensive unit tests
- No issues with mypy type checking or Pydantic v2 compatibility

[Source: docs/stories/2.1.story.md#dev-agent-record]

### Repository Pattern Architecture

**Base Repository Structure:**
```python
from motor.motor_asyncio import AsyncIOMotorDatabase
from typing import TypeVar, Generic, Type
from pydantic import BaseModel
from bson import ObjectId
from datetime import datetime

ModelType = TypeVar("ModelType", bound=BaseModel)

class BaseRepository(Generic[ModelType]):
    """Base repository with common CRUD operations."""

    def __init__(self, db: AsyncIOMotorDatabase, collection_name: str, model: Type[ModelType]):
        self.collection = db[collection_name]
        self.model = model

    async def find_by_id(self, doc_id: str) -> ModelType | None:
        """Find document by ID."""
        doc = await self.collection.find_one({"_id": ObjectId(doc_id)})
        return self.model(**doc) if doc else None

    async def create(self, data: dict) -> ModelType:
        """Insert new document."""
        data["created_at"] = datetime.utcnow()
        data["updated_at"] = datetime.utcnow()

        result = await self.collection.insert_one(data)
        doc = await self.collection.find_one({"_id": result.inserted_id})
        return self.model(**doc)

    async def update(self, doc_id: str, data: dict) -> ModelType | None:
        """Update document by ID."""
        data["updated_at"] = datetime.utcnow()

        result = await self.collection.find_one_and_update(
            {"_id": ObjectId(doc_id)},
            {"$set": data},
            return_document=True  # Pydantic v2 pattern
        )
        return self.model(**result) if result else None

    async def delete(self, doc_id: str) -> bool:
        """Delete document by ID."""
        result = await self.collection.delete_one({"_id": ObjectId(doc_id)})
        return result.deleted_count > 0
```

**Context Repository extends Base:**
```python
from src.repositories.base import BaseRepository
from src.models.context import ContextInDB, ContextCreate, ContextUpdate
from motor.motor_asyncio import AsyncIOMotorDatabase
from bson import ObjectId

class ContextRepository(BaseRepository[ContextInDB]):
    def __init__(self, db: AsyncIOMotorDatabase):
        super().__init__(db, "contexts", ContextInDB)

    async def get_all_by_user(self, user_id: str) -> list[ContextInDB]:
        """Find all contexts for a user, sorted by created_at desc."""
        cursor = self.collection.find({"user_id": user_id}).sort("created_at", -1)
        docs = await cursor.to_list(length=100)
        return [ContextInDB(**doc) for doc in docs]

    async def create(self, user_id: str, context_data: ContextCreate) -> ContextInDB:
        """Create new context with user ownership."""
        data = context_data.model_dump()
        data["user_id"] = user_id
        return await super().create(data)

    async def get_by_id(self, context_id: str, user_id: str) -> ContextInDB | None:
        """Get context by ID with ownership check."""
        doc = await self.collection.find_one({
            "_id": ObjectId(context_id),
            "user_id": user_id
        })
        return ContextInDB(**doc) if doc else None

    async def update(self, context_id: str, user_id: str, updates: ContextUpdate) -> ContextInDB | None:
        """Update context with ownership check."""
        # Only update fields that are not None
        data = {k: v for k, v in updates.model_dump().items() if v is not None}
        data["updated_at"] = datetime.utcnow()

        result = await self.collection.find_one_and_update(
            {"_id": ObjectId(context_id), "user_id": user_id},
            {"$set": data},
            return_document=True
        )
        return ContextInDB(**result) if result else None

    async def delete(self, context_id: str, user_id: str) -> bool:
        """Delete context with ownership check."""
        result = await self.collection.delete_one({
            "_id": ObjectId(context_id),
            "user_id": user_id
        })
        return result.deleted_count > 0
```

[Source: docs/architecture/backend-architecture.md#repository-layer-data-access]

### Error Handling Patterns

**Custom Repository Exceptions:**
```python
# src/repositories/exceptions.py

class RepositoryException(Exception):
    """Base exception for repository errors."""
    pass

class DocumentNotFoundError(RepositoryException):
    """Raised when a document is not found in the database."""
    def __init__(self, resource: str, resource_id: str):
        self.resource = resource
        self.resource_id = resource_id
        super().__init__(f"{resource} with ID {resource_id} not found")

class UnauthorizedAccessError(RepositoryException):
    """Raised when user attempts to access resource they don't own."""
    def __init__(self, user_id: str, resource: str, resource_id: str):
        self.user_id = user_id
        self.resource = resource
        self.resource_id = resource_id
        super().__init__(
            f"User {user_id} not authorized to access {resource} {resource_id}"
        )
```

**MongoDB Error Handling:**
- Catch `pymongo.errors.PyMongoError` for connection issues
- Catch `bson.errors.InvalidId` for invalid ObjectId strings
- Propagate errors to service layer for proper HTTP error responses

[Source: docs/architecture/15-error-handling-strategy.md#backend-error-handling]

### Database Connection and Indexes

**Database Setup (database.py):**
```python
from motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorDatabase
from src.config import settings

class MongoDB:
    client: AsyncIOMotorClient | None = None
    db: AsyncIOMotorDatabase | None = None

db_instance = MongoDB()

async def connect_to_mongo():
    """Initialize MongoDB connection."""
    db_instance.client = AsyncIOMotorClient(settings.MONGODB_URL)
    db_instance.db = db_instance.client[settings.MONGODB_DB_NAME]

    # Create indexes
    await create_indexes()

async def close_mongo_connection():
    """Close MongoDB connection."""
    if db_instance.client:
        db_instance.client.close()

async def get_database() -> AsyncIOMotorDatabase:
    """Dependency for accessing database."""
    return db_instance.db

async def create_indexes():
    """Create MongoDB indexes for performance."""
    db = db_instance.db

    # Contexts collection indexes
    await db.contexts.create_index("user_id")
    await db.contexts.create_index([("user_id", 1), ("created_at", -1)])

    # Future: Flows collection indexes (Story 2.3)
```

[Source: docs/architecture/backend-architecture.md#database-connection-setup]

### MongoDB Indexes for Contexts

**Required Indexes:**
- **Single field index on `user_id`**: Optimizes `get_all_by_user()` queries
- **Compound index on `(user_id, created_at desc)`**: Optimizes sorted listing queries

**Index Rationale:**
- User will frequently list all their contexts (Context Switcher UI)
- Contexts are sorted by most recently created for better UX
- Compound index covers both filtering by user and sorting by created_at

[Source: docs/architecture/data-models.md#database-indexes-mongodb]

### Testing Standards

**Integration Test Setup:**
```python
# tests/integration/repositories/conftest.py
import pytest
from motor.motor_asyncio import AsyncIOMotorClient
from src.repositories.context_repository import ContextRepository

@pytest.fixture
async def test_db():
    """Provides test database connection."""
    client = AsyncIOMotorClient("mongodb://localhost:27017")
    db = client["myflow_test"]
    yield db
    # Cleanup: drop test database after all tests
    await client.drop_database("myflow_test")
    client.close()

@pytest.fixture
async def context_repository(test_db):
    """Provides ContextRepository instance with test DB."""
    return ContextRepository(test_db)

@pytest.fixture
async def cleanup_contexts(test_db):
    """Cleans up contexts collection after each test."""
    yield
    await test_db.contexts.delete_many({})
```

**Test Organization:**
- Integration tests: `tests/integration/repositories/test_context_repository.py`
- Use pytest-asyncio for async test support (`@pytest.mark.asyncio`)
- Each test should create fresh data and clean up after
- Use descriptive test names: `test_create_context_success`, `test_get_by_id_unauthorized`

**Coverage Requirements:**
- 85% minimum coverage for repository files
- Test both success and error paths
- Test ownership checks (user_id validation)
- Test edge cases (empty results, invalid IDs)

[Source: docs/architecture/13-testing-strategy.md#test-organization]

### Backend File Structure

**Repository directory:**
```
my_flow_api/src/repositories/
â”œâ”€â”€ __init__.py          # Export all repositories
â”œâ”€â”€ base.py              # BaseRepository generic class
â”œâ”€â”€ context_repository.py # ContextRepository implementation
â””â”€â”€ exceptions.py        # Custom repository exceptions
```

**Test directory:**
```
my_flow_api/tests/integration/repositories/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ conftest.py          # Test fixtures (DB connection, cleanup)
â””â”€â”€ test_context_repository.py  # ContextRepository integration tests
```

[Source: docs/architecture/9-unified-project-structure.md#backend-structure]

### Python Dependencies

**Required dependencies (already in pyproject.toml from Story 2.1):**
- `motor ^3.5.0` - Async MongoDB driver
- `pydantic ^2.8.0` - Data validation (Pydantic v2)
- `pymongo ^4.0.0` - MongoDB utilities (bson.ObjectId)

**Dev dependencies:**
- `pytest ^8.3.0` - Test framework
- `pytest-asyncio ^0.24.0` - Async test support
- `pytest-cov` - Coverage reporting

[Source: docs/architecture/tech-stack.md]

### Type Hints and Async Patterns

**All repository methods MUST be async:**
```python
async def get_by_id(self, context_id: str, user_id: str) -> ContextInDB | None:
    ...
```

**Use Motor async methods:**
- `await collection.find_one(query)`
- `await collection.find(query).to_list(length=100)`
- `await collection.insert_one(document)`
- `await collection.update_one(query, update)`
- `await collection.delete_one(query)`
- `await collection.find_one_and_update(query, update, return_document=True)`

**Type hints for generics:**
- `BaseRepository[ModelType]` where `ModelType` is bound to `BaseModel`
- `list[ContextInDB]` for return types (Python 3.12+ syntax)
- `ContextInDB | None` for optional returns (Python 3.12+ union syntax)

[Source: docs/architecture/coding-standards.md#naming-conventions]

### ObjectId Handling

**Convert string to ObjectId:**
```python
from bson import ObjectId

# In queries
doc = await self.collection.find_one({"_id": ObjectId(context_id)})
```

**Handle invalid ObjectId:**
```python
from bson.errors import InvalidId

try:
    doc = await self.collection.find_one({"_id": ObjectId(context_id)})
except InvalidId:
    return None  # Invalid ID format
```

**Pydantic models automatically serialize ObjectId to string** (from Story 2.1):
- Models use `@field_serializer('id')` to convert ObjectId â†’ str
- No manual conversion needed when returning Pydantic models

[Source: docs/stories/2.1.story.md#dev-notes]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-05 | 1.0 | Story created for Epic 2.2 | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
(To be filled by Dev Agent)

### Debug Log References
(To be filled by Dev Agent)

### Completion Notes List
(To be filled by Dev Agent)

### File List
(To be filled by Dev Agent)

## QA Results

(To be filled by QA Agent)
