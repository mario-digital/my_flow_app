# Story 2.3: Flow Repository with CRUD Operations (BE)

## Status
Draft

## Story

**As a** backend developer,
**I want** a repository pattern implementation for Flow CRUD operations,
**so that** flows can be managed with proper validation and context association.

## Acceptance Criteria

1. **Repository class created in `my_flow_api/src/repositories/flow_repository.py`:**
   - `FlowRepository(motor_client: AsyncIOMotorClient)`
   - Methods: `create()`, `get_by_id()`, `get_all_by_context()`, `update()`, `delete()`, `mark_complete()`
   - All methods async with proper error handling

2. **Repository methods return typed Pydantic models:**
   - `create(context_id: str, flow_data: FlowCreate) -> FlowInDB`
   - `get_by_id(flow_id: str) -> Optional[FlowInDB]`
   - `get_all_by_context(context_id: str, include_completed: bool = False) -> List[FlowInDB]`
   - `update(flow_id: str, updates: FlowUpdate) -> Optional[FlowInDB]`
   - `delete(flow_id: str) -> bool`
   - `mark_complete(flow_id: str) -> Optional[FlowInDB]`

3. **Validation includes:**
   - Context existence validation before flow creation
   - User authorization (verify user owns the context before flow operations)
   - Completed flows cannot be marked complete again

4. **Integration tests created in `my_flow_api/tests/integration/repositories/test_flow_repository.py`:**
   - Tests all CRUD operations with real async MongoDB calls
   - Tests `mark_complete()` sets `completed_at` timestamp
   - Tests filtering by `include_completed` parameter
   - Tests error conditions (invalid context_id, not found, etc.)
   - At least 85% coverage

## Tasks / Subtasks

- [ ] **Task 1: Create Flow Pydantic models** (AC: 2)
  - [ ] Create `my_flow_api/src/models/flow.py`
  - [ ] Define `FlowBase` with fields: `title` (str, 1-200 chars), `description` (Optional[str]), `priority` (Enum: "low" | "medium" | "high"), `is_completed` (bool), `created_at`, `updated_at`, `completed_at` (Optional[datetime])
  - [ ] Define `FlowCreate(FlowBase)` with additional `context_id` field
  - [ ] Define `FlowUpdate(BaseModel)` with all optional fields for partial updates
  - [ ] Define `FlowInDB(FlowBase)` with `id` (ObjectId), `context_id` (ObjectId), complete DB representation
  - [ ] Define `FlowResponse(FlowBase)` for API responses with ObjectId ‚Üí string serialization
  - [ ] Create Python Enum `FlowPriority(str, Enum)` with LOW, MEDIUM, HIGH (must inherit from str for JSON serialization)
  - [ ] Add validators: `title` length (1-200), `priority` enum validation
  - [ ] Add `@field_serializer('id')` for ObjectId ‚Üí string conversion (Pydantic v2 pattern)
  - [ ] Use `ConfigDict(from_attributes=True)` for Pydantic v2 compatibility

- [ ] **Task 2: Implement FlowRepository class** (AC: 1, 2)
  - [ ] Create `my_flow_api/src/repositories/flow_repository.py`
  - [ ] Inherit from `BaseRepository[FlowInDB]` (reuse from Story 2.2)
  - [ ] Implement `create(context_id: str, flow_data: FlowCreate) -> FlowInDB`
    - Validate context exists using ContextRepository
    - Add `context_id` to flow data
    - Set `is_completed = False`, `created_at`, `updated_at` (UTC)
    - Insert into `flows` collection
    - Return FlowInDB model with ObjectId serialized to string
  - [ ] Implement `get_by_id(flow_id: str) -> Optional[FlowInDB]`
    - Query by `_id` (convert string to ObjectId)
    - Return None if not found
    - Convert MongoDB document to FlowInDB model
  - [ ] Implement `get_all_by_context(context_id: str, include_completed: bool = False) -> List[FlowInDB]`
    - Query by `context_id`
    - Filter by `is_completed` based on `include_completed` parameter
    - Sort by `created_at` descending (most recent first)
    - Use configurable limit (settings.MAX_FLOWS_PER_CONTEXT, default: 100)
    - Return list of FlowInDB models
  - [ ] Implement `update(flow_id: str, updates: FlowUpdate) -> Optional[FlowInDB]`
    - Use `find_one_and_update()` with `return_document=True` (Pydantic v2)
    - Update `updated_at` timestamp
    - Only update fields that are not None (partial update pattern)
    - Return updated FlowInDB or None if not found
  - [ ] Implement `delete(flow_id: str) -> bool`
    - Delete flow document
    - Return True if deleted, False if not found
  - [ ] Implement `mark_complete(flow_id: str) -> Optional[FlowInDB]`
    - Get current flow to check `is_completed` status
    - If already completed, return None (idempotent operation)
    - Set `is_completed = True` and `completed_at = datetime.now(UTC)`
    - Update `updated_at` timestamp
    - Return updated FlowInDB or None if not found

- [ ] **Task 3: Add context validation to FlowRepository** (AC: 3)
  - [ ] Inject `ContextRepository` into `FlowRepository.__init__()` for context validation
  - [ ] In `create()` method: call `context_repo.get_by_id()` to verify context exists
  - [ ] If context not found, return None or raise appropriate error
  - [ ] Document context ownership validation pattern in method docstrings

- [ ] **Task 4: Update database.py to create flow indexes** (AC: 1)
  - [ ] Update `my_flow_api/src/database.py` `create_indexes()` function
  - [ ] Add index on `flows.context_id` (single field index for flow listing)
  - [ ] Add compound index on `flows.(context_id, is_completed, priority)` for filtered/sorted queries
  - [ ] Verify indexes are created during app startup in lifespan event

- [ ] **Task 5: Export models and repository from __init__.py** (AC: 1, 2)
  - [ ] Update `my_flow_api/src/models/__init__.py`
  - [ ] Export `FlowBase`, `FlowCreate`, `FlowUpdate`, `FlowInDB`, `FlowResponse`, `FlowPriority`
  - [ ] Update `my_flow_api/src/repositories/__init__.py`
  - [ ] Export `FlowRepository`
  - [ ] Verify clean imports: `from src.repositories import FlowRepository`, `from src.models import FlowInDB`

- [ ] **Task 6: Write integration tests** (AC: 4)
  - [ ] Create `my_flow_api/tests/integration/repositories/test_flow_repository.py`
  - [ ] Reuse pytest fixtures from Story 2.2 (test MongoDB connection, cleanup)
  - [ ] Create fixture for FlowRepository instance with test DB
  - [ ] Create fixture for test context (needed for flow creation)
  - [ ] Test `create()`: Creates flow with context_id, returns FlowInDB with ID
  - [ ] Test `create()`: Returns None when context_id doesn't exist (validation)
  - [ ] Test `get_by_id()`: Retrieves flow by ID
  - [ ] Test `get_by_id()`: Returns None for non-existent flow
  - [ ] Test `get_all_by_context()`: Returns all flows for context sorted by created_at desc
  - [ ] Test `get_all_by_context()`: Filters completed flows when include_completed=False
  - [ ] Test `get_all_by_context()`: Includes completed flows when include_completed=True
  - [ ] Test `get_all_by_context()`: Returns empty list for context with no flows
  - [ ] Test `update()`: Updates flow fields and updated_at timestamp
  - [ ] Test `update()`: Performs partial update (only updates provided fields)
  - [ ] Test `update()`: Returns None when flow not found
  - [ ] Test `delete()`: Deletes flow and returns True
  - [ ] Test `delete()`: Returns False when flow not found
  - [ ] Test `mark_complete()`: Sets is_completed=True and completed_at timestamp
  - [ ] Test `mark_complete()`: Returns None when flow already completed (idempotent)
  - [ ] Test `mark_complete()`: Returns None when flow not found
  - [ ] Add teardown fixture to clean up test data after each test
  - [ ] Ensure 85%+ coverage for flow_repository.py

- [ ] **Task 7: Run tests and verify coverage** (AC: 4)
  - [ ] Run pytest: `pytest tests/integration/repositories/test_flow_repository.py -v --cov=src/repositories`
  - [ ] Verify 85%+ coverage threshold met for repositories
  - [ ] Fix any failing tests or edge cases discovered
  - [ ] Verify all async operations work correctly with Motor driver

## Dev Notes

### Previous Story Insights (Story 2.2)

**Key Learnings:**
- Pydantic v2 patterns: Use `ConfigDict` instead of deprecated `Config` class
- Use `@field_serializer('id')` for ObjectId ‚Üí string conversion (replaces `json_encoders`)
- Use `@field_validator` for custom validation (timezone checks, format validation)
- Python Enum classes (inherit from `str, Enum`) for type-safe enums matching TypeScript
- Repository layer intentionally returns None/False for not-found/unauthorized cases (service layer handles HTTP responses)
- Made `get_all_by_user()` limit configurable via settings.MAX_CONTEXTS_PER_USER (default: 100)
- All 104 tests passing with 91.58% coverage after QA fixes

[Source: docs/stories/2.2.story.md#dev-agent-record]

### Repository Pattern Architecture

**FlowRepository extends BaseRepository:**
```python
from src.repositories.base import BaseRepository
from src.repositories.context_repository import ContextRepository
from src.models.flow import FlowInDB, FlowCreate, FlowUpdate, FlowPriority
from motor.motor_asyncio import AsyncIOMotorDatabase
from bson import ObjectId
from datetime import datetime, UTC

class FlowRepository(BaseRepository[FlowInDB]):
    def __init__(self, db: AsyncIOMotorDatabase, context_repo: ContextRepository):
        super().__init__(db, "flows", FlowInDB)
        self.context_repo = context_repo

    async def create(self, context_id: str, flow_data: FlowCreate) -> FlowInDB | None:
        """Create new flow with context validation."""
        # Verify context exists
        context = await self.context_repo.get_by_id(context_id)
        if not context:
            return None

        data = flow_data.model_dump()
        data["context_id"] = context_id
        data["is_completed"] = False
        return await super().create(data)

    async def get_all_by_context(
        self,
        context_id: str,
        include_completed: bool = False
    ) -> list[FlowInDB]:
        """Find all flows for a context, optionally filtering completed."""
        query = {"context_id": context_id}
        if not include_completed:
            query["is_completed"] = False

        cursor = self.collection.find(query).sort("created_at", -1)
        docs = await cursor.to_list(length=settings.MAX_FLOWS_PER_CONTEXT)
        return [FlowInDB(**doc) for doc in docs]

    async def mark_complete(self, flow_id: str) -> FlowInDB | None:
        """Mark flow as completed with timestamp."""
        # Check current status
        flow = await self.get_by_id(flow_id)
        if not flow or flow.is_completed:
            return None  # Already completed or not found

        result = await self.collection.find_one_and_update(
            {"_id": ObjectId(flow_id)},
            {
                "$set": {
                    "is_completed": True,
                    "completed_at": datetime.now(UTC),
                    "updated_at": datetime.now(UTC)
                }
            },
            return_document=True
        )
        return FlowInDB(**result) if result else None
```

[Source: docs/architecture/backend-architecture.md#repository-layer-data-access]

### Flow Data Model

**Flow Model Fields:**
```python
from pydantic import BaseModel, Field, field_serializer, ConfigDict
from datetime import datetime
from enum import Enum
from bson import ObjectId

class FlowPriority(str, Enum):
    """Flow priority levels (must inherit from str for JSON serialization)."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"

class FlowBase(BaseModel):
    title: str = Field(..., min_length=1, max_length=200)
    description: str | None = None
    priority: FlowPriority = FlowPriority.MEDIUM
    is_completed: bool = False

class FlowCreate(FlowBase):
    context_id: str  # Required for creation

class FlowUpdate(BaseModel):
    title: str | None = Field(None, min_length=1, max_length=200)
    description: str | None = None
    priority: FlowPriority | None = None

class FlowInDB(FlowBase):
    id: ObjectId = Field(alias="_id")
    context_id: ObjectId
    created_at: datetime
    updated_at: datetime
    completed_at: datetime | None = None

    model_config = ConfigDict(from_attributes=True)

    @field_serializer('id', 'context_id')
    def serialize_object_id(self, v: ObjectId) -> str:
        return str(v)
```

[Source: docs/architecture/data-models.md#flow-model]

### MongoDB Indexes for Flows

**Required Indexes:**
- **Single field index on `context_id`**: Optimizes `get_all_by_context()` queries
- **Compound index on `(context_id, is_completed, priority)`**: Optimizes filtered/sorted listing queries

**Index Rationale:**
- Users will frequently list flows within a context (Flow List UI)
- Filtering by completion status is common (show only active flows)
- Sorting by priority enables priority-based flow ordering
- Compound index covers filtering by context + completion + sorting by priority

[Source: docs/architecture/data-models.md#database-indexes-mongodb]

### Context Validation Pattern

**Dependency Injection for Context Validation:**
```python
class FlowRepository(BaseRepository[FlowInDB]):
    def __init__(self, db: AsyncIOMotorDatabase, context_repo: ContextRepository):
        super().__init__(db, "flows", FlowInDB)
        self.context_repo = context_repo  # Inject for validation

    async def create(self, context_id: str, flow_data: FlowCreate) -> FlowInDB | None:
        # Validate context exists before creating flow
        context = await self.context_repo.get_by_id(context_id)
        if not context:
            return None  # Context not found

        # Proceed with flow creation...
```

**Why return None instead of raising exception:**
- Repository layer focuses on data access patterns
- Service layer handles business logic and HTTP responses
- None/False returns are intentional (from Story 2.2 QA review)

[Source: docs/stories/2.2.story.md#qa-resolution]

### Testing Standards

**Integration Test Setup:**
```python
# tests/integration/repositories/test_flow_repository.py
import pytest
from motor.motor_asyncio import AsyncIOMotorClient
from src.repositories.flow_repository import FlowRepository
from src.repositories.context_repository import ContextRepository
from src.models.context import ContextCreate
from src.models.flow import FlowCreate, FlowPriority

@pytest.fixture
async def test_db():
    """Provides test database connection."""
    client = AsyncIOMotorClient("mongodb://localhost:27017")
    db = client["myflow_test"]
    yield db
    # Cleanup: drop test database after all tests
    await client.drop_database("myflow_test")
    client.close()

@pytest.fixture
async def context_repository(test_db):
    """Provides ContextRepository instance with test DB."""
    return ContextRepository(test_db)

@pytest.fixture
async def flow_repository(test_db, context_repository):
    """Provides FlowRepository instance with test DB."""
    return FlowRepository(test_db, context_repository)

@pytest.fixture
async def test_context(context_repository):
    """Creates a test context for flow creation."""
    context_data = ContextCreate(
        name="Test Context",
        color="#3B82F6",
        icon="üíº"
    )
    return await context_repository.create("test_user_id", context_data)

@pytest.fixture
async def cleanup_flows(test_db):
    """Cleans up flows collection after each test."""
    yield
    await test_db.flows.delete_many({})
```

**Test Organization:**
- Integration tests: `tests/integration/repositories/test_flow_repository.py`
- Use pytest-asyncio for async test support (`@pytest.mark.asyncio`)
- Each test should create fresh data and clean up after
- Use descriptive test names: `test_create_flow_success`, `test_mark_complete_idempotent`

**Coverage Requirements:**
- 85% minimum coverage for repository files
- Test both success and error paths
- Test context validation (invalid context_id)
- Test edge cases (empty results, invalid IDs, already completed flows)

[Source: docs/architecture/13-testing-strategy.md#test-organization]

### Backend File Structure

**Repository directory:**
```
my_flow_api/src/repositories/
‚îú‚îÄ‚îÄ __init__.py          # Export all repositories
‚îú‚îÄ‚îÄ base.py              # BaseRepository generic class (from Story 2.2)
‚îú‚îÄ‚îÄ context_repository.py # ContextRepository (from Story 2.2)
‚îú‚îÄ‚îÄ flow_repository.py   # FlowRepository implementation (THIS STORY)
‚îî‚îÄ‚îÄ exceptions.py        # RepositoryError base class
```

**Models directory:**
```
my_flow_api/src/models/
‚îú‚îÄ‚îÄ __init__.py          # Export all models
‚îú‚îÄ‚îÄ context.py           # Context models (from Story 2.1)
‚îî‚îÄ‚îÄ flow.py              # Flow models (THIS STORY)
```

**Test directory:**
```
my_flow_api/tests/integration/repositories/
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ conftest.py          # Test fixtures (DB connection, cleanup) - REUSE from Story 2.2
‚îú‚îÄ‚îÄ test_context_repository.py  # From Story 2.2
‚îî‚îÄ‚îÄ test_flow_repository.py     # FlowRepository integration tests (THIS STORY)
```

[Source: docs/architecture/9-unified-project-structure.md#backend-structure]

### Python Dependencies

**Required dependencies (already in pyproject.toml from Stories 2.1-2.2):**
- `motor ^3.5.0` - Async MongoDB driver
- `pydantic ^2.8.0` - Data validation (Pydantic v2)
- `pymongo ^4.0.0` - MongoDB utilities (bson.ObjectId)

**Dev dependencies:**
- `pytest ^8.3.0` - Test framework
- `pytest-asyncio ^0.24.0` - Async test support
- `pytest-cov` - Coverage reporting

[Source: docs/architecture/tech-stack.md]

### Type Hints and Async Patterns

**All repository methods MUST be async:**
```python
async def get_by_id(self, flow_id: str) -> FlowInDB | None:
    ...
```

**Use Motor async methods:**
- `await collection.find_one(query)`
- `await collection.find(query).to_list(length=100)`
- `await collection.insert_one(document)`
- `await collection.find_one_and_update(query, update, return_document=True)`
- `await collection.delete_one(query)`

**Type hints for generics:**
- `BaseRepository[ModelType]` where `ModelType` is bound to `BaseModel`
- `list[FlowInDB]` for return types (Python 3.12+ syntax)
- `FlowInDB | None` for optional returns (Python 3.12+ union syntax)

[Source: docs/architecture/coding-standards.md#naming-conventions]

### ObjectId Handling

**Convert string to ObjectId:**
```python
from bson import ObjectId

# In queries
doc = await self.collection.find_one({"_id": ObjectId(flow_id)})
```

**Handle invalid ObjectId:**
```python
from bson.errors import InvalidId

try:
    doc = await self.collection.find_one({"_id": ObjectId(flow_id)})
except InvalidId:
    return None  # Invalid ID format
```

**Pydantic models automatically serialize ObjectId to string:**
- Models use `@field_serializer('id')` to convert ObjectId ‚Üí str
- No manual conversion needed when returning Pydantic models

[Source: docs/stories/2.2.story.md#dev-notes]

### Enum Usage for Type Safety

**Python Enum Pattern:**
```python
from enum import Enum

class FlowPriority(str, Enum):
    """MUST inherit from str for JSON serialization."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
```

**Why inherit from `str`:**
- Enables JSON serialization without custom encoders
- Pydantic automatically validates enum values
- OpenAPI spec shows allowed values
- Matches TypeScript enum string values

**TypeScript equivalent (for reference):**
```typescript
enum FlowPriority {
  Low = 'low',      // PascalCase member names (TypeScript convention)
  Medium = 'medium',
  High = 'high'
}
```

**Key points:**
- Member names differ (Python: `LOW`, TypeScript: `Low`)
- String values match exactly (both: `"low"`)
- API contract uses string values, so it's consistent

[Source: docs/architecture/coding-standards.md#backend-enum-usage-python]

### Configuration Management

**Add configurable limit for flows:**
```python
# src/config.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # ... existing settings ...

    MAX_FLOWS_PER_CONTEXT: int = 100  # Add this setting
```

**Usage in repository:**
```python
from src.config import settings

# In get_all_by_context()
cursor = self.collection.find(query).sort("created_at", -1)
docs = await cursor.to_list(length=settings.MAX_FLOWS_PER_CONTEXT)
```

[Source: docs/stories/2.2.story.md#qa-resolution - PERF-001]

### Partial Update Pattern

**FlowUpdate model supports partial updates:**
```python
class FlowUpdate(BaseModel):
    title: str | None = Field(None, min_length=1, max_length=200)
    description: str | None = None
    priority: FlowPriority | None = None
```

**Repository update logic:**
```python
async def update(self, flow_id: str, updates: FlowUpdate) -> FlowInDB | None:
    # Only update fields that are not None
    data = {k: v for k, v in updates.model_dump().items() if v is not None}
    data["updated_at"] = datetime.now(UTC)

    result = await self.collection.find_one_and_update(
        {"_id": ObjectId(flow_id)},
        {"$set": data},
        return_document=True
    )
    return FlowInDB(**result) if result else None
```

[Source: docs/stories/2.2.story.md#dev-notes]

### Timezone-Aware Timestamps

**ALWAYS use timezone-aware datetimes:**
```python
from datetime import datetime, UTC

# ‚úÖ CORRECT
created_at = datetime.now(UTC)

# ‚ùå WRONG (naive datetime)
created_at = datetime.utcnow()  # Deprecated in Python 3.12+
```

[Source: docs/architecture/coding-standards.md#naming-conventions]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-07 | 1.0 | Story created for Epic 2.3 | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
[To be filled by Dev Agent]

### Debug Log References
[To be filled by Dev Agent]

### Completion Notes List
[To be filled by Dev Agent]

### File List
[To be filled by Dev Agent]

## QA Results
[To be filled by QA Agent]
