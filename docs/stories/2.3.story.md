# Story 2.3: Flow Repository with CRUD Operations (BE)

## Status
in review

## Story

**As a** backend developer,
**I want** a repository pattern implementation for Flow CRUD operations,
**so that** flows can be managed with proper validation and context association.

## Acceptance Criteria

1. **Repository class created in `my_flow_api/src/repositories/flow_repository.py`:**
   - `FlowRepository(db: AsyncIOMotorDatabase, context_repo: ContextRepository)` with injected dependencies
   - Methods: `create()`, `get_by_id()`, `get_all_by_context()`, `update()`, `delete()`, `mark_complete()`
   - All methods async with proper error handling and user-aware signatures

2. **Repository methods return typed Pydantic models with pagination support:**
   - `create(user_id: str, context_id: str, flow_data: FlowCreate) -> FlowInDB`
   - `get_by_id(user_id: str, flow_id: str) -> Optional[FlowInDB]`
   - `get_all_by_context(user_id: str, context_id: str, include_completed: bool = False, limit: int = 50, offset: int = 0) -> List[FlowInDB]`
   - `update(user_id: str, flow_id: str, updates: FlowUpdate) -> Optional[FlowInDB]`
   - `delete(user_id: str, flow_id: str) -> bool`
   - `mark_complete(user_id: str, flow_id: str) -> Optional[FlowInDB]`
   - Pagination parameters must be applied via MongoDB `skip()` and `limit()` chaining

3. **Validation includes:**
   - Context existence validation before flow creation
   - User authorization (verify requesting user owns the context and target flow before operations)
   - Completed flows cannot be marked complete again
   - Pagination parameters validated (`limit` ‚â• 1, `limit` ‚â§ `settings.MAX_FLOWS_PER_CONTEXT`, `offset` ‚â• 0, `offset` ‚â§ 10_000)

4. **Integration and security tests updated:**
   - `tests/integration/repositories/test_flow_repository.py` exercises CRUD operations, pagination (limit/offset), and `include_completed`
   - JWKS cache concurrency and stale-key fallback covered with async tests in `tests/unit/auth/test_jwks_cache.py`
   - Tests cover JWT claim validation failure paths (expired, not-before, future-issued tokens)
   - Overall coverage remains ‚â• 85% for affected modules

5. **Authentication hardening implemented:**
   - `LOGTO_JWKS_MAX_STALE_SECONDS` (default 7200 seconds) exposed in `src/config.py` and enforced during JWKS fallback
   - Stale JWKS cache entries older than configured threshold are rejected instead of silently re-used
   - `jwt.decode` explicitly validates `exp`, `nbf`, and `iat` claims
   - `get_current_user` dependency protected with `@limiter.limit("5/minute")` (or tighter per security guidelines)
   - Production startup enforces HTTPS redirection and rejects wildcard CORS origins

6. **Database indexing optimized for pagination:**
   - Compound index on `(context_id, user_id, is_completed, created_at)` created for `flows` collection
   - Existing index definitions updated to avoid redundant full-collection scans

## Tasks / Subtasks

- [x] **Task 1: Create Flow Pydantic models** (AC: 2)
  - [ ] Create `my_flow_api/src/models/flow.py`
- [ ] Define `FlowBase` with fields: `title` (str, 1-200 chars), `description` (Optional[str]), `priority` (Enum: "low" | "medium" | "high"), `is_completed` (bool), `created_at`, `updated_at`, `completed_at` (Optional[datetime])
  - [ ] Define `FlowCreate(BaseModel)` with fields `title`, `description`, `priority`, `context_id`
  - [ ] Define `FlowUpdate(BaseModel)` with all optional fields for partial updates
  - [ ] Define `FlowInDB(FlowBase)` with `id` (ObjectId), `context_id` (ObjectId), `user_id` (ObjectId), complete DB representation
  - [ ] Define `FlowResponse(FlowBase)` for API responses with ObjectId ‚Üí string serialization (include `context_id`, `user_id` fields as strings)
  - [ ] Create Python Enum `FlowPriority(str, Enum)` with LOW, MEDIUM, HIGH (must inherit from str for JSON serialization)
  - [ ] Add validators: `title` length (1-200), `priority` enum validation
  - [ ] Add `@field_serializer('id', 'context_id', 'user_id')` for ObjectId ‚Üí string conversion (Pydantic v2 pattern)
  - [ ] Use `ConfigDict(from_attributes=True)` for Pydantic v2 compatibility
  - [ ] Add `FlowListParams(BaseModel)` containing `include_completed: bool = False`, `limit: int = Field(50, ge=1)`, `offset: int = Field(0, ge=0, le=10_000)`

- [ ] **Task 2: Implement FlowRepository class** (AC: 1, 2, 3, 6)
  - [ ] Create `my_flow_api/src/repositories/flow_repository.py`
  - [ ] Inherit from `BaseRepository[FlowInDB]` (reuse from Story 2.2)
  - [ ] Implement `create(user_id: str, context_id: str, flow_data: FlowCreate) -> FlowInDB | None`
    - Validate context exists **and** belongs to `user_id` using ContextRepository
    - Merge `context_id`, `user_id`, `is_completed=False`, `created_at`, `updated_at` (UTC) into payload
    - Insert into `flows` collection
    - Return FlowInDB model with ObjectId serialized to string or None when validation fails
  - [ ] Implement `get_by_id(user_id: str, flow_id: str) -> Optional[FlowInDB]`
    - Query by `_id` and `user_id` (convert string to ObjectId)
    - Return None if not found or user mismatch
    - Convert MongoDB document to FlowInDB model
  - [ ] Implement `get_all_by_context(user_id: str, context_id: str, include_completed: bool = False, limit: int = 50, offset: int = 0) -> List[FlowInDB]`
    - Validate pagination inputs against `settings.MAX_FLOWS_PER_CONTEXT`
    - Query by `context_id` and `user_id`
    - Filter by `is_completed` based on `include_completed` parameter
    - Sort by `created_at` descending (most recent first)
    - Apply `.skip(offset)` and `.limit(limit)` (bounded by settings)
    - Return list of FlowInDB models
  - [ ] Implement `update(user_id: str, flow_id: str, updates: FlowUpdate) -> Optional[FlowInDB]`
    - Use `find_one_and_update()` with `return_document=True` (Pydantic v2)
    - Include user guard in filter (`{"_id": ObjectId(flow_id), "user_id": user_id}`)
    - Update `updated_at` timestamp
    - Only update fields that are not None (partial update pattern)
    - Return updated FlowInDB or None if not found/unauthorized
  - [ ] Implement `delete(user_id: str, flow_id: str) -> bool`
    - Delete flow document scoped by `user_id`
    - Return True if deleted, False if not found/unauthorized
  - [ ] Implement `mark_complete(user_id: str, flow_id: str) -> Optional[FlowInDB]`
    - Get current flow scoped by user to check `is_completed` status
    - If already completed, return None (idempotent operation)
    - Set `is_completed = True` and `completed_at = datetime.now(UTC)`
    - Update `updated_at` timestamp
    - Return updated FlowInDB or None if not found/unauthorized
  - [ ] Document error return patterns in method docstrings:
    - Clarify `None` return semantics for each method (not found vs validation failure vs unauthorized)
    - Example docstring: `"""Returns None if context not found (validation) or flow not found"""`
    - Document `False` return semantics for `delete()` method
    - Add docstring examples showing None/False return cases

- [ ] **Task 3: Add context and ownership validation to FlowRepository** (AC: 1, 3)
  - [ ] Inject `ContextRepository` into `FlowRepository.__init__()` for context validation
  - [ ] In `create()` method: call `context_repo.get_by_id()` to verify context exists **and** `context.user_id == user_id`
  - [ ] In read/update/delete/mark_complete methods: ensure flows queried with both `_id` and `user_id`
  - [ ] Short-circuit with `None`/`False` when validation fails (no exceptions)
  - [ ] Document context ownership + pagination validation pattern in method docstrings

- [ ] **Task 4: Update database.py to create flow indexes** (AC: 1, 6)
  - [ ] Update `my_flow_api/src/database.py` `create_indexes()` function
  - [ ] Add/confirm single-field index on `flows.context_id`
  - [ ] Add compound index on `flows.(context_id, user_id, is_completed, created_at)` for pagination queries
  - [ ] Remove/replace obsolete `(context_id, is_completed, priority)` index to avoid duplication
  - [ ] Verify indexes are created during app startup in lifespan event

- [ ] **Task 5: Export models and repository from __init__.py** (AC: 1, 2)
  - [ ] Update `my_flow_api/src/models/__init__.py`
  - [ ] Export `FlowBase`, `FlowCreate`, `FlowUpdate`, `FlowInDB`, `FlowResponse`, `FlowPriority`
  - [ ] Update `my_flow_api/src/repositories/__init__.py`
  - [ ] Export `FlowRepository`
  - [ ] Verify clean imports: `from src.repositories import FlowRepository`, `from src.models import FlowInDB`

- [ ] **Task 6: Write integration tests** (AC: 4)
  - [ ] Create `my_flow_api/tests/integration/repositories/test_flow_repository.py`
  - [ ] Reuse pytest fixtures from Story 2.2 (test MongoDB connection, cleanup)
  - [ ] Create fixture for FlowRepository instance with test DB
  - [ ] Create fixture for test context (needed for flow creation)
  - [ ] Test `create()`: Creates flow with context_id/user_id, returns FlowInDB with ID
  - [ ] Test `create()`: Returns None when context_id doesn't exist (validation)
  - [ ] Test `create()`: Returns None when context exists but belongs to different user
  - [ ] Test `get_by_id()`: Retrieves flow by ID scoped to owner
  - [ ] Test `get_by_id()`: Returns None for non-existent flow or mismatched user
  - [ ] Test `get_all_by_context()`: Returns paginated flows sorted by created_at desc using default limit/offset
  - [ ] Test `get_all_by_context()`: Filters completed flows when include_completed=False
  - [ ] Test `get_all_by_context()`: Includes completed flows when include_completed=True
  - [ ] Test `get_all_by_context()`: Applies `limit` bounds (rejects limit=0, clamps to MAX_FLOWS_PER_CONTEXT)
  - [ ] Test `get_all_by_context()`: Applies `offset` bounds (rejects offset > 10_000)
  - [ ] Test `get_all_by_context()`: Returns empty list for context with no flows
  - [ ] Test `update()`: Updates flow fields and updated_at timestamp
  - [ ] Test `update()`: Performs partial update (only updates provided fields)
  - [ ] Test `update()`: Returns None when flow not found or unauthorized
  - [ ] Test `delete()`: Deletes flow and returns True
  - [ ] Test `delete()`: Returns False when flow not found/unauthorized
  - [ ] Test `mark_complete()`: Sets is_completed=True and completed_at timestamp
  - [ ] Test `mark_complete()`: Returns None when flow already completed (idempotent)
  - [ ] Test `mark_complete()`: Returns None when flow not found/unauthorized
  - [ ] Add teardown fixture to clean up test data after each test
  - [ ] Ensure 85%+ coverage for flow_repository.py

- [ ] **Task 7: Run tests and verify coverage** (AC: 4, 5)
  - [ ] Run pytest: `pytest tests/integration/repositories/test_flow_repository.py -v --cov=src/repositories`
  - [ ] Run pytest: `pytest tests/unit/auth/test_jwks_cache.py -v --cov=src/auth`
  - [ ] Verify 85%+ coverage threshold met for repositories and auth modules touched
  - [ ] Fix any failing tests or edge cases discovered
  - [ ] Verify all async operations work correctly with Motor driver and auth cache locks

- [ ] **Task 8: Update configuration for pagination and JWKS** (AC: 2, 5)
  - [ ] Update `my_flow_api/src/config.py`
  - [ ] Ensure `MAX_FLOWS_PER_CONTEXT` remains configurable and referenced in repository pagination
  - [ ] Add `MAX_FLOW_QUERY_OFFSET` (default 10_000) for upper bound validation
  - [ ] Add `LOGTO_JWKS_MAX_STALE_SECONDS: int = 7200` with `.env` override support
  - [ ] Document new settings in config docstring and `.env.example`

- [ ] **Task 9: Harden JWKS cache implementation** (AC: 5)
  - [ ] Update `my_flow_api/src/auth/jwks.py` (or equivalent cache module)
  - [ ] When JWKS HTTP fetch fails, only fall back to cached keys if `now - cached_at <= LOGTO_JWKS_MAX_STALE_SECONDS`
  - [ ] Log and raise `HTTPException` (401) if cached keys exceed stale threshold
  - [ ] Guard concurrent refreshes with asyncio lock to prevent thundering herd
  - [ ] Expose helper for tests to inject fake timestamps

- [ ] **Task 10: Enforce JWT claim validation and rate limiting** (AC: 5)
  - [ ] Update `my_flow_api/src/auth/dependencies.py`
  - [ ] Pass `options={"require": ["exp", "nbf", "iat"], "verify_exp": True, "verify_nbf": True, "verify_iat": True}` to `jwt.decode`
  - [ ] Reject tokens with clock skew beyond ¬±60 seconds (configurable via existing setting)
  - [ ] Apply `@limiter.limit("5/minute")` to `get_current_user`
  - [ ] Add structured logging for rate-limit hits and claim verification failures

- [ ] **Task 11: Enforce production HTTPS and strict CORS** (AC: 5)
  - [ ] Update `my_flow_api/src/main.py` (FastAPI app factory)
  - [ ] Add `HTTPSRedirectMiddleware` when `settings.ENV == "production"`
  - [ ] Configure `CORSMiddleware` to reject wildcard origins in production (raise startup error if `"*"` configured)
  - [ ] Ensure allowable origins pulled from `settings.CORS_ALLOWED_ORIGINS`
  - [ ] Add unit tests covering CORS/HTTPS configuration guards

## Dev Notes

### Previous Story Insights (Story 2.2)

**Key Learnings:**
- Pydantic v2 patterns: Use `ConfigDict` instead of deprecated `Config` class
- Use `@field_serializer('id')` for ObjectId ‚Üí string conversion (replaces `json_encoders`)
- Use `@field_validator` for custom validation (timezone checks, format validation)
- Python Enum classes (inherit from `str, Enum`) for type-safe enums matching TypeScript
- Repository layer intentionally returns None/False for not-found/unauthorized cases (service layer handles HTTP responses)
- Made `get_all_by_user()` limit configurable via settings.MAX_CONTEXTS_PER_USER (default: 100)
- All 104 tests passing with 91.58% coverage after QA fixes

[Source: docs/stories/2.2.story.md#dev-agent-record]

### Repository Pattern Architecture

**FlowRepository extends BaseRepository:**
```python
from src.config import settings
from src.repositories.base import BaseRepository
from src.repositories.context_repository import ContextRepository
from src.models.flow import FlowInDB, FlowCreate, FlowUpdate
from motor.motor_asyncio import AsyncIOMotorDatabase
from bson import ObjectId
from datetime import datetime, UTC

class FlowRepository(BaseRepository[FlowInDB]):
    def __init__(self, db: AsyncIOMotorDatabase, context_repo: ContextRepository):
        super().__init__(db, "flows", FlowInDB)
        self.context_repo = context_repo

    async def create(self, user_id: str, context_id: str, flow_data: FlowCreate) -> FlowInDB | None:
        """Create new flow with context + ownership validation."""
        context = await self.context_repo.get_by_id(user_id, context_id)
        if not context:
            return None

        payload = flow_data.model_dump()
        payload.update(
            {
                "context_id": ObjectId(context_id),
                "user_id": ObjectId(user_id),
                "is_completed": False,
                "created_at": datetime.now(UTC),
                "updated_at": datetime.now(UTC),
                "completed_at": None,
            }
        )
        insert_result = await self.collection.insert_one(payload)
        payload["_id"] = insert_result.inserted_id
        return FlowInDB(**payload)

    async def get_all_by_context(
        self,
        user_id: str,
        context_id: str,
        include_completed: bool = False,
        limit: int = 50,
        offset: int = 0,
    ) -> list[FlowInDB]:
        """Find flows for a context, honoring pagination + status filters."""
        limit = min(max(limit, 1), settings.MAX_FLOWS_PER_CONTEXT)
        if offset > settings.MAX_FLOW_QUERY_OFFSET:
            raise ValueError("offset exceeds MAX_FLOW_QUERY_OFFSET")

        query = {"context_id": ObjectId(context_id), "user_id": ObjectId(user_id)}
        if not include_completed:
            query["is_completed"] = False

        cursor = (
            self.collection
            .find(query)
            .sort("created_at", -1)
            .skip(offset)
            .limit(limit)
        )
        docs = await cursor.to_list(length=limit)
        return [FlowInDB(**doc) for doc in docs]

    async def mark_complete(self, user_id: str, flow_id: str) -> FlowInDB | None:
        """Mark flow as completed with timestamp."""
        # Check current status while scoping by user
        flow = await self.get_by_id(user_id, flow_id)
        if not flow or flow.is_completed:
            return None  # Already completed or not found

        now = datetime.now(UTC)
        result = await self.collection.find_one_and_update(
            {"_id": ObjectId(flow_id), "user_id": ObjectId(user_id)},
            {
                "$set": {
                    "is_completed": True,
                    "completed_at": now,
                    "updated_at": now,
                }
            },
            return_document=True,
        )
        return FlowInDB(**result) if result else None
```

[Source: docs/architecture/backend-architecture.md#repository-layer-data-access]

### Flow Data Model

**Flow Model Fields:**
```python
from pydantic import BaseModel, Field, field_serializer, ConfigDict
from datetime import datetime
from enum import Enum
from bson import ObjectId

class FlowPriority(str, Enum):
    """Flow priority levels (must inherit from str for JSON serialization)."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"

class FlowBase(BaseModel):
    title: str = Field(..., min_length=1, max_length=200)
    description: str | None = None
    priority: FlowPriority = FlowPriority.MEDIUM
    is_completed: bool = False
    created_at: datetime | None = None
    updated_at: datetime | None = None
    completed_at: datetime | None = None

class FlowCreate(BaseModel):
    title: str = Field(..., min_length=1, max_length=200)
    description: str | None = None
    priority: FlowPriority = FlowPriority.MEDIUM
    context_id: str

class FlowUpdate(BaseModel):
    title: str | None = Field(None, min_length=1, max_length=200)
    description: str | None = None
    priority: FlowPriority | None = None
    is_completed: bool | None = None

class FlowInDB(FlowBase):
    id: ObjectId = Field(alias="_id")
    context_id: ObjectId
    user_id: ObjectId

    model_config = ConfigDict(from_attributes=True)

    @field_serializer("id", "context_id", "user_id")
    def serialize_object_id(self, v: ObjectId) -> str:
        return str(v)

class FlowResponse(FlowBase):
    id: str
    context_id: str
    user_id: str

class FlowListParams(BaseModel):
    include_completed: bool = False
    limit: int = Field(50, ge=1)
    offset: int = Field(0, ge=0, le=10_000)
```

[Source: docs/architecture/data-models.md#flow-model]

### MongoDB Indexes for Flows

**Required Indexes:**
- **Single field index on `context_id`**: Optimizes `get_all_by_context()` lookups
- **Compound index on `(context_id, user_id, is_completed, created_at)`**: Optimizes user-scoped pagination queries

**Index Rationale:**
- Users will frequently list flows within a context (Flow List UI)
- Filtering by completion status is common (show only active flows)
- Sorting by priority enables priority-based flow ordering
- Compound index covers filtering by context + user + completion + default sort order

[Source: docs/architecture/data-models.md#database-indexes-mongodb]

### Context Validation Pattern

**Dependency Injection for Context Validation:**
```python
class FlowRepository(BaseRepository[FlowInDB]):
    def __init__(self, db: AsyncIOMotorDatabase, context_repo: ContextRepository):
        super().__init__(db, "flows", FlowInDB)
        self.context_repo = context_repo  # Inject for validation

    async def create(self, user_id: str, context_id: str, flow_data: FlowCreate) -> FlowInDB | None:
        # Validate context exists AND belongs to user before creating flow
        context = await self.context_repo.get_by_id(user_id, context_id)
        if not context:
            return None  # Context not found / unauthorized

        # Proceed with flow creation...
```

**Why return None instead of raising exception:**
- Repository layer focuses on data access patterns
- Service layer handles business logic and HTTP responses
- None/False returns are intentional (from Story 2.2 QA review)

[Source: docs/stories/2.2.story.md#qa-resolution]

### Testing Standards

**Integration Test Setup:**
```python
# tests/integration/repositories/test_flow_repository.py
import pytest
from motor.motor_asyncio import AsyncIOMotorClient
from src.repositories.flow_repository import FlowRepository
from src.repositories.context_repository import ContextRepository
from src.models.context import ContextCreate
from src.models.flow import FlowCreate, FlowPriority

@pytest.fixture
async def test_db():
    """Provides test database connection."""
    client = AsyncIOMotorClient("mongodb://localhost:27017")
    db = client["myflow_test"]
    yield db
    # Cleanup: drop test database after all tests
    await client.drop_database("myflow_test")
    client.close()

@pytest.fixture
async def context_repository(test_db):
    """Provides ContextRepository instance with test DB."""
    return ContextRepository(test_db)

@pytest.fixture
async def flow_repository(test_db, context_repository):
    """Provides FlowRepository instance with test DB."""
    return FlowRepository(test_db, context_repository)

@pytest.fixture
async def test_context(context_repository):
    """Creates a test context for flow creation."""
    user_id = "test_user_id"
    context_data = ContextCreate(
        name="Test Context",
        color="#3B82F6",
        icon="üíº"
    )
    context = await context_repository.create(user_id, context_data)
    return user_id, context

@pytest.fixture
async def cleanup_flows(test_db):
    """Cleans up flows collection after each test."""
    yield
    await test_db.flows.delete_many({})
```

**Test Organization:**
- Integration tests: `tests/integration/repositories/test_flow_repository.py`
- Auth cache unit tests: `tests/unit/auth/test_jwks_cache.py`
- Use pytest-asyncio for async test support (`@pytest.mark.asyncio`)
- Each test should create fresh data and clean up after
- Use descriptive test names: `test_create_flow_success`, `test_mark_complete_idempotent`, `test_get_all_by_context_enforces_offset_cap`, `test_jwks_cache_rejects_stale`

**Coverage Requirements:**
- 85% minimum coverage for repository files
- Test both success and error paths
- Test context validation (invalid context_id)
- Test edge cases (empty results, invalid IDs, already completed flows)

[Source: docs/architecture/13-testing-strategy.md#test-organization]

### Backend File Structure

**Repository directory:**
```
my_flow_api/src/repositories/
‚îú‚îÄ‚îÄ __init__.py          # Export all repositories
‚îú‚îÄ‚îÄ base.py              # BaseRepository generic class (from Story 2.2)
‚îú‚îÄ‚îÄ context_repository.py # ContextRepository (from Story 2.2)
‚îú‚îÄ‚îÄ flow_repository.py   # FlowRepository implementation (THIS STORY)
‚îî‚îÄ‚îÄ exceptions.py        # RepositoryError base class
```

**Models directory:**
```
my_flow_api/src/models/
‚îú‚îÄ‚îÄ __init__.py          # Export all models
‚îú‚îÄ‚îÄ context.py           # Context models (from Story 2.1)
‚îî‚îÄ‚îÄ flow.py              # Flow models (THIS STORY)
```

**Test directory:**
```
my_flow_api/tests/integration/repositories/
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ conftest.py          # Test fixtures (DB connection, cleanup) - REUSE from Story 2.2
‚îú‚îÄ‚îÄ test_context_repository.py  # From Story 2.2
‚îî‚îÄ‚îÄ test_flow_repository.py     # FlowRepository integration tests (THIS STORY)
```

[Source: docs/architecture/9-unified-project-structure.md#backend-structure]

### Python Dependencies

**Required dependencies (already in pyproject.toml from Stories 2.1-2.2):**
- `motor ^3.5.0` - Async MongoDB driver
- `pydantic ^2.8.0` - Data validation (Pydantic v2)
- `pymongo ^4.0.0` - MongoDB utilities (bson.ObjectId)

**Dev dependencies:**
- `pytest ^8.3.0` - Test framework
- `pytest-asyncio ^0.24.0` - Async test support
- `pytest-cov` - Coverage reporting

[Source: docs/architecture/tech-stack.md]

### Type Hints and Async Patterns

**All repository methods MUST be async:**
```python
async def get_by_id(self, user_id: str, flow_id: str) -> FlowInDB | None:
    ...
```

**Use Motor async methods:**
- `await collection.find_one(query)`
- `await collection.find(query).to_list(length=100)`
- `await collection.insert_one(document)`
- `await collection.find_one_and_update(query, update, return_document=True)`
- `await collection.delete_one(query)`

**Type hints for generics:**
- `BaseRepository[ModelType]` where `ModelType` is bound to `BaseModel`
- `list[FlowInDB]` for return types (Python 3.12+ syntax)
- `FlowInDB | None` for optional returns (Python 3.12+ union syntax)

[Source: docs/architecture/coding-standards.md#naming-conventions]

### ObjectId Handling

**Convert string to ObjectId:**
```python
from bson import ObjectId

# In queries
doc = await self.collection.find_one({"_id": ObjectId(flow_id)})
```

**Handle invalid ObjectId:**
```python
from bson.errors import InvalidId

try:
    doc = await self.collection.find_one({"_id": ObjectId(flow_id)})
except InvalidId:
    return None  # Invalid ID format
```

**Pydantic models automatically serialize ObjectId to string:**
- Models use `@field_serializer('id')` to convert ObjectId ‚Üí str
- No manual conversion needed when returning Pydantic models

[Source: docs/stories/2.2.story.md#dev-notes]

### Enum Usage for Type Safety

**Python Enum Pattern:**
```python
from enum import Enum

class FlowPriority(str, Enum):
    """MUST inherit from str for JSON serialization."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
```

**Why inherit from `str`:**
- Enables JSON serialization without custom encoders
- Pydantic automatically validates enum values
- OpenAPI spec shows allowed values
- Matches TypeScript enum string values

**TypeScript equivalent (for reference):**
```typescript
enum FlowPriority {
  Low = 'low',      // PascalCase member names (TypeScript convention)
  Medium = 'medium',
  High = 'high'
}
```

**Key points:**
- Member names differ (Python: `LOW`, TypeScript: `Low`)
- String values match exactly (both: `"low"`)
- API contract uses string values, so it's consistent

[Source: docs/architecture/coding-standards.md#backend-enum-usage-python]

### Configuration Management

**Add configurable limit for flows and pagination bounds:**
```python
# src/config.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # ... existing settings ...

    MAX_FLOWS_PER_CONTEXT: int = 100
    MAX_FLOW_QUERY_OFFSET: int = 10_000
    LOGTO_JWKS_MAX_STALE_SECONDS: int = 7200
```

**Usage in repository:**
```python
from src.config import settings

# In get_all_by_context()
limit = min(max(limit, 1), settings.MAX_FLOWS_PER_CONTEXT)
if offset > settings.MAX_FLOW_QUERY_OFFSET:
    raise ValueError("offset exceeds MAX_FLOW_QUERY_OFFSET")
```

[Source: docs/stories/2.2.story.md#qa-resolution - PERF-001]

### Partial Update Pattern

**FlowUpdate model supports partial updates:**
```python
class FlowUpdate(BaseModel):
    title: str | None = Field(None, min_length=1, max_length=200)
    description: str | None = None
    priority: FlowPriority | None = None
```

**Repository update logic:**
```python
async def update(self, flow_id: str, updates: FlowUpdate) -> FlowInDB | None:
    # Only update fields that are not None
    data = {k: v for k, v in updates.model_dump().items() if v is not None}
    data["updated_at"] = datetime.now(UTC)

    result = await self.collection.find_one_and_update(
        {"_id": ObjectId(flow_id)},
        {"$set": data},
        return_document=True
    )
    return FlowInDB(**result) if result else None
```

[Source: docs/stories/2.2.story.md#dev-notes]

### Timezone-Aware Timestamps

**ALWAYS use timezone-aware datetimes:**
```python
from datetime import datetime, UTC

# ‚úÖ CORRECT
created_at = datetime.now(UTC)

# ‚ùå WRONG (naive datetime)
created_at = datetime.utcnow()  # Deprecated in Python 3.12+
```

[Source: docs/architecture/coding-standards.md#naming-conventions]

### JWKS Cache Hardening

**Stale fallback guard:**
```python
from datetime import datetime, UTC
from fastapi import HTTPException, status

if fetch_failed:
    if not cached_keys or (datetime.now(UTC) - cached_keys.fetched_at).total_seconds() > settings.LOGTO_JWKS_MAX_STALE_SECONDS:
        raise HTTPException(status.HTTP_401_UNAUTHORIZED, "JWKS keys expired")
    return cached_keys
```

- Cache entries store `fetched_at` timestamp for staleness checks
- Wrap network refresh in `asyncio.Lock` to prevent concurrent fetches racing

### JWT Claim Validation & Rate Limiting

- Call `jwt.decode(..., options={"require": ["exp", "nbf", "iat"], "verify_exp": True, "verify_nbf": True, "verify_iat": True})`
- Reject tokens where `iat` is in the future (allow ¬±60s skew via `leeway`)
- Decorate `get_current_user` with `@limiter.limit("5/minute")`
- Log authentication failures with context (user_id claim, reason)

### Production HTTPS & CORS Guardrails

- Add `HTTPSRedirectMiddleware` when `settings.ENV == "production"`
- Fail startup if `"*"` present in `settings.CORS_ALLOWED_ORIGINS` for production profiles
- Accept explicit origins only; include tests verifying misconfiguration raises `RuntimeError`

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-07 | 1.0 | Story created for Epic 2.3 | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
claude-sonnet-4-5-20250929

### Debug Log References
None - No blocking issues encountered

### Completion Notes List
- Ensure Flow models include `user_id` (ObjectId) and expose pagination params via `FlowListParams`
- FlowRepository methods now accept `user_id`, enforce pagination bounds, and return typed models
- Context validation must verify both existence and ownership using ContextRepository
- Database indexes updated to `(context_id, user_id, is_completed, created_at)` to support pagination
- Config introduces `MAX_FLOW_QUERY_OFFSET` and `LOGTO_JWKS_MAX_STALE_SECONDS` with documentation
- JWKS cache fallback rejects keys older than allowed stale window and guards concurrent refreshes
- JWT decoding explicitly verifies `exp`, `nbf`, `iat`; `get_current_user` guarded by rate limiting
- Production middleware enforces HTTPS and strict CORS configuration without wildcard origins
- New tests required for pagination edges and JWKS cache concurrency/expiration paths

### File List

- **Modified Files:**
- `my_flow_api/src/config.py`
- `my_flow_api/src/models/flow.py`
- `my_flow_api/src/repositories/__init__.py`
- `my_flow_api/src/repositories/flow_repository.py`
- `my_flow_api/src/database.py`
- `my_flow_api/src/auth/jwks.py`
- `my_flow_api/src/auth/dependencies.py`
- `my_flow_api/src/main.py`
- `my_flow_api/tests/integration/repositories/test_flow_repository.py`
- `my_flow_api/tests/unit/auth/conftest.py` (if supporting fixtures needed)
- `.env.example`

**New Files:**
- `my_flow_api/tests/unit/auth/test_jwks_cache.py` (if not present)

## QA Results

### Review Summary (2025-10-09)

- **Reviewer:** Quinn (Test Architect)
- **Gate Decision:** **FAIL** ‚Äî Story lacked pagination parameters, user scoping, critical index guidance, JWKS staleness guard, JWT claim validation, rate limiting, HTTPS enforcement, and CORS hardening instructions.
- **High-Priority Follow-ups:** Add pagination validation ranges, rate limiting for `get_current_user`, HTTPS middleware in production, CORS allow-list enforcement, and regression tests for JWKS concurrency plus pagination edge cases.

### Resolution Updates (2025-10-10)

- Acceptance Criteria now capture user-aware signatures, pagination parameters, security hardening, and index requirements.
- Tasks 1‚Äì11 expanded to cover Flow model updates, repository pagination limits, compound index creation, JWKS stale guard, JWT claim enforcement, rate limiting, HTTPS middleware, and CORS restrictions.
- Dev Notes include detailed examples for pagination bounds, JWKS cache logic, JWT decoding options, and production middleware expectations.
- Testing guidance now calls for pagination boundary tests and JWKS concurrency/staleness regression tests; File List updated with config/auth/main touchpoints plus new auth unit tests.

### Current Status

- **Gate:** ‚è≥ **Pending Re-review** ‚Äî Awaiting QA confirmation after these documentation updates.
- **Next Action:** Submit revised story to QA (Quinn) for validation; update `docs/qa/gates/2.3-flow-repository-crud.yml` once approved.
